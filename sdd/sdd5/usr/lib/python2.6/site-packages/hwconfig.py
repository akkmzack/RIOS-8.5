#!/usr/bin/python
from xml.dom.minidom import parse
from os import stat
from sys import exit
from hwtool_util import rlog_debug, rlog_info, rlog_warning, get_devid_cnt 
from appliance_util import *


###############################################################################
# Config Class
#
# these parameters are filled in from the configuration file (config.xml)
#
###############################################################################


class Config:
    def __init__(self, config_path=''):
        self.__mobos       = []
        self.__cards       = []
        self.__nics        = []
        self.__config_path = config_path

        self.__read_config()

    def get_mobos(self):
        return self.__mobos

    def get_cards(self):
        return self.__cards

    def get_nics(self):
        return self.__nics

    ###########################################################################
    # read_config
    #
    # Read the specs.xml file and populate associative arrays of Config
    #
    ###########################################################################
    def __read_config(self):
        config_file = self.__config_path
        if config_file == '':
            config_file = "/opt/tms/lib/hwtool/config/config.xml"

        mfg_config_file = "/etc/config.xml"

        try:
            stat(config_file)
            name = config_file
        except OSError:
            try:
                stat(mfg_config_file)
                name = mfg_config_file
            except OSError:
                print 'Unable to find specs.xml'
                exit (1)

        rlog_debug('Using spec file :' + name)
        dom = parse(name)
        mobos = dom.getElementsByTagName('motherboard')
        for mb in mobos:
            mobo = Motherboard()
            mobo.dname = mb.getAttribute('display_name')
            mobo.part_num = mb.getAttribute('part_number')
            mobo.name_keys = mb.getAttribute('name_keys').split(',')
            mobo.use_gpio = mb.getAttribute('use_gpio')
            if mb.getAttribute('gpio_mask'):
                (mobo.gpio_mask, mobo.gpio_res) = mb.getAttribute('gpio_mask').split(',')
            mobo.type = mb.getAttribute('type')
            mobo.kernel_opts = mb.getAttribute('kernel_opts')
            mobo.virtual = mb.getAttribute('is_virtual') # *** USED ONLY FOR BOB, NOT SH ***
            mobo.is_vm = mb.getAttribute('is_vm') # *** USED FOR SH ***
            mobo.isbob = mb.getAttribute('is_bob')
            if mb.getAttribute('backplane_keys'):
                mobo.backplane_keys = mb.getAttribute('backplane_keys').split(',')
            if mb.getAttribute('redfin_keys'):
                mobo.redfin_keys = mb.getAttribute('redfin_keys').split(',')
            else:
                mobo.redfin_keys = []
            if mb.hasAttribute('yt_model_type'):
                mobo.yt_model_type = mb.getAttribute('yt_model_type')

            if mb.getAttribute('usb_based'):
                if mb.getAttribute('usb_based') == 'true':
                    mobo.usb_based = True
		else:
		    mobo.usb_based = False

            # mobo passthru inpath indicates whether or not we are configuring 
            # the inpath devices for passthrough on this system
            if mb.hasAttribute('passthru_inpath'):
                mobo.passthru_inpath = mb.getAttribute('passthru_inpath') == 'true'
            else:
                mobo.passthru_inpath = False

            integrated_pci_cfg_list = mb.getElementsByTagName('integrated_pci')
            if integrated_pci_cfg_list != None and \
                integrated_pci_cfg_list != []:
                for node in integrated_pci_cfg_list:
                    pattern      = node.getAttribute('bus_number_pattern')
                    name         = node.getAttribute('name')
                    passthru_str = node.getAttribute('passthru')

                    if passthru_str == 'true':
                        passthru = True
                    else:
                        passthru = False

                    idev = IntegratedPciDevice(name, pattern, passthru)
                    if pattern != None and pattern != '' and name != None and \
                        name != '':
                        mobo.integrated_pci.append(idev)
                    else:
                        rlog_warning('invalid integrated device node %s' % \
                                     mobo.dname)

            # Cant run a loop for the elements and reply on the IndexError exception
            # cause the XML file does not have all the entries set and replies on 
            # missing values to assume the value
            # eg: if ipmi_support missing, it means 'false'
            try:
                hal = mb.getElementsByTagName('hal')[0]
                mobo.hal_path = hal.getAttribute('path')
            except IndexError:
                rlog_debug('hal path missing for mobo %s' % mobo.dname)
                mobo.hal_path = ''
                pass

            try:
                branding = mb.getElementsByTagName('branding')[0]
                mobo.branding = branding.getAttribute('supported')
                if branding.getAttribute('who_checks_disk') == 'host':
                    mobo.disk_brand_checker = 'host'
                else:
                    # anything else is 'rios'
                    mobo.disk_brand_checker = 'rios'

                if branding.getAttribute('mem_lic_check') == 'false':
                    mobo.mem_lic_check = 'false'
                else:
                    # anything else is 'true'
                    mobo.mem_lic_check = 'true'

            except IndexError:
                rlog_debug('branding info missing for mobo %s' % mobo.dname)
                mobo.branding = 'false'
                mobo.disk_brand_checker = 'rios'
                mobo.mem_lic_check = 'true'
                pass

            try:
                flexl = mb.getElementsByTagName('flexlicence')[0]
                mobo.flexl = flexl.getAttribute('supported')
            except IndexError:
                rlog_debug('flexible licensing info missing for mobo %s' % mobo.dname)
                mobo.flexl = 'false'
                pass

            try:
                rev = mb.getElementsByTagName('revision')[0]
                mobo.revision = rev.getAttribute('id')
            except IndexError:
                rlog_debug('revision info missing for mobo %s' % mobo.dname)
                mobo.revision = ''
                pass

            try:
                hwalarm = mb.getElementsByTagName('hwalarm')[0]
                mobo.hwalarm = hwalarm.getAttribute('supported')
            except IndexError:
                rlog_debug('hwalarm info missing for mobo %s' % mobo.dname)
                mobo.hwalarm = 'none'
                pass

            try:
                ipmi = mb.getElementsByTagName('ipmi')[0]
                mobo.ipmi_support = True
            except IndexError:
                mobo.ipmi_support = False
                pass

            try:
                onboard_nics_list = mb.getElementsByTagName('onboard_nics')
                for onboard_nics in onboard_nics_list:
                    update_mobo = False
                    # update the mobo in 2 situations
                    # we havent matched the onboard pattern name specified by 
                    # our product OR this is the first time we're seeing a pattern
                    if onboard_nics.getAttribute('name'):
                        if onboard_nics.getAttribute('name') == get_onboard_nic_pattern_name():
                            # we found the spec for this product
                            update_mobo = True
                    elif mobo.onboard_pattern == '':
                        update_mobo = True

                    if update_mobo:
                        mobo.onboard_pattern = onboard_nics.getAttribute('bus_number_pattern')
                        if onboard_nics.getAttribute('primary_first') == "true":
                            mobo.primary_first = True
                        else:
                            mobo.primary_first = False

                        try:
                            if onboard_nics.getAttribute('num_ifs') == '1':
                                mobo.num_ifs = 1
                            else:
                                mobo.num_ifs = 2
                                dev_id = onboard_nics.getAttribute('search_devid')
                                if get_devid_cnt(dev_id) == '1':
                                    # Primary only case
                                    mobo.num_ifs = 1
                                
                        except Exception:
                            mobo.num_ifs = 2
                            try:
                                dev_id = onboard_nics.getAttribute('search_devid')
                                if get_devid_cnt(dev_id) == '1':
                                    # Primary only case
                                    mobo.num_ifs = 1
                            except Exception:
                                mobo.num_ifs = 2
                                pass

            except IndexError:
                rlog_info('No onboard NIC cards for motherboard %s' % mobo.dname)
                pass

            try:
                slots = mb.getElementsByTagName('slot')
                for sl in slots:
                    pattern = (sl.getAttribute('number'), sl.getAttribute('bus_number_pattern'))
                    mobo.slot_patterns.append(pattern)
            except IOError:
                rlog_info('Something incorrect while parsing slots for motherboard %s' % mobo.dname)
                pass

            try:
                disks = mb.getElementsByTagName('disk')
                for di in disks:
                    # start_offset is set to 0 for disk elements, as they identify only
                    # a single disk.
                    pattern = (di.getAttribute('number'), di.getAttribute('pattern'), 
                               di.getAttribute('bus'), di.getAttribute('prefix'), 0)
                    mobo.disk_patterns.append(pattern)
            except IOError:
                rlog_warning('Something incorrect while parsing disk for motherboard %s' % mobo.dname)
                pass

            try:
                diskarrays = mb.getElementsByTagName('disk-array')
                for da in diskarrays:
		    start_offset_str = da.getAttribute('start_offset')
                    if start_offset_str == '' or start_offset_str == None:
                        start_offset = 0
                    else:
                        start_offset = int(start_offset_str)
                        
                    # we don't use a pattern for disk arrays, since we assume we
                    # have a unique port id somewhere exposed for disk-arrays
                    # only supports MPT at the moment
                    pattern = (da.getAttribute('number'), da.getAttribute('pattern'), 
                               da.getAttribute('bus'), da.getAttribute('prefix'), 
                               start_offset)
                    #
                    # disk arrays are handled in a special way, they
                    mobo.disk_patterns.append(pattern)
            except IOError:
                rlog_warning('Something incorrect while parsing disk arrays for motherboard %s' % mobo.dname)
                pass
        
            self.__mobos.append(mobo)

        cards = dom.getElementsByTagName('card')
        for c in cards:
            card = Card()
            try:
                card.dname = c.getAttribute('display_name')
                card.part_num = c.getAttribute('part_number')
                card.name_keys = c.getAttribute('name_keys').split(',')
            except IOError:
                rlog_warning('Something incorrect while parsing card %s' % card.dname)
                pass

            self.__cards.append(card)

        nics = dom.getElementsByTagName('nic')
        for n in nics:
            nic = Nic()
            try:
                nic.dname = n.getAttribute('display_name')
                nic.part_num = n.getAttribute('part_number')

                if n.hasAttribute('vendor_name_keys'):
                    nic.vendor_name_keys = n.getAttribute('vendor_name_keys')
                else:
                    nic.vendor_name_keys = ''

                nic.name_keys = n.getAttribute('name_keys').split(',')
                nic.num_ifaces = int(n.getAttribute('num_interfaces'))
                nic.utility = n.getAttribute('utility')
                nic.block = n.getAttribute('wdt_capab_block')
                nic.wdt_type = n.getAttribute('wdt_type')
                nic.ordering = n.getAttribute('ordering')
                nic.ethtool_offset = n.getAttribute('ethtool_offset')
                nic.guest_order = n.getAttribute('guest_order')
                nic.if_naming = n.getAttribute('if_naming')
            except IOError:
                rlog_warning('Something incorrect while parsing NIC %s' % nic.dname)
                pass

            self.__nics.append(nic)

        return True
##############################################################
#  Integrated Pci Device
##############################################################
class IntegratedPciDevice:
    def __init__(self,
		 name,
                 bus_number_pattern,
                 passthru):

        self.__name = name
        self.__bus_number_pattern = bus_number_pattern
        self.__passthru = passthru
    
    def get_name(self):
        return self.__name

    def get_pattern(self):
        return self.__bus_number_pattern
  
    def get_passthru(self):
        return self.__passthru


##############################################################
#  Motherboard, container class for motherboard XML Entities
##############################################################

class Motherboard:
    def __init__(self):
        self.slot_patterns=[]
        self.name_keys=[]
        self.use_gpio=''
        self.gpio_mask=''
        self.gpio_res=''
        self.type=''
        self.disk_patterns=[]
        self.backplane_keys=[]
        self.redfin_keys=[]
        self.kernel_opts=''
        self.virtual=''
        self.isbob=''
        self.usb_based=False
        self.passthru_inpath=False
        # integrated PCI is a list of PCI devices that
        # are non removable on the motherboard.  This is mainly used
        # for integrated storage reporting on BOB
        self.integrated_pci=[]
        self.disk_brand_checker=''
        self.yt_model_type=''        


    dname=''
    part_num=''
    name_keys=[]
    use_gpio=''
    gpio_mask=''
    gpio_res=''
    type=''
    backplane_keys=[]
    redfin_keys=[]
    hal_path=''
    branding=''
    flexl=''
    revision=''
    ipmi_support=False
    hwalarm=''
    disk_brand_checker=''

    #nic handling
    onboard_pattern=''
    primary_first=None
    num_ifs=2
    slot_patterns=[]
    disk_patterns=[]

    def printo(self):
        print self.dname, self.part_num
        for k in self.name_keys:
            print k
        print self.hal_path
        print self.onboard_pattern, self.primary_first, self.use_gpio, self.gpio_mask, self.gpio_res, self.type
        for k in self.slot_patterns:
            print k

##############################################################
#  Card, container class for PCI-X card XML Entities
##############################################################

class Card:
    def __init__(self):
        self.name_keys = []
    dname=''
    part_num=''
    name_keys=[]
    wdt_type = ''

    def printo(self):
        print self.dname
        print self.part_num
        for k in self.name_keys:
            print k

##############################################################
#  Nic, specialized container for NIC XML Entities
##############################################################

class Nic (Card):
    num_ifaces=0
    ordering=0
    asc=1
    desc=2
    utility = ''
    block = ''
    ethtool_offset = ''
    if_naming = ''
    guest_order = ''
    wdt_type = ''

    def __str__(self):
        return "Nic %s %s" % (self.part_num, self.dname)

    def printo(self):
        print self.dname
        print self.part_num
        for k in self.name_keys:
            print k
        print self.num_ifaces
        print self.utility
        print self.block
        print self.wdt_type
        print self.ordering
        print self.ethtool_offset
        print self.guest_order

##############################################################
#  PciLink, container struct for association of lspci
#  and ifconfig parsing info pertaining to card position
#  and memory address.
##############################################################

class Pci_link:
    tnv_string = ''
    nv_string = ''
    bus_num = ''

    pci_id = ''
    pci_subid = ''
    memory_base = ''

    card = None

    def __str__(self):
        return "Pci_link %s %s %s (%s %s) %s" % \
                (self.tnv_string, self.nv_string, self.bus_num,
                        self.pci_id, self.pci_subid, self.memory_base)

    def printo(self):
        print self.tnv_string
        print self.nv_string
        print self.bus_num

        print self.pci_id
        print self.pci_subid
        print self.memory_base

        if self.card != None:
            self.card.printo()

