#!/usr/bin/python

from os.path import exists
from hwconfig import *
from hwtool_util import *
from hwtool_disk import *
from hwtool_nic import *
from hwtool_cpu import *
from re import compile as recompile
from time import sleep
from os import remove
import cPickle as pickle

HWTOOL_CACHE_FILE = "/tmp/hwtool.psave"
mobos, cards, nics, pci_links = [], [], [], []
config = None

##############################################################
# parse_config:
# Start parsing the config.xml config file
# Arguments: None
# return: True for success

def parse_config(config_path):
    global mobos, cards, nics, config
    # if the saved python object does exist
    # we will read the saved python object
    # from the cache file. 
    if exists (HWTOOL_CACHE_FILE):
        try:
            cache_file=open(HWTOOL_CACHE_FILE, "rb")
            config = pickle.load(cache_file)
            cache_file.close()
            mobos = config.get_mobos()
            cards = config.get_cards()
            nics = config.get_nics()
            return True
        except (IOError, pickle.UnpicklingError):
            print "Cannot read file %s" % HWTOOL_CACHE_FILE
            remove(HWTOOL_CACHE_FILE)
            pass
  
    config = Config(config_path)
    mobos = config.get_mobos()
    cards = config.get_cards()
    nics = config.get_nics()
    try:
        cache_file = open(HWTOOL_CACHE_FILE, "wb")
        pickle.dump(config, cache_file, pickle.HIGHEST_PROTOCOL)
        cache_file.close()
    except (IOError, pickle.PicklingError):
        print "Cannot write file %s" % HWTOOL_CACHE_FILE
        pass

    return True

## get_mobo_hint
#
# Reads dmidecode and hints at what the motherboard can be
# This function does not look in the backplane or GPIO, etc
# It will be used in situation where we want to load specific
# kernel modules for a family of motherboards and not all
def get_mobo_hint():
    base_info = dmidecode(' | grep -A 6 \"Base Board\"')

    mobo_family = {}
    mkey = ''
    pkey = ''

    mb = recompile("^\s+Manufacturer:\s+([\w\-]+).*$")
    pr = recompile("^\s+Product\sName:\s+([\w\-]+).*$")
    for b in base_info:
        mmb = mb.match(b)
        mpr = pr.match(b)

        if mmb:
            mkey = mmb.group(1)
        if mpr:
            pkey = mpr.group(1)

    for m in mobos:
        for k in m.name_keys:
            man = "sent"
            ks =  k.split()
            if len(ks) >= 2:
                man = ks[0]
                prod = ks[1]
            else:
                prod = ks[0]

            # Virtual model motherboard config entry, skip it
            if m.virtual == "true" or m.isbob == "true":
                continue

            if man == "sent":
                if prod.upper() == pkey.upper():
                        mobo_family[m.part_num] = 1
            else:
                if man.upper() == mkey.upper() and \
                        prod.upper() == pkey.upper():
                        mobo_family[m.part_num] = 1

    print ",".join(mobo_family.keys())

def get_mobo():
    base_info = dmidecode(' | grep -A 6 \"Base Board\"')

    mkey = ''
    pkey = ''

    mb = recompile("^\s+Manufacturer:\s+([\w\-]+).*$")
    pr = recompile("^\s+Product\sName:\s+([\w\-]+).*$")
    for b in base_info:
        mmb = mb.match(b)
        mpr = pr.match(b)

        if mmb:
            mkey = mmb.group(1)
        if mpr:
            pkey = mpr.group(1)

    vmware_value = ''
    vmware_mb_type = ''
    vm_machine = False
    # unclear whether, per comment to rev 73393, this code affects Hyper-V.
    # mkey == 'Microsoft' and pkey == 'Virtual' are the Manufacture and Product 
    # names for a Hyper-V VM based product.
    # see also bug 129015 and reviews 69562 and 69559.
    if not exists (VM_MOBO):
        # Could not find the VM_MOBO file
        # This means its the first attempt to get the MOBO string
        # Check to see if the BIOS says its a VM
        # If VM, run vmware-rpctool to figure out if its a BOB or VSH
        # mkey == 'Intel' and pkey == '440BX' is the Manufacture and Product 
        # name for a ESXi VM based product
        if mkey == 'Intel' and pkey == '440BX':
            try:
                vmware_value = vmwarerpctool("'info-get guestinfo.mobo'")[0]
                vmware_mb_type = vmwarerpctool("'info-get guestinfo.mobotype'")[0]
            except:
                # Could not execute the vmware-rpctool call
                # or the vmwarerpctool call returned 1 as there 
                # is no guestinfo.MOBO variable in the VSH vmx file
                vmware_value = 'VM'

            vm_machine = True

    else:
        # If BOB platform, the value is set at mfg time, else None
        (vmware_value, vmware_mb_type) = read_vm_model_file()
        if vmware_value != None and vmware_value != '':
            vm_machine = True

    for m in mobos:
        for k in m.name_keys:
            if vm_machine:
                if m.part_num == vmware_value and m.isbob == "true":
                    if vmware_mb_type != "":
                        if m.type != vmware_mb_type.strip():
                            continue
                    # Create the model file if it does not exist
                    create_vm_model_file(m.part_num, m.type)
                    return m

            man = "sent"
            ks =  k.split()
            if len(ks) >= 2:
                man = ks[0]
                prod = ks[1]
            else:
                prod = ks[0]

            # If virtual flag set, 
            # Virtual model motherboard config entry, skip it
            if m.virtual == "true" or m.isbob == "true":
                continue

            if man == "sent":
                if prod.upper() == pkey.upper():
                    if check_backplane_keys(m):
                        create_vm_model_file("", "")
                        return m
            else:
                if man.upper() == mkey.upper() and \
                        prod.upper() == pkey.upper():
                    if check_backplane_keys(m):
                        create_vm_model_file("", "")
                        # For Redfin motherboards we are using the GPIO's to figure out
                        # what the motherboard type is
                        # The PCI register to read is in the config file. 
                        # GPIO pin 56 is the one which changes state. For 1U off SB
                        # the pin is set to zero, For 1U|2U off LSI, the pin is set to 1
                        # the mask and the result are defined in the config file as well
                        if m.use_gpio != "":
                            if int(m.gpio_mask, 16) & \
                               int(read_pci_register(get_smbus_pattern(), m.use_gpio), 16) \
                               != int(m.gpio_res):
                                # GPIO pin does not match what is expected, this isn't
                                # the right motherboard, move on.
                                continue

                        if m.redfin_keys:
                            if len(m.redfin_keys) > 0:
                                # If we reached here and the box is a LSI based redfin
                                # Now we need to distinguish if it is a 1U or a 2U
                                # Check the backplane of the box for the correct key.
                                # NOTE: The above method of checking backplane_keys 
                                # wont work on redfins as the redfin EEPROM is not
                                # ipmitool readable. Hence we just skip that method
                                # and use this check here.
                                if not match_redfin_backplane(m):
                                    continue
                                
                        #Check for Yellowtail DVT/PVT model
                        #Check for FRU7. It must have valid content to be a PVT
                        try:
                            if m.yt_model_type != "":
                                if  (m.yt_model_type == "PVT" and is_yt_pvt() == True) or (m.yt_model_type == "Other" and is_yt_pvt() == False):
                                    return m
                                else:
                                    continue
                        except:
                            pass

                        return m


    #if we get here, we've failed, so exit cleanly.
    print "Couldn't find motherboard."
    exit(1)


def get_prod_type():
    return outcall(std='/bin/cat',
                   mfg='/bin/cat',
                   name='cat',
                   arg='/etc/build_version.sh | grep "^BUILD_PROD_ID=" | sed \'s/^BUILD_PROD_ID="//\' | sed \'s/"//\'')

def print_raid():
    print "TYPE: %s" % get_raid()


def get_system():
    spacer = '_______________________________'

    dmi = dmidecode()

    #information categories
    syt = recompile("System Information")
    mbo = recompile("Base Board Information")
    pro = recompile("Processor Information")
    cha = recompile("Chassis Information")
    mem = recompile("Use: System Memory")

    #subheadings 
    mfgr = recompile("Manufacturer: ([\s\w\.]+)")
    prod = recompile("Product Name: ([\s\w\-\/]+)")
    sped = recompile("Max Speed: ([\s\w]+)")
    capa = recompile("Maximum Capacity: ([\s\w]+)")

    looking_for = ''
    sys_vend, sys_prod, mbo_vend, mbo_prod = '', '', '', ''
    proc_vend, proc_speed, chas_vend, mem_cap = '', '', '', ''

    for line in dmi:
        #determine where we are
        if looking_for == '':
            if syt.search(line):
                looking_for = 'sys'
            elif mbo.search(line):
                looking_for = 'mbo'
            elif pro.search(line):
                looking_for = 'pro'
            elif cha.search(line):
                looking_for = 'cha'
            elif mem.search(line):
                looking_for = 'mem'
        else:
            if looking_for == 'sys':
                v = mfgr.search(line)
                p = prod.search(line)

                if v:
                    sys_vend = v.group(1)
                if p:
                    sys_prod = p.group(1)

                if sys_prod != '' and sys_vend != '':
                    looking_for = ''
            elif looking_for == 'mbo':
                v = mfgr.search(line)
                p = prod.search(line)

                if v:
                    mbo_vend = v.group(1)
                if p:
                    mbo_prod = p.group(1)

                if mbo_prod != '' and mbo_vend != '':
                    looking_for = ''
            elif looking_for == 'pro':
                v = mfgr.search(line)
                s = sped.search(line)

                if v:
                    proc_vend = v.group(1)
                if s:
                    proc_speed = s.group(1)

                if proc_vend != '' and proc_speed != '':
                    looking_for = ''
            elif looking_for == 'cha':
                v = mfgr.search(line)

                if v:
                    chas_vend = v.group(1)
                    looking_for = ''
            elif looking_for == 'mem':
                c = capa.search(line)

                if c:
                    mem_cap = c.group(1)
                    looking_for = ''

    print spacer
    print "System  "
    print " -     Vendor : %s" % sys_vend
    print " -    Product : %s" % sys_prod
    print spacer
    print "Motherboard  "
    print " -     Vendor : %s" % mbo_vend
    print " -    Product : %s" % mbo_prod
    print spacer
    print "Processor  "
    print " -     Vendor : %s" % proc_vend
    print " -  Max Speed : %s" % proc_speed #useless
    print spacer
    print "Chassis  "
    print " -     Vendor : %s" % chas_vend
    print spacer
    print "Memory "
    print " -   Capacity : %s" % mem_cap
    print spacer


def print_memory(query):
    dmi = dmidecode()
    mems = []
    section = ''
    temp_type, temp_locator, temp_size, temp_asset = '', '', '', None
    total = 0
    unbranded_total = 0
    mobo = get_mobo()
    brand_support = mobo.branding
    mem_lic_check = mobo.mem_lic_check
    partnum = mobo.part_num[0:9]

    for line in dmi:
        line = line.strip()
        if line == "Memory Device":
            section = "MD"
        elif 'MD' == section:
            if line[:4] == 'Size':
                temp_size = line[6:]
            elif line[:7] == 'Locator':
                temp_locator = line[9:]
            elif line[:5] == 'Type:':
                temp_type = line[6:]
            elif line[:9] == 'Asset Tag':
                temp_asset = line[11:]

            if '' != temp_size and '' != temp_type:
                if 'true' == brand_support:
                    # Some of the older models dont have the Asset tag line at all
                    # So dont keep running through the lines till asset found
                    # branding is supported on xx50 models onwards
                    # so Asset line will be present for those models
                    if None == temp_asset:
                        continue

                if temp_type != 'Flash':
                    if temp_size[:len(temp_size)-3].isdigit():
                        if temp_size[len(temp_size)-2:].lower() == 'kb':
                            temp_size = int(temp_size[:len(temp_size)-2])/1024
                        elif temp_size[len(temp_size)-2:].lower() == 'mb':
                            temp_size = int(temp_size[:len(temp_size)-2])
                        else:
                            temp_size = int(temp_size[:len(temp_size)-2]) * 1024

                    # If its a sturgeon motherboard, need remapping of DIMM's
                    # XXX/munirb: Bug 47608
                    # Need special remapping for Sturgeons as the BIOS naming
                    # does not match the motherboard silk screens
                    if partnum[0:9] == '400-00300':
                        try:
                            tmp_no = int(temp_locator[4:])
                            if tmp_no < 8:
                                tmp_no = 7 - tmp_no
                                temp_locator = 'CPU0 DIMM%s' % tmp_no
                            else:
                                tmp_no = 15 - tmp_no
                                temp_locator = 'CPU1 DIMM%s' % tmp_no
                        except ValueError:
                            temp_locator = 'Unknown'

                    mems.append((temp_type, temp_locator, temp_size, temp_asset))

                temp_size, temp_locator, temp_type, temp_asset = '', '', '', None
                section = ''

    dimm_info = ''
    unbranded_dimms = ''
    for mem in mems:
        type, locator, size, asset = mem
        if type != 'Flash':
            try:
                if 'true' == brand_support and 'false' != mem_lic_check:
                    if str(size).isdigit():
                        if compareAssetTag(asset):
                            total += int(size)
                            dimm_info += "%s: %s Licensed\n" % (locator, size)
                        else:
                            unbranded_total += int(size)
                            dimm_info += "%s: %s Unlicensed\n" % (locator, size)
                            unbranded_dimms += "%s " % (locator)
                    else:
                        dimm_info += "%s: %s\n" % (locator, size)
                else:
                    total += int(size)
                    dimm_info += "%s: %s Licensed\n" % (locator, size)
            except ValueError:
                pass # This way non-int entries don't crash everything.

    if query == '':
        print "Total Licensed Memory: %d GB" % int (total/1024)
        print "Total Unlicensed Memory: %d GB" % int (unbranded_total/1024)
        print dimm_info.strip()
        print "Number of DIMMs: %d" % len(mems)
    elif query == 'size':
        # Till the decision on branding is made use this hack
        # Later get rid of the unbranded part
        print total
    elif query == 'unlicensed_size':
        # Till the decision on branding is made use this hack
        # Later get rid of the unbranded part
        print unbranded_total
    elif query == 'unlicensed':
        if 0 < unbranded_total:
            return "true"
        else:
            return "false"
    elif query == 'unlicensed_dimms':
        print unbranded_dimms.strip()
    elif query == 'quantity':
        print len(mems)


def get_raid():
    output = cat(arg = '/proc/scsi/scsi')
    raid = recompile("Vendor: (\w+)")
    for line in output:
        r = raid.search(line)
        if r:
            vendor = r.group(1)
            if vendor == 'AMCC':
                return 'TW'
            elif vendor == 'MegaRAID':
                return 'LSI'
            elif vendor == 'ATA':
                return 'NONE'
            else:
                return 'UNKNOWN'
            break
    return 'NONE'


def get_disk(query):
    mobo = get_mobo()
    disks = Disks(mobo, get_branding())

    if query == 'map':
        print disks.get_map()
    elif query == 'unlicensed':
        return disks.get_unlicensed()
    elif query == 'quantity':
        print disks.get_quantity()
    elif query == 'size-licensed':
        for d, s in disks.get_branded():
            print "%s %s" % (d, s)
    elif query == 'quantity-licensed':
        print len(disks.get_branded())
    else:
        # size query is the default "query=size"
        for d, s in disks.get_size():
            print "%s %s" % (d, s)


def get_cpu(query):
    cores = Cores("RiOS")
    if query == 'speed':
        ret = cores.get_speed()
    elif query == 'cores':
        ret = cores.get_quantity()
    elif query == 'manufacturer':
        ret = cores.get_vendor()
    else:
        ret = "Manufacturer: %s\n" % cores.get_vendor()
        ret += "Number of cores: %d\n" % cores.get_quantity()
        ret += "Speed: %d MHz" % cores.get_speed()

    return ret

def print_cpu(query):
    print get_cpu(query)

def print_flash():
    print get_flash()


def get_flash():
    output = echo(arg = 'X`/bin/grep flash /proc/mounts`')[0]
    if output[1:] == '':
        return 'missing'
    else:
        return 'present'


# Return the CPU and disk info in a group
def get_groupinfo():
    disk_size = ''
    mobo = get_mobo()
    disks = Disks(mobo, get_branding())
    quant = 0

    # XXX This change is primarily being done to 
    # address RF boxes with eUSB + mSATA.
    # Localizing changes in this function to 'fix'
    # disk quantity (by excluding any disk not
    # havin prefix 'disk'). This change is less risky
    # than changing the way disk objects are instantiated.
    try:
        quant = int(disks.get_quantity())
    except ValueError:
        pass

    if (len(disks.get_size()) > 0) and (quant > 0):
        for d, s in disks.get_size():
            try:
                if d[:4] == 'disk':
                    disk_size = "%s%s,%s," % (disk_size, d[4:], s)
                else:
                    # If prefix is not 'disk' reduce the count of disks 
                    quant -= 1

            except IndexError:
                pass

        # Get rid of the additional ','
        disk_size = disk_size.rstrip(',')

    print "%s\t%s\t%d\t%s" % (get_cpu('cores'), get_cpu('speed'),
                              quant, disk_size)


def get_nic_card():
    mobo = get_mobo()
    nic = NIC(mobo, nics, cards)
    nic.get_nic_card()

def get_redirect_nics():
    mobo = get_mobo()
    nic = NIC(mobo, nics, cards)
    nic.get_redirect_nics()

def get_util(query, slot):
    mobo = get_mobo()
    nic = NIC(mobo, nics, cards)
    if mobo.isbob == 'true':
        nic.get_bob_nic_info(slot, query)
    else:
        nic.get_nic_info(slot, query)


def get_cli():
    mobo = get_mobo()
    nic = NIC(mobo, nics, cards)

    links = nic.make_pci_links()
    found_rev = False
    is_minnow = False
    print "Hardware revision:", mobo.revision
    try:
	eeprom_cont = outcall("/sbin/read_sh_eeprom.sh", "read_sh_eeprom.sh")
        found_rev = "Rev A" in eeprom_cont[3]
        is_minnow = "DTABA Minnow" in eeprom_cont[1]
    except IndexError:
        pass

    if (found_rev == True) and (is_minnow == True):
        print "Mainboard:  %s, %s PoE" % (mobo.dname, mobo.part_num)
    else:
        print "Mainboard:  %s, %s" % (mobo.dname, mobo.part_num)

    if mobo.isbob == 'true':
        print_bob_card_info(nic)
    else:
        print_card_info(mobo, nic, links)

## print_bob_card_info
#
# @param nic, NIC object 
#
# This function will print out all NIC card information for BOB based appliances
# 
def print_bob_card_info(nic):
    try:
        device_info = vmwarerpctool('\'info-get guestinfo.slotcard\' 2>/dev/null')[0]
        slot_no     = vmwarerpctool('\'info-get guestinfo.slot\' 2>/dev/null')[0]
    except HwtoolError:
        # This means there is no passthru slot
        # no need to do any further processing
        return

    card = nic.get_card_from_device_and_vendor(nics, device_info)
    if card == None:
        dname = "Unrecognized card"
        part_num = "Unknown"
    else:
        dname = card.dname
        part_num = card.part_num

    print "Slot %s: .......... %s, %s" % (slot_no,
                                          dname,
                                          part_num)

## print_card_info
#
# @param mobo, motherboard object for the current machine
# @param nic, NIC object 
# @param links, list of PCI buses 
#
# This function will print out all the NIC card information
# 
def print_card_info(mobo, nic, links):
    partnum = mobo.part_num[0:9]

    nicview = nic.generate_nic_view(if_only = False)
    for (slotnum, slotlinks) in nicview.get_all_slots():
        if slotlinks != []:
            card = nic.get_card_from_link(slotlinks[0])
            if card == None:
                dname = "Unrecognized card"
                part_num = "Unknown"
            else:
                dname = card.dname
                part_num = card.part_num
                # To distinuish between 2-port and 4-port minnow
                if partnum == '400-00098':
		    dname = '4 Port Copper GigE Network Bypass Module'
		    part_num = 'Integrated' 
		
                # To distinguish between 1-inpath and 2-inpath Guppy
                if partnum == '425-00120':
                    ports = outcall(std='/sbin/lspci',
                                    mfg='/sbin/lspci',
                                    name='lspci',
                                    arg=' -n | grep 8086:0438 | wc -l')
                    dname = ports[0] + ' Port Copper GigE Network Bypass Module'
                    part_num = 'Integrated'


            print "Slot %s: .......... %s, %s" % (slotnum,
                                                      dname,
                                                      part_num)



def print_address_map(gateway_naming):
    mobo = get_mobo()
    nic = NIC(mobo, nics, cards, gateway_naming)
    (branded, unbranded) = nic.get_brandsplit_ifconfig()
    for iface in branded:
        print "%s %s" % (iface.memory_base, iface.name)

def print_nic_license():
    mobo = get_mobo()
    nic = NIC(mobo, nics, cards)
    (branded, unbranded) = nic.get_brandsplit_ifconfig()
    for iface in branded:
        print "%s Licensed" % iface.name
    for iface in unbranded:
        print "%s Unlicensed" % iface.name


def print_licensed(pretty = True): 
    if pretty:
        print "Memory Information:"
        print "------------------------------"
        print_memory("")
        print "\n\nDisk Information:"
        print "------------------------------"
        print_disk_license()
        print "\n\nNIC Information"
        print "------------------------------"
        print_nic_license()
    else:
        nic_brand = "true"
        mobo = get_mobo()
        nic = NIC(mobo, nics, cards)
        (branded, unbranded) = nic.get_brandsplit_ifconfig()

        if not unbranded:
            nic_brand = "false"
        print "%s\t%s\t%s" % (print_memory("unlicensed"), get_disk("unlicensed"), nic_brand)


def get_mactab(out_path, gateway_naming):
    mobo = get_mobo()
    if mobo.isbob == 'true':
        nic = NIC(mobo, nics, cards, gateway_naming)
        nic.get_bob_mactab(out_path)
    else:
        nic = NIC(mobo, nics, cards, gateway_naming)
        nic.get_mactab(out_path)


def print_disk_license():
    mobo = get_mobo()
    disks = Disks(mobo, get_branding())
    print disks.get_disk_license()


def get_has_card(arg):
    mobo = get_mobo()
    nic = NIC(mobo, nics, cards)
    print nic.has_card(arg)


def get_card_list():
    mobo = get_mobo()
    nic = NIC(mobo, nics, cards)
    if mobo.isbob == 'true':
	nic.get_bob_card_list();
    else:
	nic.get_card_list()

def get_rev():
    mobo = get_mobo()
    print mobo.revision


def get_ipmi_support():
    mobo = get_mobo()
    print mobo.ipmi_support


def get_hal_path():
    mobo = get_mobo()
    print mobo.hal_path


def print_flexl():
    mobo = get_mobo()
    print mobo.flexl


def print_hwalarm():
    mobo = get_mobo()
    print mobo.hwalarm


def print_kernel_opts():
    mobo = get_mobo()
    prod = ''
    # per comment to rev 94701, this code appears to not matter for ESX,
    # but we haven't tested whether Hyper-V would be affected. Hyper-V's
    # part_num is 'HyperV'.
    # see also bug 129015 and reviews 69562 and 69559.
    if mobo.part_num == 'VM':
        try:
            prod = get_prod_type()[0]
        except HwtoolError:
            # In manufacturing mode most likely
            # nothing to do as we don't know what
            # product this is
            pass

    if prod == 'GW' or prod == 'CMC' or prod == 'CB':
        print "%s divider=10" % mobo.kernel_opts
    else:
        print mobo.kernel_opts

# get_physical_motherboard
#
# This query will print the actual physical hardware motherboard partnum
# It is mainly useful for all BOB based appliances
def get_physical_motherboard():
    mobo = get_mobo()
    print mobo.part_num

# Function returns host or rios based on the config
def get_disk_check():
    mobo = get_mobo()
    print mobo.disk_brand_checker

def get_motherboard_is_vm():
    mobo = get_mobo()
    print mobo.is_vm

# get_motherboard_type
#
# This query will print out the type of the motherboard. It is useful
# for cases where we have the same motherboard for two different chassis
def get_motherboard_type():
    mobo = get_mobo()
    print mobo.type

def get_motherboard():
    mobo = get_mobo()
    # For all BOB based motherboard return "BOB-MOBO"
    if mobo.isbob == "true":
        print "BOB-MOBO"
    else:
        print mobo.part_num

def print_branding():
    print get_branding()

def get_branding():
    mobo = get_mobo()
    prod = ''
    if mobo.part_num == '400-00300-01':
        try:
            prod = get_prod_type()[0]
        except HwtoolError:
            pass

        # For WW on Stureons we had disabled branding as the
        # 3010 model uses 3TB drives which do not support log page 80h
        if prod == 'CB':
            return "false"

    return mobo.branding

