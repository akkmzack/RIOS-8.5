#!/usr/bin/env python

from rrdm_util import run_shell_cmd, rrdm_error
from os.path import exists
from time import ctime, sleep
import errno

RVBD_SUPER_PATH	    =	"/opt/tms/bin/rvbd_super"
RVBD_MFG_SUPER_PATH =	"/mfg/rvbd_super"

 
###############################################################################
# Rvbd Superblock Wrapper Class
#
# Wraps the superblock output of rvbd_super in a python accessible form.
#
# Does not use extended SB output.
#
###############################################################################
class RvbdSuperBlock:
    def __init__(self, 
                 dev_name,
                 wait_for_device = False):
	self.dev_name	    = dev_name
	self.port_num	    = -1
	self.raid_port_num  = -1
	self.event_time     = 0
	self.serial	    = ''
	# 0 means no SB, >0 is a valid version (up to 1 at the moment)
	# and -1 means bad juju
	#
	self.version        = 0;
	self.super_path     = '';
        self.__sb_kvp       = {}
	self.fill_from_rvbd_super(wait_for_device)

    ## Return a string representation of the SB object
    def __str__(self):
        result = ''
        result += 'Version : %d\n' % self.version
        result += 'Serial Number : %s\n' % self.serial
        result += 'Port Number : %d\n' % self.port_num
        result += 'Raid Port Number : %d\n' % self.raid_port_num
        result += 'Event Time : %s\n' % ctime(self.event_time)
        for key in self.__sb_kvp.keys():
            result += '%s : %s\n' % (key, self.__sb_kvp[key])

        return result

    ## Indicate a valid SB if we read the version string
    # and found the version to be supported
    def is_valid(self):
        return self.version > 0

    ## Add akey value pair tuple to the object
    # @param kvp (key, value) tuple
    def update_from_kvp(self, kvp):
	if kvp[0] == 'port':
	    self.port_num = int (kvp[1], 10)
	elif kvp[0] == 'raid_port':
	    self.raid_port_num = int (kvp[1], 10)
	elif kvp[0] == 'time':
	    self.event_time = int (kvp[1], 10)
	elif kvp[0] == 'serial':
	    self.serial = kvp[1]
	elif kvp[0] == 'code':
	    self.code = int (kvp[1], 10)
        elif kvp[0] != 'version':
            self.__sb_kvp[kvp[0]] = kvp[1]

    ## Add a key/value pair to the SB
    # @param kvp key value pair to add to the disk SB.
    def add_sb_kvp(self, kvp):
        if len(kvp) != 2:
            raise rrdm_error ('Invalid key value pair parameter')
    
        cmdline = '%s -a %s=%s %s' % (self.super_path, kvp[0], kvp[1], self.dev_name)
        err = run_shell_cmd (cmdline)
        if err != 0:
            if err == errno.EINVAL:
		        raise rrdm_error ('%s: Invalid argument provided.' % self.super_path)
            raise rrdm_error ('Unable to update superblock on %s' % self.dev_name)
        
        self.__sb_kvp[kvp[0]] = kvp[1]


    ## Returns a string value given the key, or None if the key
    # does not exist.
    # @param key string key to fetch from the SB
    def get_sb_kvp(self, key):
        if self.__sb_kvp.has_key(key):
            return self.__sb_kvp[key]
        else:
            return None

    def get_port(self):
	return self.port_num

    def get_raid_port(self):
	return self.raid_port_num

    def get_serial(self):
	return self.serial
    
    def get_event_time(self):
	return self.event_time

    def display(self):
	print 'Version : %d' % self.version
	print 'Serial Number : %s' % self.serial
	print 'Port Number : %d' % self.port_num
	print 'Raid Port Number : %d' % self.raid_port_num
	print 'Event Time : %s' % ctime(self.event_time)

    def sync_disk_sb (self):
        retries = 0
        while retries < 5 and not exists (self.dev_name):
            sleep (1)
            retries = retries + 1
            
	cmdline = '%s -u -s %s -p %d -r %d %s' % (self.super_path, self.serial,  \
				                  self.port_num, self.raid_port_num, self.dev_name)
	err = run_shell_cmd (cmdline)
	if err != 0:
	    if err == errno.EINVAL:
		    raise rrdm_error ('%s: Invalid argument provided.' % self.super_path)
	    raise rrdm_error ('Unable to update superblock on %s' % self.dev_name)
    
    def update_superblock (self, serial, port_num, raid_port_num):
	self.port_num	    = port_num
	self.raid_port_num  = raid_port_num
	self.serial	    = serial
    
	self.sync_disk_sb()
	
    def fill_from_rvbd_super(self, 
                             wait_for_device = False):
	super_path = RVBD_SUPER_PATH
	if not exists (super_path):
	    super_path = RVBD_MFG_SUPER_PATH
	    if not exists (super_path):
		raise rrdm_error ('Unable to locate rvbd_super tool.')

        retries = 0
        if wait_for_device:
            while not exists(self.dev_name) and retries < 3:
                sleep (1)
                retries += 1
            
	if not exists (self.dev_name):
	    raise rrdm_error ('Device does not exist %s' % self.dev_name)

	self.super_path = super_path

	cmdline = '%s -v %s' % (super_path, self.dev_name)
	try:
	    output = run_shell_cmd (cmdline, True)
	except rrdm_error:
	    raise rrdm_error ('Unable to execute rvbd super tool.')
	    
	if output == '':
	    raise rrdm_error ('No output returned from rvbd super tool.');
    
	ver_kvp = output.split('=')
	if ver_kvp[0] != 'version': 
	    raise rrdm_error ('Invalid output returned from rvbd super tool');

	self.version = int (ver_kvp[1], 10)
	# we only do version 1 SB 's today.
	# should probably abstract the routines as a class later if we need to add 
	# more.
	#
	if self.version == 1:
	    # if we have a valid SB version.
	    # just get fetch the output.
	    cmdline = '%s -g %s' % (super_path, self.dev_name)
	    output = run_shell_cmd (cmdline, True)
	    try:
		sb_lines = output.split('\n')
		for line in sb_lines:	
		    sb_kvp = line.split('=')
		    self.update_from_kvp(sb_kvp)
	    except IndexError:
		raise rrdm_error ('invalid SB output returned from rvbd_super')
