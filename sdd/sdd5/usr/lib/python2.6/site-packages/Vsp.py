#!/usr/bin/env python

__doc__ = '''\
This module provides access to various VSP related functionality.
'''

import os
import subprocess
import time
import Mgmt
import Logging
import unittest
import fcntl, sys, os, os.path
from common import decrypt_scrypt

RUN_FOR_TIMEOUT=99

def get_esxi_dir():
    """!
    Return the ESXi dir (/esxi/<primary_mac_address>) on our appliance,
    where the primary MAC address is stripped of any colons and converted
    to lowercase
    """

    ret_directory = None

    cmd_get_pmac = "ip link show dev primary | grep 'link\/ether' | awk '{ print $2 }' | sed 's/://g'"

    # Query the primary mac
    pobj = subprocess.Popen([cmd_get_pmac], shell = True,
                              stdout = subprocess.PIPE)
    code = pobj.wait()

    if not code:
        ret_directory = "/esxi/%s" % pobj.stdout.readline().strip()

    return ret_directory

#------------------------------------------------------------------------------
def get_vmx_proc_id(vmx_file_path):
    """!
    Get process id of vmware-vmx. This function finds the vmware-vmx process
    that was run using the given configuration file. We should have only one
    vmware-vmx running at a time but still this function checks if there are
    multiple vmware-vmx running and does not return a value if it is the case.
    For a vm vmrun itself protects against multiple instances
    """

    vmware_vmx_pids = []

    # Currently we are only using vmware-vmx. However we could see -debug or
    # -stats depending on the configuration
    binary_names = ["vmware-vmx", "vmware-vmx-debug", "vmware-vmx-stats"]

    for binary_name in binary_names:
        pobj = subprocess.Popen(["pidof", binary_name], stdout=subprocess.PIPE)
        pobj.wait()

        pid = pobj.stdout.readline()
        pids = pid.strip().split()

        vmware_vmx_pids.extend(pids)

    if len(vmware_vmx_pids) <= 1:
        # For each process id get the command line and look
        # for vmx configuration file name. If file name matches
        # then we have the process id of our vmware-vmx
        for process_id in vmware_vmx_pids:
            file = open("/proc/%s/cmdline" % process_id)
            cmd = file.read()
            if cmd.find(vmx_file_path) != -1:
                return process_id

    return None

#------------------------------------------------------------------------------
def is_process_running(proc_id):
    """!
    Check if the process with the passed process id is running
    """
    if os.path.exists("/proc/%s/cmdline" % proc_id):
        return True
    return False

#------------------------------------------------------------------------------
class EncryptionContext(Mgmt.Structure):
         _fields_ = [("key", Mgmt.c_char * 8)]

context = EncryptionContext()
context.key = '47d28881'

def get_rios_manage_esxi_ip():
    """!
    Queries mgmtd for the current RiOS manage ESXi IP address and returns it

    Any callers of this function MUST have an open Mgmt GCL session

    If failed, the function returns None.
    """
    current_rios_mgmt_esxi_ip_node = "/rbt/vsp/state/network/rios_manage_esxi/ip"
    current_rios_mgmt_esxi_ip = Mgmt.get_value(current_rios_mgmt_esxi_ip_node)
    if not current_rios_mgmt_esxi_ip or current_rios_mgmt_esxi_ip == "0.0.0.0":
        Logging.log(Logging.LOG_INFO, "Failed to get RiOS manage ESXi IP address")
        current_rios_mgmt_esxi_ip = None
    return current_rios_mgmt_esxi_ip

def get_root_password():
    """!
    Queries mgmtd for the encrypted root password for ESXi and then returns
    the decrypted password.

    Any callers of this function MUST have an open Mgmt GCL session

    """

    # Mgmt nodes related to ESXi password
    rootpw_node = "/rbt/vsp/config/esxi/root/password"

    ret_password = None

    encrypted_str = Mgmt.get_value(rootpw_node)
    if encrypted_str:
        ret_password = decrypt_scrypt(context, encrypted_str)
    else:
        # If the root password is default empty string, node returns empty
        ret_password = ""

    return ret_password

#------------------------------------------------------------------------------
def is_memlock_enabled():
    """!
    Queries mgmtd to determine if workstation memlock is turned on
    """
    memlock_node = "/rbt/vsp/config/memlock/enable"
    memlocked = Mgmt.get_value(memlock_node)
    if not memlocked or memlocked == "":
        Logging.log(Logging.LOG_ERR, "Cannot determine if memlock is enabled")
        memlocked = "false"
    return memlocked == "true"

#------------------------------------------------------------------------------
def make_esxcli_env_vars():
    """!
    Setup the environment variables for the esxcli command. The required pieces
    are server IP, username, and password

    The function returns None if it can not get ip to
    access ESXi
    """

    hpn_ip = get_rios_manage_esxi_ip()

    password = get_root_password()
    if password != None and hpn_ip != None:
        env = {"VI_USERNAME":"root", "VI_SERVER":hpn_ip, "VI_PASSWORD":password}
        return env
    else:
        return None

#------------------------------------------------------------------------------
def make_vicfg_env_vars():
    """!
    Setup the environment variables for the vicfg command. In addition to the
    server IP, username, and password, vicfg calls require additional perl5
    related variables.

    """

    ret_base_env = make_esxcli_env_vars()

    if ret_base_env:
        ret_base_env["PERL5LIB"] = "/opt/perl5/lib/perl5"
        ret_base_env["PERL_LWP_SSL_VERIFY_HOSTNAME"] = "0"

    return ret_base_env

#------------------------------------------------------------------------------
def get_pids(process_name):
    """!
    For a given process return all process IDs returned from 'pidof'
    call. It may happen that we poke the process between its fork-exec
    calls, thus client may either re-run this routine or check if 
    interested pid belongs to the returned list.

    """

    pids = []

    pobj = subprocess.Popen(["pidof", process_name], stdout=subprocess.PIPE)
    ret = pobj.wait()
    
    if ret < 0:
        return None
    
    pid = pobj.stdout.readline()
    pids = pid.strip().split()
   
    return pids

class PidLock:
    def __init__(self, lockfile, lockdir="/var/run", pid=os.getpid()):
        self.__pid = pid
        self.__lockfile = lockdir + os.sep + lockfile
        self.__pidlockfile =  self.__lockfile + "." + str(self.__pid)
        self.__locked = False

    def __del__(self):
        """ When PidLock goes out of scope, delete the lock file """
        self.unlock()

    def lock(self):
        """ lock

            Attempt to acquire a pid base lock.

            1) Check if the lockfile <lockdir>/<lockfile> exists. If it
               exists, return False
            2) Create a file <lockdir>/<lockfile>.<pid>, writing the current
               pid in the file. Again, if this fails, return False (full FS?
               it's a bad thing and creating a lock wouldn't make sense)
            3) Attempt to atomically rename <lockdir>/<lockfile>.<pid> to
               <lockdir>/<lockfile>. If it fails, something else got in before
               us, so we delete our <lockfile>.<pid> file and return False
            4) Everything should be good, so we set self.__locked = True
               and return True.

            This should be atomic, insofar as os.rename() is atomic (it is).

            @return True/False if lock is successful.
        """
        if os.path.exists(self.__lockfile):
            pid_str = open(self.__lockfile, "r").read()
            pid = int(pid_str)
            if self.__pid == pid:
                # Not too sure why, but we're locking ourselves again
                return True
            if os.path.exists("/proc/%d/cmdline" % (pid)):
                return False
            # Stale PID file, unlink it
            try:
                os.unlink(self.__lockfile)
            except OSError:
                pass
        try:
            open(self.__pidlockfile, "w").write(str(self.__pid) + "\n")
            # after this point, pidlockfile should exist. If
            # rename fails, then it'll throw an exception. The finally
            # block will handle that though
            os.rename(self.__pidlockfile, self.__lockfile)
            self.__locked = True
            return True
        finally:
            try:
                os.unlink(self.__pidlockfile)
            except:
                pass
        return False

    def unlock(self):
        if self.__locked:
            try:
                os.unlink(self.__lockfile)
            except OSError:
                pass
        self.__locked = False

    def is_locked(self):
        return self.__locked

    def lock_pid(self):
        """ lock_pid

            Returns the process ID of the process that is currently has the
            lock. It will throw if the lockfile is corrupted in some way
            but generally should work just fine
        """
        pid = int(open(self.__lockfile, "r").read())
        return pid

class PidLockTest(unittest.TestCase):
    """ Not all that useful, but if you ever want to test the PidLock
        in isolation just run unittest.main() """
    def test_basicTest(self):
        self.assertNotEqual(os.getpid(), 88, "Bad luck, pid is 88. Try again.")
        lock1 = PidLock("test", lockdir="/tmp")
        lock2 = PidLock("test", lockdir="/tmp", pid=88)
        self.assertTrue(lock1.lock())
        self.assertTrue(lock1.is_locked())
        self.assertEqual(lock1.lock_pid(), os.getpid())
        self.assertFalse(lock2.lock())
        self.assertFalse(lock2.is_locked())
        self.assertEqual(lock2.lock_pid(), os.getpid())
        lock1.unlock()
        self.assertFalse(lock1.is_locked())
        self.assertTrue(lock2.lock())
        self.assertTrue(lock2.is_locked())
        self.assertEqual(lock2.lock_pid(), 88)

        # Test that the lock will overwrite a "stale" lock.
        # Assuming the test is never pid=88
        self.assertTrue(lock1.lock())
        # Relocking should work
        self.assertTrue(lock1.lock())
        self.assertTrue(lock1.is_locked())

    def test_scopeTest(self):
        def lockone(pid):
            lock = PidLock("test", lockdir="/tmp", pid=pid)
            self.assertTrue(lock.lock())
        lockone(44)
        lockone(88)
        lockone(99)

def update_progress(progress_file, value):
    """ Update Progress file, grabbing a lock and releasing it """
    if not progress_file:
        return
    progress_dir = os.path.dirname(progress_file)
    if not os.path.exists(progress_dir):
        os.makedirs(progress_dir)
    lock_file = progress_file + ".lck"
    if not os.path.exists(lock_file):
        fp = open(lock_file, "w")
        fp.close()
    fd = os.open(lock_file, os.O_RDONLY)
    # XXX/One day we might make this RAII, but Python's try/finally
    # works well enough
    fcntl.flock(fd, fcntl.LOCK_EX)
    try:
        fp = open(progress_file, "w+")
        fp.write("%d\n" % (value))
        fp.close()
    finally:
        fcntl.flock(fd, fcntl.LOCK_UN)
        os.close(fd)

#------------------------------------------------------------------------------
def run_esxcli(env_vars, timeout, args):

    # check if iSCSI software adapter is ENABLED?
    command = ["/opt/tms/bin/run_for", "-t", timeout, "--", \
               "/opt/vmware/vsphere_perl_sdk/bin/esxcli"]

    command += args

    pobj = subprocess.Popen(command, env=env_vars,
                            stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    output_lines = pobj.stdout.readlines()
    ret_code = pobj.wait()

    return ret_code, output_lines

#------------------------------------------------------------------------------
def get_iqn(env_vars, timeout):
    """!
    Run esxcli command to obtain IQN
    """
    
    iqn = None

    if not is_sw_iscsi_enabled(env_vars, timeout):
        return None

    iscsi_adapter = get_iscsi_adapter(env_vars, timeout)
    if iscsi_adapter == None:
        return None

    iqn = get_iqn_name(env_vars, iscsi_adapter, timeout)

    return iqn

#------------------------------------------------------------------------------
def get_iqn_name(env_vars, adapter_name, timeout):
    """!
    Run esxcli command to obtain IQN
    """
   
    iqn_name = None
    output_lines = []
   
    args = ["iscsi", "adapter", "get", "-A", adapter_name]

    ret_code, output = run_esxcli(env_vars, timeout, args)

    if ret_code < 0 or ret_code == RUN_FOR_TIMEOUT:
        return None

    # extract iqn name of sw iSCSI adapter
    if output != None:
        for line in output:
            if line.find("Name:") != -1:
                tokens = line.split() 
                iqn_name = tokens[1]
                break

    return iqn_name

#------------------------------------------------------------------------------
def get_iscsi_adapter(env_vars, timeout):
    """!
    Run esxcli command to obtain IQN
    """
   
    iscsi_adapter = None
    adapter_list = []

    args = ["iscsi", "adapter", "list"]

    ret_code, output = run_esxcli(env_vars, timeout, args)

    if ret_code < 0 or ret_code == RUN_FOR_TIMEOUT:
        return None

    # extract sw iSCSI adapter name
    if output != None:
        for adapter in output:
            if adapter.find("iSCSI Software Adapter") != -1:
                tokens = adapter.split() 
                iscsi_adapter = tokens[0]
                break

    return iscsi_adapter
  
#------------------------------------------------------------------------------
def is_sw_iscsi_enabled(env_vars, timeout):
    """!
    Run esxcli command to obtain IQN
    """
    
    args = ["iscsi", "software", "get"]

    ret_code, output = run_esxcli(env_vars, timeout, args)

    if ret_code < 0 or ret_code == RUN_FOR_TIMEOUT:
        return None

    # check if iSCSI software adapter is ENABLED?
    if output[0].find("true") != -1:
        return True

    return False

