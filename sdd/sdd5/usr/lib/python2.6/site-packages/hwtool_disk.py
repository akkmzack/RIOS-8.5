#!/usr/bin/python
import os
from os.path import exists, basename, isdir
from hwtool_util import *
import re
from re import compile as recompile
import glob

kernel_version = os.uname()[2]

##############################################################
# Disk, container class for Disk information in the system
##############################################################
class Disk:
    def __init__(self, bus):
        self.__vendor = get_sysfs_param('/sys/bus/scsi/devices/%s/vendor' % bus)
        self.__model = get_sysfs_param('/sys/bus/scsi/devices/%s/model' % bus)
        self.__state = get_sysfs_param('/sys/bus/scsi/devices/%s/state' % bus)
        self.__bus = bus

        if kernel_version.startswith('2.6.9'):
            self.__devname = get_sysfs_param('/sys/bus/scsi/devices/%s/device_name' % bus)
        else:
            D = os.listdir('/sys/bus/scsi/devices/%s/block/' % bus)
            assert len(D) == 1 and isdir('/sys/bus/scsi/devices/%s/block/%s' % (bus, D[0]))
            self.__devname = D[0]

        # Do not fill in this by default cause it is a ioctl call 
        # and we dont want to do that every few seconds
        self.__serial = ''
        self.__fw = ''
        
    def get_diskinfo(self):
        """This call will fill out the disk serial number and firmware version
        this is an ioctl call so please use sparingly
        """
        (self.__serial, self.__fw) = get_disk_info('/dev/%s' % self.devname)[0].split(' ')

    def printo(self):
        """Pretty printing for all the disk information
        """
        print "Device Name: %s, Bus: %s, Serial: %s, FW version: %s, Vendor: %s, Model: %s, State: %s" % (self.__devname
            , self.__bus, self.__serial, self.__fw, self.__vendor, self.__model, self.__state)


##############################################################
# Disks, container class for all the Disks in the system
##############################################################
class Disks:
    def __init__(self, mobo, branding):
        self.__size = []
        self.__branded = []
        self.__sysmobo = mobo
        self.__disk_list = {}
        self.__map = ''
        self.__unlicensed = ''
        self.__quantity = ''
        self.__branding_support = branding

        ## Sturgeon Disk Map Info
        #
        # The procfs phys_drive_info has 2 bytes of output the first is the 
        # expander port, and the second is the target offset within that 
        # expander
        #
        # on sturgeon units, the first expander 
        # shows up on port 0, the second on port 4.
        # the drive offsets are linear with each expander having 8 drives.
        #
        self.sturgeon_disk_map = { 
                                  0x0000:0,
                                  0x0001:1,
                                  0x0002:2,
                                  0x0003:3,
                                  0x0004:4,
                                  0x0005:5,
                                  0x0006:6,
                                  0x0007:7,
                                  0x0400:8,
                                  0x0401:9,
                                  0x0402:10,
                                  0x0403:11,
                                  0x0404:12,
                                  0x0405:13,
                                  0x0406:14,
                                  0x0407:15
                                 }

        ## Yellowtail Disk Map Info
        #
        # YT has two controllers (ioc0 and ioc1), plus 
        # four expanders (exp0 and exp1 per ioc).
        # This gives us a tuple of {ioc,exp,drv}.
        # ioc0 - expander 0 and 1 (expander 0:0 and 0:1)
        # ioc1 - expander 2 and 3 (expander 1:0 and 1:1)
        # Hex representation is 0xPPQQ, where
        # PP = expander
        # QQ = drive 
        # where, PP is between 0 and  3
        #        QQ is between 0 and 31
        #
        self.yellowtail_disk_map = { 
                                  0x0301:2,
                                  0x0004:3,
                                  0x0300:0, # /dev/disk0 maps to connector #2
                                  0x0005:1, # /dev/disk1 maps to connector #3
                                  0x031f:4,
                                  0x031e:5,
                                  0x0302:6,
                                  0x0303:7,
                                  0x0106:8,
                                  0x0107:9,
                                  0x0204:10,
                                  0x0205:11,
                                  0x0006:12,
                                  0x0007:13,
                                  0x031d:14,
                                  0x031c:15,
                                  0x0105:16,
                                  0x0104:17,
                                  0x0108:18,
                                  0x0109:19,
                                  0x0206:20,
                                  0x0208:21,
                                  0x000b:22,
                                  0x0009:23,
                                  0x031a:24,
                                  0x031b:25,
                                  0x0110:26,
                                  0x0112:27,
                                  0x010b:28,
                                  0x010a:29,
                                  0x0207:30,
                                  0x020b:31,
                                  0x000a:32,
                                  0x0008:33,
                                  0x0319:34,
                                  0x0318:35,
                                  0x0111:36,
                                  0x0113:37,
                                  0x021b:38,
                                  0x021a:39,
                                  0x020a:40,
                                  0x0209:41,
                                  0x000c:42,
                                  0x000d:43,
                                  0x0317:44,
                                  0x0316:45,
                                  0x010e:46,
                                  0x010f:47,
                                  0x0219:48,
                                  0x0218:49,
                                  0x0214:50,
                                  0x0215:51,
                                  0x000e:52,
                                  0x000f:53,
                                  #0x0315:54, # bottom row HDD has single connector
                                  #0x010d:55, # bottom row HDD has single connector
                                  #0x0217:56, # bottom row HDD has single connector
                                  #0x0013:57, # bottom row HDD has single connector
                                  #0x0010:58, # bottom row HDD has single connector
                                  0x0314:54,
                                  0x010c:55,
                                  0x0216:56,
                                  0x0012:57,
                                  0x0011:58,
                                 }
        self.dell_disk_map = {
                                  0x0006:0,
                                  0x0004:1,
                                  0x0002:2,
                                  0x0007:3,
                                  0x0005:4,
                                  0x0003:5,
                                 }

        # RF 1U LSI
        self.rf_1u_lsi_disk_map = {
                                  0x0000:0,
                                  0x0001:1,
                                  0x0002:2,
                                  0x0003:3 
                                 }

        self.rf_2u_lsi_disk_map = {
                                  0x0000:0,
                                  0x0003:1,
                                  0x0006:2,
                                  0x0009:3,
                                  0x0001:4,
                                  0x0004:5,
                                  0x0007:6,
                                  0x000a:7, 
                                  0x0002:8,
                                  0x0005:9,
                                  0x0008:10,
                                  0x000b:11
                                 }

        self.rf_25u_lsi_disk_map = {
                                  0x0004:0,
                                  0x0005:1,
                                  0x0006:2,
                                  0x0007:3,
                                  0x0008:4,
                                  0x0009:5,
                                  0x000a:6,
                                  0x000b:7, 
                                  0x000c:8,
                                  0x000d:9,
                                  0x000e:10,
                                  0x000f:11,
                                  0x001a:12,
                                  0x001b:13,
                                  0x0012:14,
                                  0x0013:15,
                                  0x0014:16,
                                  0x0018:17,
                                  0x0017:18,
                                  0x0016:19,
                                  0x0015:20,
                                  0x0019:21,
                                  0x0010:22,
                                  0x0011:23
                                 }

        ## Gar Disk Map Info
        #
        # The procfs phys_drive_info has 2 bytes of output the first is the 
        # expander port, and the second is the target offset within that 
        # expander
        #
        #
        # On Gar units, the disk mapping to between expander and port is more 
        # complicated, and we tabled it, since its confusing. Refer to the
        # Gar backplane spec for more info 
        #
        self.gar_disk_map = {
                  0x0003:0,
                  0x000f:1,
                  0x040d:2,
                  0x040c:3,
                  0x040a:4,

                  0x0005:5,
                  0x0000:6,
                  0x040e:7,
                  0x040b:8,
                  0x0408:9,

                  0x0006:10,
                  0x0001:11,
                  0x040f:12,
                  0x0409:13,
                  0x0406:14,

                  0x0008:15,
                  0x0002:16,
                  0x000e:17,
                  0x0407:18,
                  0x0403:19,

                  0x0009:20,
                  0x0004:21,
                  0x000d:22,
                  0x0405:23,
                  0x0402:24,

                  0x000a:25,
                  0x0007:26,
                  0x000c:27,
                  0x0404:28,
                  0x0401:29,

                  0x000b:30,
                  0x0400:31
               }


    def get_map(self):
        """Return the disk map string
        """
        if not self._get_disk_map():
            rlog_warning('Could not get the disk mapping')
            self.__map = ''
        return self.__map.rstrip()

    def get_size(self):
        """Return the size of all the disks in the system
        we dont care if the disks are branded here
        """
        if not self.get_disk():
            rlog_warning('Could not get the disk size information')
            self.__size = []

        return self.__size

    def get_unlicensed(self):
        """Return "true" if there are unbranded disks in the system else "false"
        """
	# If it is a BOB but branding is checked by esxi, ignore branding 
        if 'true' == self.__sysmobo.isbob and 'host' == self.__sysmobo.disk_brand_checker:
            return "false"

        if "true" == self.__branding_support:
            if not self.get_disk():
                rlog_warning('Could not get the disk size information, don\'t know if there are unbranded disks')
                return "false"

            if len(self.__size) != len(self.__branded):
                return "true"

        return "false"

    def get_quantity(self):
        """Return the number of branded disks in the system
        """
        if not self.get_disk():
            rlog_warning('Could not get the disk quantity information')
            self.__size = []

        return len(self.__size)

    def get_branded(self):
        """Return all the branded disks in the system
        """
        if not self.get_disk():
            rlog_warning('Could not get the branded disk information')
            self.__branded = []

        return self.__branded

    def translate_scsi_state(self, state):
        """We want to turn the scsi state into a binary state
        which indicates whether we can talk to the drive or not.
        we only want to talk to the drive when it is in the
        running state
        """
        if state == "running":
            return 'online'
        else:
            return 'offline'

    def get_scsi_dev_info(self, path):
        """Returns a tuple of scsi device name and state based on the path
        to its sysfs.

        the state is the raw scsi state, so it will need to be translated
        prior to use given the above translate_scsi_state() call, if you
        want to know whether the device can be talked to or not.

        An exception is raised if the sysfs file does not exist, or another IO
        error, which can be interpreted as a drive is missing by the caller
        if so desired.
        """
        if kernel_version.startswith('2.6.32'):
            D = os.listdir('%s/block/' % path)
            assert len(D) == 1 and isdir('%s/block/%s' % (path, D[0]))
            dev_name = D[0]
            dev_num = get_sysfs_param('%s/block/%s/dev' % (path, D[0]))

            bkdevs = glob.glob('/sys/block/*/shadow/backing_device')
            for bkd in bkdevs:
                if get_sysfs_param(bkd) == dev_num:
                    dev_name=bkd.split('/')[3]
                    break
        elif kernel_version.startswith('2.6.9'):
            dev_name  = get_sysfs_param ('%s/device_name' % path)
            dev_num = get_sysfs_param ('%s/device/block/dev' % path)

            bkdevs = glob.glob('/sys/block/*/shadow/backing_device')
            for bkd in bkdevs:
                if get_sysfs_param(bkd) == dev_num:
                    dev_name=bkd.split('/')[3]
                    break
        else:
            raise Exception('do not recognize kernel version %s' % kernel_version)

        dev_state = get_sysfs_param ('%s/state' % path)

        return (dev_name, dev_state)

    def _get_license_info(self, dname):
	# If it is a BOB but branding is checked by esxi, ignore branding 
	if 'true' == self.__sysmobo.isbob and 'host' == self.__sysmobo.disk_brand_checker:
	    return "Licensed"

        if dname[:4] == 'disk' or dname[:5] == 'msata':
            if self.__branding_support == "true":
                dbrand = get_disk_branding("/dev/%s" % dname)
                if dbrand == -1:
                    return "Error"
                if not compareSecretStr(dbrand):
                    return "Unlicensed"
    
        return "Licensed"


    def get_disk_license(self):
        if not self._get_disk_map():
            rlog_warning('Could not get the disk mapping')
            self.__map = ''

        str = ''
        try:
            for disk in self.__map.rstrip().split('\n'):
                diskinfo = disk.split(' ')
                dname = diskinfo[1]
                state = diskinfo[3]
                # only talk to disks that hwtool reports as online (scsi state).
                # this disk may still be degraded in a raid, but the disk_map query
                # tells us whether we should talk to the disk or not.
                #
                if 'online' == state:
                    str += dname + ' ' + self._get_license_info(dname) + '\n'
        except IndexError:
            # Old models where nothing is returned for disk=map
            pass

        return str


    def _do_scan_scsi_mpt(self, root_dir, pattern, bus_type):
        """Return a map of all the scsi drives in the system
        """
        mpt_scsi_regex = recompile(pattern)
        scsi_dev_dir_list = listdir (root_dir)
        found_drive_count = 0

        mpt_scsi_list = {}

        for scsi_dir in scsi_dev_dir_list:
            if mpt_scsi_regex.match (scsi_dir):
                try:
                    phys_drive_info = get_sysfs_param ("%s%s/device/phys_drive_info" % (root_dir, scsi_dir))
                except Exception:
                    rlog_debug('%s%s/device/phys_drive_num went missing, don\'t insert it into the list' % (root_dir, scsi_dir))
                    continue

                try:
                    pdi_int = int(phys_drive_info)
                except ValueError:
                    continue

                if bus_type == 'scsi-mpt':
                    disk_map = self.sturgeon_disk_map
                elif bus_type == 'scsi-mpt-2':
                    disk_map = self.gar_disk_map
                elif bus_type == 'scsi-dell':
                    disk_map = self.dell_disk_map
                elif bus_type == 'scsi-rf-1u-lsi':
                    disk_map = self.rf_1u_lsi_disk_map
                elif bus_type == 'scsi-rf-2u-lsi':
                    disk_map = self.rf_2u_lsi_disk_map
                elif bus_type == 'scsi-rf-25u-lsi':
                    disk_map = self.rf_25u_lsi_disk_map
                else:
                    raise HwtoolError('Invalid bus type for scsi-mpt system [%s]' % bus_type)

                if disk_map.has_key(pdi_int):
                    phys_drive_num = disk_map[pdi_int]
                else:
                    continue

                mpt_scsi_list[phys_drive_num] = scsi_dir

        return mpt_scsi_list


    def _get_fusion_map_2632(self, n, bus_type, prefix):
        fusion_disks = {}
 
        if bus_type == 'scsi-mpt':
            disk_map = self.sturgeon_disk_map
        elif bus_type == 'scsi-mpt-2':
            disk_map = self.gar_disk_map
        elif bus_type == 'scsi-dell':
            disk_map = self.dell_disk_map
        elif bus_type == 'scsi-rf-1u-lsi':
            disk_map = self.rf_1u_lsi_disk_map
        elif bus_type == 'scsi-rf-2u-lsi':
            disk_map = self.rf_2u_lsi_disk_map
        elif bus_type == 'scsi-rf-25u-lsi':
            disk_map = self.rf_25u_lsi_disk_map
        elif bus_type == 'scsi-yt':
            disk_map = self.yellowtail_disk_map
        else:
            raise HwtoolError('Invalid bus type for scsi-mpt system [%s]' % bus_type)

        if bus_type == 'scsi-rf-1u-lsi':
            # XXX/munirb: Special case
            # The Redfin 1U's don't have an expander so the sysfs nodes are different
            # paths are like ...
            # /sys/class/sas_phy/phy-0\:0/phy_identifier
            # /sys/class/sas_phy/phy-0\:1/phy_identifier
            root = '/sys/class/sas_phy'
            for i in range(0, 4):
                node = '%s/phy-0:%s/phy_identifier' % (root, i)
                phy_num = int(get_sysfs_param(node))
                for p in glob.glob('%s/phy-0:%s/device/port/end_device-*' % (root, i)):
                    #print p
                    for p2 in glob.glob('%s/target*' % p):
                        #print "=====%s=====" % p2
                        id2 = basename(p2)[len('target'):]
                        scsi_id = '%s:0' % id2
                        devpath = '%s/%s' % (p2, scsi_id)
                        fullpath = devpath + '/block'
                        #print fullpath
                        if not isdir(fullpath):
                            print '%s exists but %s does not' % (p2, fullpath)
                            continue

                    if disk_map.has_key(phy_num):
                         phys_drive_num = disk_map[phy_num]
                    else:
                        # invalid key we should log an error once we get logging
                        # into hwtool
                        continue

                    devnames = os.listdir('%s/block' % (devpath))
                    if len(devnames) != 1 or not isdir('%s/block/%s' % (devpath, devnames[0])):
                        print 'cannot find devname in %s/block' % devpath
                        continue
                    devname = devnames[0]

                    state = self.translate_scsi_state(get_sysfs_param('%s/state' % devpath))

                    fusion_disks[phys_drive_num] = (scsi_id, devname, state)
        else:
            # These machines always have an expander so the sysfs nodes
            # are different
            # paths are pretty deep but look something like:
            # /sys/class/sas_expander/expander-0:0/device/port-0:0:10/end_device-0:0:10/target0:0:10/0:0:10:0
            # /sys/class/sas_expander/expander-0:1/device/port-0:1:9/end_device-0:1:9/target0:0:25/0:0:25:0
            yt_dvt = 0
            topbyte = 0x0
            exp_list = []
            root = '/sys/class/sas_expander'
            try:
                for dir in os.listdir(root):
                    match = (re.compile('expander-([012]):([01])')).search(dir)
                    if match:
                        if '2' == match.group(1):
                            if bus_type == 'scsi-yt':
                                yt_dvt = 1
                            else:
                                # if we reach this, it means we have an expander with 
                                # enumeration of 2:[0|1], which should *only* be present
                                # in YT systems. 
                                print 'warning: incorrect expander enumeration %s' % bus_type
                    exp_list.append(dir) 
            except MemoryError:
                print 'Out of memory'
                raise 
            except OSError: 
                print 'Unable to list sysfs SAS expander nodes'
                raise 
            except: 
                print 'Unexpected error: ', sys.exc_info()[0]
                raise 
            for exp in exp_list:
                if yt_dvt: 
                    if exp == 'expander-1:0':
                        topbyte = 0x00
                    elif exp == 'expander-1:1':
                        topbyte = 0x01
                    elif exp == 'expander-2:0':
                        topbyte = 0x02
                    elif exp == 'expander-2:1':
                        topbyte = 0x03
                else: 
                    if exp == 'expander-0:0':
                        topbyte = 0x00
                    elif exp == 'expander-0:1':
                        # if yellowtail, there are 4 expanders, and 2 i/o controllers
					    # format for yt: [0|1|2|3]
					    # format for rf: [0|4]
                        if bus_type == 'scsi-yt':
                           topbyte = 0x01
                        else:
                           topbyte = 0x04
                    elif exp == 'expander-1:0':
                        topbyte = 0x02
                    elif exp == 'expander-1:1':
                        topbyte = 0x03
                    else:
                        print 'warning: do not recognize expander %s' % exp
                        continue
                D = '%s/%s/device' % (root, exp)
                for p in glob.glob('%s/port-*' % D):
                    id = p.split('-')[-1]
                    path = '%s/end_device-%s/' % (p, id)
                    if not isdir(path):
                        #print 'bah, %s exists but %s does not' % (p, path)
                        continue

                    phylist = [ f for f in os.listdir(p) if f.startswith('phy-') ]
                    if len(phylist) != 1:
                        #print 'weird, phy-* in %s gave:' % p, D
                        continue
                    idfile = '%s/%s/sas_phy/%s/phy_identifier' % (p, phylist[0], phylist[0])
                    phy_num = int(get_sysfs_param(idfile))
	
                    for p2 in glob.glob('%s/target*' % path):
                        id2 = basename(p2)[len('target'):]
                        scsi_id = '%s:0' % id2
                        devpath = '%s/%s' % (p2, scsi_id)
                        fullpath = devpath + '/block'
                        #print fullpath
                        if not isdir(fullpath):
                            #print '%s exists but %s does not' % (p2, fullpath)
                            continue
                    
                    # woohoo!
            
                    pdi_int = (topbyte << 8) | phy_num
                    #print 'mapped %s to 0x%x' % (path, pdi_int)

                    if disk_map.has_key(pdi_int):
                        phys_drive_num = disk_map[pdi_int]
                    else:
                        # invalid key we should log an error once we get logging
                        # into hwtool
                        continue

		    if isdir(fullpath):
                        devnames = os.listdir('%s/block' % (devpath))
                        if len(devnames) != 1 or not isdir('%s/block/%s' % (devpath, devnames[0])):
                            print 'cannot find devname in %s/block' % devpath
                            continue
                        devname = devnames[0]

                        state = self.translate_scsi_state(get_sysfs_param('%s/state' % devpath))

                        fusion_disks[phys_drive_num] = (scsi_id, devname, state)

        ret_str = ''
        for i in range(n):
            dname = '%s%d' % (prefix, i)
            if fusion_disks.has_key(i):
                scsi_id, devname, state = fusion_disks[i]
            else:
                scsi_id, devname, state = ('unknown', 'missing', 'missing')

            ret_str += '%s %s %s %s\n' % (scsi_id, dname, devname, state)

        return ret_str

    def _get_disk_map(self):
        """Get the disk OS to bus mapping
        # disk maps are generated in 2 different ways for the new hw,
        # Barramundi's use direct scsi host bus patterns, on sturgeon,
        # the MPT driver assigns bus numbers in order of drive insertion,
        # so we need to use the phys_drive_num in the scsi device sysfs dir.
        #
        # also simplify the config when we have an explicit port number field
        """
        self.__map      = ''
        brand_support = self.__branding_support
        status        = ''

        disk_root = '/sys/class/scsi_device/'
        for (n, slot, bus, prefix, start_offset) in self.__sysmobo.disk_patterns:

            if bus == "scsi-mpt" or bus == "scsi-mpt-2" or bus == "scsi-dell" or \
                bus == "scsi-rf-1u-lsi" or bus == "scsi-rf-2u-lsi" or bus == "scsi-rf-25u-lsi" or \
				bus == "scsi-yt":
                if kernel_version.startswith('2.6.32'):
                    self.__map += self._get_fusion_map_2632(int(n), bus, prefix)
                    continue

                # the number for scsi-mpt entries indicates the total number of drives.
                #
                mptpd_to_scsi_map = self._do_scan_scsi_mpt(disk_root, slot, bus)

                for disk_ix in range (int(n, 10)):
                    dev_name  = 'missing'
                    dev_state = 'missing'
    
                    if mptpd_to_scsi_map.has_key (disk_ix):
                        scsi_bus = mptpd_to_scsi_map[disk_ix]
                        try:
                            (dev_name, dev_scsi_state) = self.get_scsi_dev_info ('%s%s' % (disk_root, scsi_bus))
                            dev_state = self.translate_scsi_state (dev_scsi_state)

                        except Exception:
                            pass
                    else:
                        scsi_bus = 'unknown'

                    dname = "%s%d" % (prefix, disk_ix + start_offset)

                    # use the device name prefix in the config file.
                    # e.g. disk0, the naming script elsewhere optionally attaches the
                    # p<partition num>
                    #
                    self.__map += (scsi_bus + " " + dname + " " + dev_name + " " + dev_state + "\n")
                    if dname[0:4] == 'disk' and dev_name != 'missing':
                        disk_obj = Disk(scsi_bus)   
                        self.__disk_list[dev_name] = disk_obj
                    
            elif bus == "scsi":
                dev_name  = 'missing'
                dev_state = 'missing'

                # scan the scsi devices using the pattern specified in the cfg.
                #
                if exists (disk_root):
                    scsi_dev_list = os.listdir (disk_root)
                    scsi_regex    = recompile(slot)

                    matches = filter (lambda dir: scsi_regex.match(dir), scsi_dev_list)
                    if matches != []:
                        slot = matches[0]

                        # today we use the first match, there can be only one match
                        # for regex's in scsi bus config entries.
                        #
                        try:
                            (dev_name, dev_scsi_state) = self.get_scsi_dev_info ('%s%s/device/' % (disk_root, slot))
                            dev_state = self.translate_scsi_state (dev_scsi_state)
                        except Exception:
                            # we default to missing above.
                            pass
                    else:
			# mismtach may happen after eUSB is power-reset due to error handling.
			# in such case we get the dev_t(major/minor) from the new backing device
			# and then find the new slot number (host_id:channel:target:lun) based
			# on the dev_t.
                        bkdevs = glob.glob('/sys/block/sh*/shadow/backing_device')                                  
                        if bkdevs != [] and prefix == 'flash':                                                      
                            # shadow is enabled                                                                     
                            flash_devt = get_sysfs_param(bkdevs[0])                                                 
                            scsi_devices = glob.glob('/sys/block/sd*')                                              
                                                                                                                    
                            for scsi_device in scsi_devices:                                                        
                                if get_sysfs_param('%s/dev' %scsi_device) == flash_devt:                            
                                    # found the backing device for shadow                                           
                                    # now need to figure out new slot and dev_state                                 
                                    slot = os.listdir('%s/device/scsi_device' % (scsi_device))[0]                   
                                    try:                                                                            
                                        (dev_name, dev_scsi_state) = self.get_scsi_dev_info ('%s%s/device/' % (disk_root, slot))
                                        dev_state = self.translate_scsi_state (dev_scsi_state)                                  
                                    except Exception:                                                                           
                                        # we default to missing above.                                                          
                                        pass
				    break

                # set the prefix
                dname = prefix + n

                self.__map += (slot + " " + dname + " " + dev_name + " " + dev_state + "\n")
                if dname[0:4] == 'disk' and dev_name != 'missing':
                    disk_obj = Disk(slot)   
                    self.__disk_list[dev_name] = disk_obj
            else:
                continue

        return True


    def get_disk(self):
        """Get the hard disk information
        """

        #get the size of each disk, rounded to the nearest GB.
        self.__size = []
        self.__branded = []

        if not self._get_disk_map():
            rlog_warning('Cannot get disk mapping')
            return False

        for e in self.__map.strip().split('\n'):
            try:
                parts = e.split(' ')
                if parts[1][0:5] == 'flash':
                    # skipping flash
                    continue
                if parts[2] == 'missing':
                    # skipping missing disks
                    continue
		size = get_sysfs_param('/sys/block/%s/size' % parts[2])
		size = int(size)/2
                size = int(int(size) * 1.024 / 1e6) # convert into GB

                if "true" == self.__branding_support:
                    dbrand = get_disk_branding('/dev/%s' % parts[1])

                    if dbrand == -1:
                        # This is a failed drive assume the disk size is zero and move on
                        self.__branded.append([parts[1], 0])
                        self.__size.append([parts[1], 0])
                        continue

                    if compareSecretStr(dbrand):
                        self.__branded.append([parts[1], size])
                        self.__size.append([parts[1], size])

                    else:
                        self.__size.append([parts[1], size])
                else:
                    self.__branded.append([parts[1], size])
                    self.__size.append([parts[1], size])

            except IndexError:
                # Nothing we can do as yet, would be great to log this
                pass
            except HwtoolError:
                pass
            except AttributeError:
                pass

        return True
