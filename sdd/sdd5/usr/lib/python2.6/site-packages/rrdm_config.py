#!/usr/bin/env python
## @package rrdm_config
# 
# Configuration File Interface classes for Raid and Disk Management
#

from sys import exit, argv
from os.path import ismount
from rrdm_util import *
import re
import os
import pickle

## compute_part_size_given_parities
#
# Returns the partition size for a single disk in a RAID, or -1 on error
#
def compute_part_size_given_parities(size, num_disks, parity_disks):
    # size:  usable data on full RAID
    # num_disks:  total number of disks (partitions) in the array
    # parity_disks:  number of parity disks (1 for raid5, 2 for raid6)

    part_size = size / (num_disks - parity_disks)

    if part_size <= 0:
        return -1
    else:
       return part_size

## compute_part_size_by_raid
#       
# special case the logical partition, since we don't specify a size for it.
#       
# return -1 on error
#       
# otherwise return the size of a disk partition given the system
# configuration.
#       
def compute_part_size_by_raid(size, num_disks, vol_type, ptype):    # size is an int
    # num_disks is an int
    # vol_type is a string (single, raid10, utility, ftraid)
            
    # special case the logical partitions, which just get a size of 0
    if ptype == "0f":
        return 0
        
    if vol_type == "raid10":
        # size is the configuration size divided by the number of mirror pairs.
        #
        num_mirrors = num_disks / 2
            
        part_size = size / num_mirrors
        
        if part_size <= 0:
            return -1
        else:
           return part_size
        
    elif vol_type == "raid5":
        return compute_part_size_given_parities(size, num_disks, 1)

    elif vol_type in [ "raid6", "raid6b" ]:
        return compute_part_size_given_parities(size, num_disks, 2)

    elif vol_type in [ "single", "utility", "ftraid" ]:
        # for single disk entities, the partition size is the indicated
        #   
        # configuration entries size.
        return size

    else:
        return -1

## DiskMemberManager
# This class abstracts a disk quantity/membership list.  The disk quantity 
# members now can take a few types of inputs
# single number : '9', which is used to indicate the number of disks
#                 which means we'd have a disk range of 0..8
# range: '0-5' which means we'll have a disk range of 0..5
# multiple ranges/single members: 0-5,9 or 0-5,8-9 which can leave a gap
#                 in the managed disks, which is 0..5 and 8..9
# single members non-numeric: we can now identify a disk as a non-numeric
#                 disk, such as sp1, sp2 ranges can not be used with
#                 non-numeric disks
class DiskMemberManager:
    disk_range_regex = re.compile('([0-9]+)\-([0-9]+)')
    disk_single_regex = re.compile('[0-9]+$')
    disk_special_regex = re.compile('[a-zA-Z]+[0-9]+$')

    ## Init
    # @param disk_attr string representation of acceptable drive locations
    # @param order string representation of the disk ordering
    #       : ascending -> 0,1,2,3
    #       : descending -> 3,2,1,0
    #       : 0,2,1,3 (for out of order)
    # @raise AssertionError on invalid disk_attr input
    def __init__(self,
                 disk_attr,
                 order = 'ascending'):
        self.__member_list = []
        self.__attrs       = disk_attr
        self.__order       = order
        if disk_attr == '' or disk_attr == None:
            raise AssertionError('Invalid disk attributes')

        self.__parse_disk_attr()

    ## __check_disk_attr
    # @raise AssertionError if the member list specifies the same drive twice
    #
    # perform a consistency check on the disk member list to ensure that we
    # don't have a config that specifies the same drive multiple times
    def __check_disk_attr(self):
        memdict = {}
        for member in self.__member_list:
            if memdict.has_key(member):
                raise AssertionError('Disk %s appears multiples times' % \
                                     member)
            memdict[member] = member

    ## __parse_disk_attr
    # @raise AssertionError on invalid disk attribute string
    #
    # Parse the disk attribute member and convert it to a list of disk
    # location strings (disk locations can now be special non-int values
    # like sp1, sp2, etc)
    def __parse_disk_attr(self):
        parts = self.__attrs.split(',')
        for opart in parts:
            part = opart.strip()
            if self.disk_single_regex.match(part):
                try:
                    part_i = int(part)
                except ValueError:
                    raise AssertionError('Invalid disk index %s' % part)

                # if we only have one attribute entry, we'll treat this
                # for legacy reasons as a range
                if len(parts) == 1:
                    if self.__order == 'ascending':
                        self.__member_list.extend(range(0, part_i))
                    elif self.__order == 'descending':
                        self.__member_list.extend(range(0, part_i)[::-1])
                    else:
                        new_order = self.__order.split(',')
                        for elem in new_order:
                            self.__member_list.append(int(elem))
                else:
                    # if there are multiple attributes, ranges must be
                    # explicit
                    self.__member_list.append(part_i)
            else:
                matchobj = self.disk_range_regex.match(part)
                if matchobj:
                    if self.__order == 'ascending':
                        self.__member_list.extend(range(int(matchobj.group(1)),
                                                    int(matchobj.group(2))+1))
                    elif self.__order == 'descending':
                        self.__member_list.extend(range(int(matchobj.group(2))+1),
                                                    range(int(matchobj.group(1))))
                    else:
                        new_order = self.__order.split(',')
                        for elem in new_order:
                            self.__member_list.append(int(elem))
                else:
                    # if we allow characters we need to check more things here
                    raise AssertionError('Invalid disk entry %s' % part)

        # make sure that we have not multiply defined the same disk
        # in our ranges
        self.__check_disk_attr()

    ## Str
    # Returns a list of disk members
    def __str__(self):
        result = ''
        for member in self.__member_list:
            result += '%s\n' % member

        return result

    ## get_disks
    # Returns the list of disks that are part of this config
    def get_disks(self):
        return self.__member_list

    ## get_num_disks
    # Returns the number of disks that are part of this config
    def get_num_disks(self):
        return len(self.__member_list)

    ## find_logical_port
    # @param disk_id disk id in the system
    # determines the logical offset of this given disk id in the member
    # list.
    # Returns None if the disk is not in the list, or an int representing 
    # the logical disk number within the list
    #
    def find_logical_port(self, 
                          disk_id):
        cnt = 0
        for member in self.__member_list:
            if member == disk_id:
                return cnt
            cnt += 1

        return None

    ## find_physical_port
    # @param logical_port device index within the zone
    # @raise AssertionError if the logical port requested does not exist
    #                       within the zone.
    # determines the physical device of this given logical device
    # within the zone list, based on the member list for the zone
    #
    def find_physical_port(self,
                           logical_port):
        lport_i = int(logical_port)
        if lport_i >= len(self.__member_list):
            member_str = ''

            for member in self.__member_list:
                member_str += '%d,' % member

            raise AssertionError('Logical port %d does not exist in member list' \
                                 ' [%s]' % (lport_i, member_str))
        else:
            return self.__member_list[lport_i]
        
## Volume Config Entry Class
#
# A volume is a wrapper around either a software raid device, 
# or a physical disk device for the appliances without software raid.
#
# On non sw raided units, the raid status routines are not supported.
# And the disk status will always report healthy
#
# The child device at this point can either be a partition, or a Raid Array,
# since we're using the old 2020 2 disk management method.
#
class VolumeConfig:
    def __init__(self, xml):
        self.__dict = {}
        self.__size_key = 'size'
        self.__type_key = 'type'
        self.__name_key = 'name'
        self.__rdev_key = 'rdev_name'
        self.__pid_key  = 'part_id'
        self.__ptype_key = 'ptype'
        self.__fstype_key = 'fstype'
        self.__layout_key = 'layout'
        self.__fill_to_end_key = 'fill_to_end'

        self.__volume_param = [ self.__type_key, 
                                self.__size_key, 
                                self.__name_key, 
                                self.__rdev_key, 
                                self.__pid_key, 
                                self.__ptype_key, 
                                self.__fstype_key, 
                                self.__layout_key,
                                self.__fill_to_end_key ]

        for vp in self.__volume_param:
            self.__dict[vp] = xml.getAttribute(vp)

    ## textual representation of the object
    def __str__(self):
        result = ''
        result += 'Volume:%s:%s:%s:%s:%s:%s:%s:%s\n' % (self.get_name(),
                                                   self.get_cfg_size(),
                                                   self.get_type(),
                                                   self.get_rdev(),
                                                   self.get_part_id(),
                                                   self.get_ptype(),
                                                   self.get_fstype(),
                                                   self.get_layout())

        return result

    ## return the object type
    # e.g 'utility', 'raid10', 'single'
    def get_type(self):
        return self.__dict[self.__type_key]

    ## returns the exact configuration size of the volume (as specified in the config)
    # this is only the actual partition size for utility or single volumes
    # for raid volumes this is the size of the raid array.
    def get_cfg_size(self):
        return int(self.__dict[self.__size_key])

    ## returns the exact configuration size of the volume (as specified in the config)
    # this is only the actual partition size for utility or single volumes
    # for raid volumes this is the size of the raid array.
    def get_name(self):
        return self.__dict[self.__name_key]
    
    ## returns the raid device associated with the volume.
    # if this is not a raid type volume, the empty string is returned (from the config)
    def get_rdev(self):
        return self.__dict[self.__rdev_key]

    ## returns the partition id (string) for the volume
    def get_part_id(self):
        return self.__dict[self.__pid_key]

    ## returns the partition type for the volume 
    # ['83', '0f', 'da', '82'] are current supported.
    def get_ptype(self):
        return self.__dict[self.__ptype_key]

    ## returns the fstype for the volume, or none if there is no filesystem on the 
    # volume. 
    # ["swap", "ext3", "none", "ext4" ] are currently supported.
    def get_fstype(self):
        return self.__dict[self.__fstype_key]

    ## returns the layout (string) for the volume, "f02" for far and "" for near
    def get_layout(self):
        return self.__dict[self.__layout_key]

    def get_fill_to_end(self):
        try:
            if self.__dict[self.__fill_to_end_key] != "":
                return self.__dict[self.__fill_to_end_key]
        except:
            pass

        return "false"

    ## validate that the configuration does not have any unsupported values.
    # @param layout the layout in which this volume is being validated.
    def validate(self, layout):
        if self.get_type() not in [ "single", "raid10", "utility", "raid5", "raid6", "raid6b", "ftraid" ]:
            raise rrdm_error(' Layout [%s] invalid volume type [%s] for volume [%s]' % (
                             layout.get_name(), self.get_type(), self.get_name()))

        if self.get_name() == '':
            raise rrdm_error ('Layout [%s] invalid volume name [%s]' % (layout.get_name(), 
                              self.get_name()))
                              
        if self.get_type() in [ "raid10", "raid5", "raid6", "raid6b" ]:
            if self.get_rdev() == '': 
                raise rrdm_error ('Layout [%s] volume [%s] requires an rdev name' % (
                                  layout.get_name(), self.get_name()))
    
        part_id = int(self.get_part_id())
        if part_id <= 0 or part_id > layout.get_num_volumes():
            raise rrdm_error ('Layout [%s] [%s] invalid partition [%d]' % (
                              layout.get_name(), self.get_name(),  part_id))
        
        if self.get_ptype() not in [ "83", "da", "0f", "82" ]:
            raise rrdm_error ('Layout [%s] [%s] invalid ptype [%s]' % (
                              layout.get_name(), self.get_name(), self.get_ptype()))
        
        if self.get_fstype() not in [ "none", "swap", "ext3", "ext4" ]:
            raise rrdm_error ('Layout [%s] [%s] invalid fstype [%s]' % (
                              layout.get_name(),
                              self.get_name(),
                              self.get_fstype()))
            
        if self.get_ptype() != "0f" and self.get_cfg_size() <= 0:
            raise rrdm_error ('Layout [%s] [%s] invalid size [%d]' % (
                              layout.get_name(),
                              self.get_name(),
                              self.get_cfg_size()))

        if self.get_layout() == "f02" and self.get_type() != "raid10":
            raise rrdm_error ('Layout [%s] [%s] cannot be f02 if type [%s]' % (
                              layout.get_name(),
                              self.get_name(),
                              self.type()))


    ## Return the partition size for the volume
    # @param zone The zone in which this volume lives. 
    # 
    # The zone is needed because raid volumes have their size listed as an aggregate
    # raid device size in a zone and the size is actually then based on the raid
    # type and array size.
    # 
    def get_part_size(self, zone):
        part_size   = compute_part_size_by_raid (self.get_cfg_size(), zone.get_disk_count(), 
                                                 self.get_type(), self.get_ptype())
        if part_size < 0:
            raise rrdm_error ('Zone [%s] Volume [%s] error computing disk partition size' % (
                              zone.get_name(), self.get_name()))

        return part_size


## DiskLayout Class
#
# Class representing a layout in the model configuration file.
# Layouts are used to define what disks look like in a particular 
# disk zone.
#
class DiskLayout:
    ## Constructor
    # @param xml the xml top level mode of a 'zone_layout' config entry.
    def __init__(self, xml):
        self.__name         = ''
        self.__size         = 0
        self.__num_volumes  = 0
        # indicates that rrdm_tool has to ignore this disk layout. 
        # Just use it for reporting - dont format or set-it up.
	self.__managed	    = 0
        self.__part_tbl_type = ''

        # XXX/munirb: parted does not do a great job when aligning
        # hardware RAID disks. We need to make sure that the partitions
        # align based on (number of usable disks * sector size)
        # We will take this parameter as part of specs definition.
        self.__gpt_part_align    = 0

        # indicats that rrdm_tool will ignore the disk layout, but 
        # it needs information about the partition table for reporting
        # purposes (Bluedell FTS case where SS, VE cache come from layout_settings
        # but the reporting from rrdm_tool)
        self.__report       = 0

        # part list corresponds to partitions on disk that 
        # we don't do reporting on, such as rvbd, or logical
        self.__part_list = []
        
        # vol_list corresponds to partitions on disk that we report on
        # for single disk units
        self.__vol_list  = []

        # raid_list contains all arrays in this layout
        self.__raid_list = []
        
        # fts_arr_list contains all fts disk arrays in this layout
        self.__fts_arr_list = []

        self.populate_from_xml(xml)

    ## Textual representation of the DiskLayout object
    def __str__(self):
        result = ''
        result += 'Disk Layout:%s:%d\n' % (self.__name, self.__num_volumes)
        result += 'Partitions:\n'
        for part in self.__part_list:
            result += str(part)

        return result

    ## Assuming we're passed the contents of a zone_layout xml node, read all
    # the info into the object
    # @param xml zone_layout xml object node.
    def populate_from_xml(self, xml):
        self.__name = xml.getAttribute('name')
        self.__size = int(xml.getAttribute('size'))

	try:
        	self.__managed = int(xml.getAttribute('managed'))
	except:
		self.__managed = 0
		pass
	
        try:
                self.__report = int(xml.getAttribute('report'))
        except:
                self.__report = 0
                pass

        # If the disk is managed and we don't want to report on the partition
        # layout from rrdm_tool then move on here.
        if self.__managed == 1 and self.__report == 0:
            return

	try:
		self.__part_tbl_type = xml.getAttribute('part_tbl_type')
	except:
		# Default MBR partition table type
		self.__part_tbl_type = 'mbr'
		pass

	if self.__part_tbl_type == '':
		self.__part_tbl_type = 'mbr'

        try:
            self.__gpt_part_align    = int(xml.getAttribute('gpt_part_align'))
        except:
            self.__gpt_part_align = 0
            pass

        vtable      = xml.getElementsByTagName('rios_volume')[0]
        self.__num_volumes = int(vtable.getAttribute('num'))

        if self.__num_volumes <= 0 and self.__managed == 0:
            raise rrdm_error ('Invalid number of volumes specified for layout [%s]' % 
                             (self.__name))

        volume_list = vtable.getElementsByTagName('volume')
        for volume in volume_list:
            vconf = VolumeConfig(volume)

            vconf.validate(self)

            self.__part_list.append (vconf)

            # Utility partitions are not exposed to higher levels, but
            # we send all raid and single type devices to the System for
            # so the raid disk tool can manage them
            #
            vtype = vconf.get_type()
            if vtype != 'utility':
                rlog_debug ('Array Name : %s ' % vconf.get_name())
                rlog_debug ('Array Dev : %s' % vconf.get_rdev())
                rlog_debug ('Array Part Id: %s' % vconf.get_part_id())

                if vtype == 'raid10':
                    self.__raid_list.append(vconf)
                elif vtype == 'raid5':
                    self.__raid_list.append(vconf)
                elif vtype in [ "raid6", "raid6b" ]:
                    self.__raid_list.append(vconf)
                elif vtype == 'ftraid':
                    self.__fts_arr_list.append(vconf)
                elif vtype == 'single':
                    self.__vol_list.append(vconf)

    ######### Object Access Routines ##########################################

    ## Returns the minimum disk size needed for this layout
    def get_disk_size(self):
        return self.__size

    def managed_disk(self):
        return self.__managed

    def get_part_tbl_type(self):
        return self.__part_tbl_type

    def get_gpt_part_align(self):
        return self.__gpt_part_align

    def reported_disk(self):
        return self.__report

    def get_num_volumes(self):
        return self.__num_volumes

    def get_name(self):
        return self.__name

    ## Returns a list of VolumeConfig classes which describe the partitions 
    # for this layout
    def get_part_list(self):
        return self.__part_list
    
    ## Returns a list of VolumeConfig classes which describe the single use
    # volumes for this layout
    def get_vol_list(self):
        return self.__vol_list

    ## Returns a list of VolumeConfig classes which describe the raid 
    # partitions for this layout
    def get_raid_list(self):
        return self.__raid_list

    ## Returns a list of VolumeConfig classes which describe the
    # ftraid partitions for this layout.
    def get_ftraid_list(self):
        return self.__fts_arr_list

    ## has_volume_by_name
    # @param name Name of partition (see specs.xml)
    # Returns True if there is the named partition is present in
    # this layout, False otherwise.
    def has_volume_by_name(self, name):
        for vol in self.__vol_list:
            if vol.get_name() == name:
                return True
        for raid in self.__raid_list:
            if raid.get_name() == name:
                return True
        for fts in self.__fts_arr_list:
            if fts.get_name() == name:
                return True

        return False

    ## 
    # 
    def get_volume_by_name(self, name):
        for vol in self.__vol_list:
            if vol.get_name() == name:
                return vol
        for raid in self.__raid_list:
            if raid.get_name() == name:
                return raid
        for fts in self.__fts_arr_list:
            if fts.get_name() == name:
                return fts

        return None


        

## DiskLayoutMap Class
# Wrapper class that contains all the layouts read from the configuration 
# file. It provides a dictionary style interface to the layouts.
#
class DiskLayoutMap:
    def __init__(self, xml = None, spec_file = None):
        from xml.dom.minidom import parse
        self.__layout_map = {}

        if xml == None and spec_file != None:
            if not exists(spec_file):
                raise rrdm_error ('Spec file not found : %s' % spec_file)

            xml = parse(spec_file)
        elif xml == None:
            raise rrdm_error ('DiskLayoutMap XML node or spec file name required')
       
        self.populate_from_xml(xml)

    ## Assuming we're passed the contents the config file root xml node,
    # read all the layout information into a dictionary
    # @param xml configuration file xml root node.
    def populate_from_xml(self, xml):
        layout_list = xml.getElementsByTagName('zone_layout')
        for layout in layout_list:
            dl = DiskLayout(layout) 
            if not self.__layout_map.has_key(dl.get_name()):
                rlog_debug ('Layout: adding [%s] to layout list.' % dl.get_name())
                self.__layout_map[dl.get_name()] = dl
            else:
                rlog_warning('Duplicate layout entry detected for layout [%s].' % 
                             dl.get_name())
        rlog_debug ('Layout: found [%d] layouts.' % len(self.__layout_map))

    ## String representation of layout map
    def __str__(self):
        result = 'Num Layouts: %d\n' % self.get_num_layouts()
        for layout_key in self.__layout_map.iterkeys():
            result += str(self.__layout_map[layout_key])

        return result

    ####### Object Access Routines ############################################

    def get_num_layouts(self):
        return len(self.__layout_map)

    def get_layout_by_name(self, name):
        if self.__layout_map.has_key(name):
            return self.__layout_map[name]
        else:
            return None
    
## DiskZoneSpec Class
#
# A disk zone spec describes a subset of the appliances disks grouped for a 
# specific function. Each zone can have its own partitioning scheme
# roughly described by the layout.
#
class DiskZoneSpec:
    ## contructor
    # @param layout_map list of all available layouts
    # @param darray_members DiskMemberManager object describing 
    #        the list of managed system disks
    # @param xml xml entry corresonding to a disk_zone node in a appliance spec
    #
    def __init__(self, layout_map, darray_members, xml=None):
        self.__system_disk_members = darray_members
        self.__disk_members = None
    
        self.populate_from_xml(xml)
        self.__layout       = layout_map.get_layout_by_name(self.__layout_name)
        self.__disk_size    = self.__layout.get_disk_size()


    ## Textual representation of the Disk Zone object
    def __str__(self):
        result = ''
        result += 'Zone:%s:%s:%s:%s' % (self.__name,
                                        self.__disk_quantity,
                                        self.__layout.get_name(),
                                        ','.join(self.__allowed_media))
        for disk_ix in self.get_disk_index_list():
            result += ':%d' % disk_ix
        result += '\n'
        return result

    ## __check_zone_disk_config
    # After parsing the disk_zone xml, we want to sure
    # that the zone disk usage is consistant with the 
    # overall system picture of disks
    def __check_zone_disk_config(self):
        zone_dlist = self.__disk_members.get_disks()
        sys_dlist = self.__system_disk_members.get_disks()

        for disk in zone_dlist:
            if disk not in sys_dlist:
                raise AssertionError('DiskZone %s references invalid system' \
                                     ' disk %s' % (self.get_name(),
                                                   disk))
        

    ## populate the class members from the disk_zone xml config
    # @param xml disk_zone xml config node
    def populate_from_xml(self, xml):
        self.__name             = xml.getAttribute('name')
        self.__layout_name      = xml.getAttribute('layout')
        self.__start            = xml.getAttribute('start')
        self.__order            = xml.getAttribute('order')
        self.__allowed_media    = []           
        self.__align_sectors    = xml.getAttribute('align_sectors')

        disk_quantity = xml.getAttribute('quantity')
        disk_members  = xml.getAttribute('members')
        if disk_quantity != '' and disk_members != '':
            raise AssertionError('Disk Zone quantity and members are mutually' \
                                 ' exclusive')

        if disk_members != '':
            dmm = DiskMemberManager(disk_members)
        elif disk_quantity != '':
            start = int(self.__start)
            end_disk = int(disk_quantity) + start - 1
            
            dmm = DiskMemberManager('%s-%s' % (start, end_disk), self.__order)
        else:
            raise AssertionError('Disk Zone requires either quantity or' \
                                 ' members attributes')

        self.__disk_members     = dmm
        self.__disk_quantity    = dmm.get_num_disks()

        disk_mode = xml.getAttribute('disk_mode')
        if disk_mode == '':
            # default to mode_type_raid
            self.__disk_mode = DiskStatusMode(DiskStatusMode.mode_type_mgmt_legacy)
        else:
            self.__disk_mode = DiskStatusMode(disk_mode)
        
        if not self.__disk_mode.is_valid():
            rlog_warning ('Unknown disk mode %s in zone %s' %(
                           disk_mode, self.__name))

        dm = DiskMedia()

        # handle the media attribute, which will allow us to 
        # properly filter on invalid disk types inserted into a zone.
        # the media field in the config is comma seperated
        #
        # empty or unset media types default to disk
        #
        if xml.getAttribute('media') != None:
            media_str   = xml.getAttribute('media')
            if media_str == '':
                self.__allowed_media.append(dm.media_type_disk)
            else:
                media_list  = media_str.strip().lower().split(',') 
                for media in media_list:
                    if dm.is_valid_media_type(media):
                        self.__allowed_media.append (media)
                    else:
                        rlog_warning ('Unknown media type %s in zone %s' %(
                                      media, self.__name))
        else:
            self.__allowed_media.append (dm.media_type_disk)

        # make sure this disk zone is consistent with the disks known
        # by the system disk members
        self.__check_zone_disk_config()

    ####### Object Access Routines #############################################

    ## Return True if the indicated media type is valid for this zone
    # @param media
    def is_media_valid(self, media):
        return media in self.__allowed_media

    ## get_valid_media
    # Returns a list of allowable media types, which are strings. Refer
    # to DiskMedia class definition for valid strings
    def get_valid_media(self):
        return self.__allowed_media

    ## Return the DiskStatusMode class describing how drive status should be
    # determined for disks in this Zone.
    #
    def get_disk_status_mode(self):
        return self.__disk_mode

    ## is_drive_in_zone
    # @param drive integer disk index e.g 1 for disk1
    # 
    # Return True if the indicated drive number is part of this zone
    def is_drive_in_zone(self, drive):
        return drive in self.get_disk_index_list()

    def get_disk_count(self):
        return int(self.__disk_quantity)

    def get_disk_size(self):
        return self.__disk_size

    def get_name(self):
        return self.__name

    def get_layout(self):
        return self.__layout

    def zone_logical_to_physical(self, 
                                 logical_drive):
        return self.__disk_members.find_physical_port(logical_drive)

    def physical_to_zone_logical(self,
                                 physical_drive):
        return self.__disk_members.find_logical_port(physical_drive)

    ## has_volume_by_name
    # @param name a rios name for a given partition 
    # Returns True if this diskzonespec's layout has a volume named name
    # or False otherwise.
    def has_volume_by_name(self, name):
        return self.__layout.has_volume_by_name(name)

    def get_volume_by_name(self, name):
        return self.__layout.get_volume_by_name(name)

    ## returns a list of disk id's that are located within this zone
    def get_disk_index_list(self):
        return self.__disk_members.get_disks()

    ## returns a list of raid arrays inside this zone, these are 
    # VolumeConfig objects
    def get_raid_arrays(self):
        return self.__layout.get_raid_list()

    def get_ftraid_arrays(self):
        return self.__layout.get_ftraid_list()

    ## returns a list of volumes arrays inside this zone, these 
    # are VolumeConfig objects
    def get_volumes(self):
        return self.__layout.get_vol_list()

    def get_align_sectors(self):
        return self.__align_sectors

## Disk Zone Class
# This class wraps the physical system disk and raid objects that are part of 
# the zone
#
class DiskZone:
    ## constructor
    # @param zone_cfg The configuration zone object for this zone
    # @param disk_array The systems array of HardDisk objects
    #
    def __init__(self, zone_cfg, disk_array):
        self.__name     = zone_cfg.get_name()
        self.__zone_cfg = zone_cfg
        self.__disk_array = disk_array.get_disk_array_slice(
                                self.__zone_cfg.get_disk_index_list())
        self.__raid_arrays  = []
        self.__volumes      = []
        self.__ftraid_arrays = []

    ####### Object Access Methods #############################################

    def get_status(self, xml=False):
            self.__disk_array.get_status(xml)

    def get_disk_array(self):
        return self.__disk_array

    def get_raid_arrays(self):
        return self.__raid_arrays

    def get_volumes(self):
        return self.__volumes
    
    def add_raid_array(self, rarray):
        self.__raid_arrays.append(rarray)

    def add_volume(self, vol):
        self.__volumes.append(vol)

    def add_ftraid_array(self, ftarray):
        self.__ftraid_arrays.append(ftarray)

    def get_ftraid_arrays(self):
        return self.__ftraid_arrays

    def get_name(self):
        return self.__name

## SpecDiskConfig
# The SpecDiskConfig class maintains a superset of legacy disk management
# where there was only one disk node in the spec xml for a given model
# and the storage profile meechanism, where there may be multiple
# disk nodes for a given model, indexed by the associated profile
# 
# This is needed, since one units supporting profiles, one profile may
# have disks partitioned differently than others.  For example,
# with RSP only mode to VE only mode, we shrink the volume sizes for RSP
# and give that data to VE (leaving minimal RSP space)
# And also for the shared mode, we once again split the non sport / mgmt
# space on the disks in half and give half to rsp and half to VE.
# These all correspond to the same model, but the profile drives the
# partition layouts. With the above, we need to associate a spec with 
# multiple possible layouts
class SpecDiskConfig:
    def __init__(self,
                 name,
                 disk_zone_map,
                 raid_arrays,
                 volumes,
                 ftraid_arrays,
                 disk_member):
        self.__name = name
        self.__disk_zone_map = disk_zone_map
        self.__raid_arrays   = raid_arrays
        self.__volumes       = volumes
        self.__ftraid_arrays = ftraid_arrays
        self.__disk_members   = disk_member

    def __str__(self):
        prefix = '%s' % self.__name
        result = ''
        result += '%s/raid_arrays=%d\n' % (prefix,
                                           len(self.__raid_arrays))
        result += '%s/ftraid_arrays=%d\n' % (prefix,
                                             len(self.__ftraid_arrays))
        result += '%s/volumes=%d\n' % (prefix,
                                       len(self.__volumes))
        return result

    #### External Methods ####################################################
    def get_volumes(self):
        return self.__volumes
    
    def get_raid_arrays(self):
        return self.__raid_arrays

    def get_ftraid_arrays(self):
        return self.__ftraid_arrays

    def get_zone_map(self):
        return self.__disk_zone_map

    def get_name(self):
        return self.__name

    def get_num_disks(self):
        return self.__disk_members.get_num_disks()
    
    def get_disks(self):
        return self.__disk_members.get_disks()
    

class SpecDiskConfigMap:
    legacy_config_type  = 'legacy'
    storage_config_type = 'storage_profile'

    ## Init Method
    # @param layout_map DiskLayoutMap object
    # @param xml xml.dom.minidom node for the spec object
    # @param legacy boolean indicating whether this is a legacy
    #        disk node (which doesn't have profiles associated with it)
    def __init__(self,
                 layout_map,
                 xml,
                 is_legacy):

        self.__layout_map = layout_map
        self.__scfg_map   = {}

        if is_legacy:
            self.__type = self.legacy_config_type
        else:
            self.__type = self.storage_config_type
    
        self.__populate_disk_configs(xml)

    def __str__(self):
        prefix = 'diskconfigs'
        result = ''
        for sdiskcfg in self.__scfg_map.values():
            for line in str(sdiskcfg).strip().split():
                result += '%s/%s\n' % (prefix, line)
        return result

    ## __populate_disk_node
    # @param xml xml.dom.minidom spec disk node
    # Populates a single disk array config into the 
    # disk config map
    def __populate_disk_node(self,
                             disk,
                             layout_map,
                             legacy):
        disk_zones    = {}
        raid_arrays   = []
        volumes       = []
        ftraid_arrays = []
        disk_count    = 0
        profile_list  = []

        # quantity and members are mutually exclusive.
        # quantity describes a range (0 through quantity-1) of disks
        # members describes a non-linear range of disks
        dqnode = disk.getAttribute('quantity')
        dmnode = disk.getAttribute('members')
        if dmnode != '' and dqnode != '':
            raise AssertionError('members and quantity attributes are' \
                                 ' mutually exclusive')

        if dmnode != '':
            dmm = DiskMemberManager(dmnode)
        elif dqnode != '':
            dmm = DiskMemberManager(dqnode)
        else:
            raise AssertionError('Either members of quantity must be specified')
        
        cfg_zones  = disk.getElementsByTagName('disk_zone')

        if not legacy:
            # lets check to see if we have a profile node
            # if so, we'll create one storage config
            # for each profile associated with that scfg
            sup_profiles = disk.getAttribute('profile')
            if sup_profiles in [ None, '' ]:
                # a profile node in non-legacy mode
                # must be associated with a profile, or multiple 
                # profiles
                raise AssertionError('Invalid disk node, missing profile')
            else:
                # the field is a comma seperated list of profile names
                profile_list = sup_profiles.split(',')
        else:
            # otherwise its legacy, and we use the default legacy name
            profile_list = [ self.legacy_config_type ]

        for cfg_zone in cfg_zones:
            dz = DiskZoneSpec(layout_map, dmm, cfg_zone)
            disk_zones[dz.get_name()] = dz

        for zone in disk_zones.values():
            raid_arrays.extend(zone.get_raid_arrays())
            volumes.extend(zone.get_volumes())
            ftraid_arrays.extend(zone.get_ftraid_arrays())

        for profile_name in profile_list:
            sdcfg = SpecDiskConfig(profile_name,
                                   disk_zones,
                                   raid_arrays,
                                   volumes,
                                   ftraid_arrays,
                                   dmm)
            self.__scfg_map[profile_name] = sdcfg
        

    def __populate_disk_configs(self,
                                xml):
        # otherwise we have the possibility of multiple disk configs
        # each associated with a profile
        disk_nodes = xml.getElementsByTagName('disk')
        for disk in disk_nodes:
            self.__populate_disk_node(disk, 
                                      self.__layout_map, 
                                      self.is_legacy())

    ## is_legacy
    # Returns True if the config is for an appliance not using the storage
    # config specifications.
    def is_legacy(self):
        return self.__type == self.legacy_config_type

    ## get_disk_config
    # @param name name of a storage config (either the profile name,
    #                  or 'legacy' or specs without storage options
    def get_disk_config(self, 
                        name):
        
        if self.has_disk_config(name):
            return self.__scfg_map[name]
        else:
            return None

    ## has_disk_config
    # @param name name of a storage config (either the profile name,
    #                  or 'legacy' or specs without storage options
    # Returns True if there is a disk config for the named profile
    def has_disk_config(self,
                        name):
        return self.__scfg_map.has_key(name)

    ## get_disk_configs
    # Returns the list of disk configs available for this spec
    def get_disk_configs(self):
        return self.__scfg_map.values()

    ## get_num_disk_configs
    # Return the number of storage configs in this map object
    def get_num_disk_configs(self):
        return len(self.__scfg_map.keys())

    ## get_disk_volumes
    # @param profile name of a profile
    # @param disk_ix index of a disk in the system (absolute disk num)
    # 
    # Returns the volumes associated with a given profile (if any) for
    # a given disk in the system.  If the drive is not in a zone
    # None is returned
    def get_disk_volumes(self,
                         profile,
                         disk_ix):
        sdiskcfg = self.__scfg_map[profile]
        zmap = sdiskcfg.get_zone_map()
        for zone in zmap.values():
            if zone.is_drive_in_zone(disk_ix):
                return zone.get_volumes()

        return None

    ## get_disk_layout
    # @param profile name of a profile
    # @param disk_ix index of a disk in the system (absolute disk num)
    # 
    # Returns the DiskLayout associated with a given profile (if any) for
    # a given disk in the system.  If the drive is not in a zone
    # None is returned
    def get_disk_layout(self,
                        profile,
                        disk_ix):
        sdiskcfg = self.__scfg_map[profile]
        zmap = sdiskcfg.get_zone_map()
        for zone in zmap.values():
            if zone.is_drive_in_zone(disk_ix):
                return zone.get_layout()

        return None


        

###############################################################################
# Spec Class
#
# Wrapper for associative arrays describing what this appliance should look like.
# these parameters are filled in from the configuration file (specs.xml)
#
###############################################################################
class Spec:
    ## constructor
    # @param layout_map DiskLayoutMap class holding all the layouts specs
    # @param xml Spec xml node
    # @param name spec name
    # @param storage_map StorageProfileMap object containing profile info from 
    #        specs.xml
    #
    def __init__(self, 
                 layout_map, 
                 xml, 
                 name, 
                 storage_map):
        self.__name           = name
        self.__disk_count     = 0
        self.__uses_layouts   = True
        self.__order          = ''
        self.__start          = -1
        self.__partitions     = []

        # disk zones/raid arrays etc have moved to the 
        # SpecDiskConfigMap, as one spec now may have 
        # multiple configurations based on the profile
        # but for non-legacy units, the raid arrays should all
        # be defined as logical volumes
        self.__sd_cfg_map = None

        # since the spec makes it to many places in the code today
        # where the profile does not always make it, we're adding
        # the ability to set a "view" of the spec object,
        # which makes it adhere to the old interfaaces.
        # the spec object can then carry around its profile
        # to the places where it would be needed, and we don't have to
        # retrofit all the class objects to propagate the current 
        # profile name
        self.__spec_profile = None

        # the following members will only be available once
        # a spec view/profile is chosen, for appliances
        # with storage configs, only the zones and volumes will
        # have data as ftraid, etc are all driven by storage configs.
        self.__disk_zones     = {}
        self.__volumes        = []
        self.__raid_arrays    = []
        self.__ftraid_arrays  = []
        self.__disk_count     = -1
        
        self.__class        = ''
        self.__subclass     = ''
        self.__cores        = 0
        self.__core_speed   = 0
        self.__memory_size  = 0
        self.__edge_mem_rule = ''
        self.__vsp_default   = ''
        self.__vsp_addon     = ''
        self.__class        = ''
        self.__upgrade_script = ''
        self.__flash        = 'none'
        self.__granite      = False
        self.__super_spec   = None
        self.__upgrade_model = None
        self.__upgrade = False 
        self.__storage_map = storage_map
        self.__default_scfg_name = None
        self.__parent_config = None
        self.__raid_sb_version = None
        self.__supported_profiles = []   # This is the list of supported profiles
                                         # It has to be a subset of the specs 

        self.__disk_member_list = []
        self.__ssd_align_boundary = self.get_ssd_def_align_boundary()

        self.populate_from_xml(layout_map, xml)

    ## text representation of the Spec
    def __str__(self):
        result = ''
        result += 'Specification:%s\n' % self.__name
        result += 'Class:%s Subclass:%s\n' % (self.__class, self.__subclass)
        result += 'Cores: %d\tCore Speed: %d\n' % (self.__cores, self.__core_speed)
        result += 'Memory: %d\n' % self.__memory_size
        result += 'Upgrade Script: %s\n' % self.__upgrade_script
        result += 'Has Model Upgrade: %s\n' % self.__upgrade_model
        result += 'Num Disks: %d\n' % self.__disk_count
        result += 'Uses Layouts: %s\n' % str(self.__uses_layouts)
        result += 'Has Storage Cfg: %s\n' % str(self.has_storage_cfg())
        result += 'Supported profiles: %s\n' % str(self.get_supported_profiles())
        result += 'RAID superblock version: %s\n' % str(self.get_raid_sb_version())
        
        if self.__granite:
            result += 'Granite Product: true\n'
        else:
            result += 'Granite Product: false\n'

        return result

    ####### Object Access Methods #############################################

    ## get_spec_cfg_disk_map
    # Return the SpecDiskConfigMap object associated with this spec
    def get_spec_cfg_disk_map(self):
        return self.__sd_cfg_map

    ## get_spec_profile
    # Returns the spec profile currently associated with this spec object
    def get_spec_profile(self):
        return self.__spec_profile

    def set_spec_profile_view(self, 
                              profile):
        if self.__sd_cfg_map.is_legacy():
            self.__spec_profile = SpecDiskConfigMap.legacy_config_type
        elif self.__sd_cfg_map.has_disk_config(profile):
            self.__spec_profile = profile
        else:
            raise AssertionError('Invalid spec profile %s for spec %s ' % \
                                (profile.get_name(), self.get_name()))

        # XXX good to also look up the specific storage config
        # for the model and see if we have a profile for it.

        # otherwise fill in the local information from the
        # given profile

        # update the member variables to reflect this profiles 
        # view of the spec. Note that for storage profiles,
        # the ftraid/raid arrays will not be populated by the zone
        # info, and thus will be empty.
        # to find those you need to look at the storage config/profile
        spec_disk_cfg = self.__sd_cfg_map.get_disk_config(self.__spec_profile)
        self.__disk_count    = spec_disk_cfg.get_num_disks()
        self.__disk_member_list  = spec_disk_cfg.get_disks()
        self.__raid_arrays   = spec_disk_cfg.get_raid_arrays()
        self.__ftraid_arrays = spec_disk_cfg.get_ftraid_arrays()
        self.__volumes       = spec_disk_cfg.get_volumes()
        self.__disk_zones    = spec_disk_cfg.get_zone_map()

    def get_disk_members(self):
        return self.__disk_member_list

    def get_name(self):
        return self.__name

    def get_disk_count(self):
        return self.__disk_count

    ## given a int disk id .. find out what zone it is in.
    # @param drive integer drive id
    def get_disk_zone_spec(self, drive):
        for zone_key in self.__disk_zones:
            if self.__disk_zones[zone_key].is_drive_in_zone(drive):
                return self.__disk_zones[zone_key]

        return None
    
    def get_zone_list(self):
        return self.__disk_zones.values()

    ## Look up a zone specification by name
    # returns None if no zone exists by that name
    def get_zone_spec_by_name(self, name):
        if self.__disk_zones.has_key(name):
            return self.__disk_zones[name]
        else:
            return None

    def get_pdrive_from_zone_logical(self,
                                     zname,
                                     logical_drive):
        zone = self.get_zone_spec_by_name(zname)
        return zone.zone_logical_to_physical(logical_drive)

    def get_zone_volume(self, 
                        zname,
                        volname):
        zone = self.get_zone_spec_by_name(zname)
        return zone.get_volume_by_name(volname)
        
    def get_raid_arrays(self):
        return self.__raid_arrays

    def get_ftraid_arrays(self):
        return self.__ftraid_arrays

    ## Return whether this appliance model has any raid arrays
    # associated with it.
    def uses_raid(self, profile=None):
        if self.has_storage_cfg():
            return self.get_storage_cfg().uses_sw_raid(profile)
        else:
            return len(self.__raid_arrays) > 0

    def get_volumes(self):
        return self.__volumes

    # the real class is the class + subclass
    def get_real_class(self):
        if self.__subclass != '':
            return '%s,%s' % (self.__class, self.__subclass)
        else:
            return self.__class

    def get_class(self):
        return self.__class

    def get_subclass(self):
        return self.__subclass

    def get_cores(self):
        return self.__cores
    
    def get_core_speed(self):
        return self.__core_speed

    def get_memory_size(self):
        return self.__memory_size

    def get_edge_mem_size(self):
        return self.__edge_mem_rule

    def get_vsp_default(self):
        return self.__vsp_default

    def get_vsp_addon(self):
        return self.__vsp_addon

    def get_reserve_mem(self):
        return self.__reserve_mem_size

    def get_flash(self):
        return self.__flash

    def get_upgrade_script(self):
        return self.__upgrade_script

    def uses_layouts(self):
        return self.__uses_layouts
    
    def is_granite(self):
        return self.__granite

    def get_ssd_align_boundary(self):
        return self.__ssd_align_boundary        

    def get_ssd_def_align_boundary(self):
        try:
            from rbt_product_settings import get_prod_ssd_align_boundary
            return get_prod_ssd_align_boundary()
        except ImportError:
            return DEFAULT_ALIGNMENT

    ## Find out if this spec upgrade may require model data changes
    # if the upgrade path does not require hardware
    # notably the case where we don't change the disk layout, but 
    # increase the segstore size, we need to update the mfdb
    # and signal a segstore clean
    def has_model_upgrade(self):
        return self.__upgrade_model

    ## Find out if the upgrade to this model is disabled
    # We want to disable upgrade to 5050L model from any path
    def is_upgrade_disabled(self):
        return self.__upgrade

    ## Find out what size a disk should be by finding which zone it is in
    # @param id integer disk id
    # 
    def get_disk_size_by_id(self, id):
        for zone in self.get_zone_list():
            if zone.is_drive_in_zone(id):
                return zone.get_disk_size()

    ## Find out what size disks should be in a given zone
    # @param zone the string name of a xone
    def get_disk_size_by_zone(self, zone):
        if self.__disk_zones.has_key(zone):
            return self.__disk_zones[zone].get_disk_size()
        else:
            raise rrdm_error ('unknown zone %s specified' % zone)

    def __overlay_spec(self, super_spec):
        self.__class         = super_spec.get_class()
        self.__subclass      = super_spec.get_subclass()
        self.__cores         = super_spec.get_cores()
        self.__core_speed    = super_spec.get_core_speed()
        self.__memory_size   = super_spec.get_memory_size()
        self.__flash         = super_spec.get_flash()
        self.__edge_mem_rule = super_spec.get_edge_mem_size()
        self.__vsp_default   = super_spec.get_vsp_default()
        self.__vsp_addon     = super_spec.get_vsp_addon()
        self.__granite       = super_spec.is_granite()
        self.__raid_sb_version =   super_spec.get_raid_sb_version()
        self.__ssd_align_boundary = super_spec.get_ssd_align_boundary()

    def __read_base_spec_info(self, xml):
        cpu_xml = xml.getElementsByTagName('cpu')
        if len(cpu_xml) != 0:
            self.__cores        = int(cpu_xml[0].getAttribute('cores'))
            self.__core_speed   = int(cpu_xml[0].getAttribute('speed') )
            
        mach_xml = xml.getElementsByTagName('machine') 
        if len(mach_xml) != 0:
            self.__class = mach_xml[0].getAttribute('class')
            self.__subclass = mach_xml[0].getAttribute('subclass')
        
        mem_xml = xml.getElementsByTagName('memory')
        if len(mem_xml) != 0:
            self.__memory_size = int(mem_xml[0].getAttribute('size'))
            self.__edge_mem_rule = mem_xml[0].getAttribute('edge_mem_size')
            if len(mem_xml[0].getAttribute('reserve_mem')) != 0:
                self.__reserve_mem_size = int(mem_xml[0].getAttribute('reserve_mem'))
            if len(mem_xml[0].getAttribute('vsp_default')) != 0:
                self.__vsp_default = mem_xml[0].getAttribute('vsp_default')
            if len(mem_xml[0].getAttribute('vsp_addon')) != 0:
                self.__vsp_addon = mem_xml[0].getAttribute('vsp_addon')

        flash_xml = xml.getElementsByTagName('flash')
        if len(flash_xml) != 0:
            self.__flash = flash_xml[0].getAttribute('presence')

        product_xml = xml.getElementsByTagName('product')
        if len(product_xml) != 0:
            if product_xml[0].getAttribute('granite').lower() == 'true': 
                self.__granite = True

        upgrade_xml = xml.getElementsByTagName('upgrade')
        if len(upgrade_xml) != 0:
            if upgrade_xml[0].getAttribute('disable').lower() == 'true':
                self.__upgrade = True

        raid_xml= xml.getElementsByTagName('raid')
        if len(raid_xml) != 0:
            if raid_xml[0].getAttribute('sb_version').lower() == 'default':
                self.__raid_sb_version = 'default'
            else:
                self.__raid_sb_version = raid_xml[0].getAttribute('sb_version')


        disk_align_xml = xml.getElementsByTagName('disk_align')
        if len(disk_align_xml) != 0:
            self.__ssd_align_boundary = \
                     int(disk_align_xml[0].getAttribute('ssd_align_boundary'))

    ## read the spec from the xml config
    # @param layout_map a DiskLayoutMap populated from the config file.
    # @param xml a spec xml node of the config file
    def populate_from_xml(self, 
                          layout_map, 
                          xml):
        specs_xml = xml.getElementsByTagName('spec') 
        cur_spec_xml = None
        for spec in specs_xml:
            if self.__name == spec.getAttribute('name'):
                cur_spec_xml = spec
                break

        if cur_spec_xml == None:
            raise rrdm_error ('Unable to find spec %s' % self.__name)

        upgrade_xml = cur_spec_xml.getElementsByTagName('upgrade')
        if len(upgrade_xml) != 0:
            self.__upgrade_script = upgrade_xml[0].getAttribute('script')
            upmodel = upgrade_xml[0].getAttribute('upmodel')
            if upmodel.lower() == 'true':
                self.__upgrade_model = True
            else:
                self.__upgrade_model = False

        super_xml = cur_spec_xml.getElementsByTagName('superspec')
        if len(super_xml) != 0:
            self.__super_spec = super_xml[0].getAttribute('names')

            superspec = Spec(layout_map, 
                             xml, 
                             self.__super_spec, 
                             self.__storage_map)
            self.__overlay_spec(superspec)

        self.__read_base_spec_info(cur_spec_xml)
        
        disk_node = cur_spec_xml.getElementsByTagName('disk')
        # if there is a disk config node, we are in legacy mode
        # where the spec maintains the disk /volume maps based on zones
        if disk_node != []:
            # grab the uses layouts flag . this is needed for the case of
            # procurve where we don't manage any disks
            use_layout = disk_node[0].getAttribute('use_layout')

            # if the use_layout attr is not set we assume we're using layouts
            self.__uses_layouts = use_layout == '' or use_layout == 'true'
        else:
            # units with storage configs require this
            self.__uses_layouts = True

        stor_node = cur_spec_xml.getElementsByTagName('storage_config')
        if stor_node in [ None, [] ]:
            # extended storage configs are not present for this spec
            self.__storage_cfg = None

        else:
            scfg_name = stor_node[0].getAttribute('name')
            self.__default_scfg_name = stor_node[0].getAttribute('default')

            self.__supported_profiles = stor_node[0].getAttribute('supported_profiles')
            self.__parent_config = stor_node[0].getAttribute('parent_config')

            self.__storage_cfg = \
                self.__storage_map.get_storage_config(scfg_name)

        # only populate zone info if we have it. some newer models
        # such as HP models have specs but don't use rrdm_tool to 
        # perform disk layouts.
        #
        # for models using storage configs, there are no raid arrays
        # defined in the zone definition, but each storage profile
        # can have a different disk layout, so we change the logic in here 
        # to create a storage context indexed by the profile name 
        # if profiles are supported, or a well known string if
        # the model does not support storage profiles
	if self.__uses_layouts:
            if not self.has_storage_cfg():
                self.__sd_cfg_map = SpecDiskConfigMap(layout_map = layout_map,
                                                      xml = cur_spec_xml,
                                                      is_legacy = True)
            else:
                # for storage config based models, we pull the info
                # from the storage config
                self.__sd_cfg_map = self.__storage_cfg.get_disk_cfg_map()
            
            if self.__sd_cfg_map.get_num_disk_configs() == 0:
                raise AssertionError('Spec %s Config %s has no associated' \
                                     ' disk configuration' % \
                                     (self.get_name(),
                                      self.__storage_cfg.get_name))

        # if we are in legacy mode, we'll set up the spec so it 
        # looks like an old spec without having have a profile associated
        # with it before you can get access to volume info
        # 
        if self.__sd_cfg_map != None and \
            self.__sd_cfg_map.is_legacy():
            self.set_spec_profile_view(SpecDiskConfigMap.legacy_config_type)
                                     
    ## has_storage_cfg
    # Returns True if this spec supports the new storage config
    # volume descriptions
    def has_storage_cfg(self):
        return self.__storage_cfg != None

    ## get_default_scfg_name
    # Returns the default storage config associated with this spec
    # or None if this is a legacy config
    def get_default_scfg_name(self):
        return self.__default_scfg_name

    ## get_parent_config
    # A spec with a storage config equal to this specs parent config can
    # upgrade to this spec with a hardware replacement
    def get_parent_config(self):
        return self.__parent_config

    ## get_supported_profiles
    # Returns the supported profiles for this spec
    def get_supported_profiles(self):
        if self.__supported_profiles != None and self.__supported_profiles != '':
           return self.__supported_profiles.split(',')
        else:
           return None

    ## get_storage_cfg
    # Returns the StorageConfig object associated with the spec
    # The storage cfg object contains all information about
    # logical volumes exported on a unit using the extended volume
    # xml definitions
    def get_storage_cfg(self):
        return self.__storage_cfg

    ## has_lvm_by_name
    # @param name of the logical volume
    # Returns True if the current spec view has a logical volume
    #  with a given name
    def has_lvm_by_name(self,
                        name):
        if self.__spec_profile == SpecDiskConfigMap.legacy_config_type:
            return False

        lvm_list = self.__storage_cfg.get_logical_volumes(self.__spec_profile)
        for lvm in lvm_list:
            if lvm.get_name() == name:
                return True
        return False

    ## get_lvm_by_name
    # @param name of the logical volume
    # Returns the LogicalVolumeConfig object corresponding to name
    # in the current profile view
    def get_lvm_by_name(self,
                        name):
        if self.__spec_profile == SpecDiskConfigMap.legacy_config_type:
            return None

        lvm_list = self.__storage_cfg.get_logical_volumes(self.__spec_profile)
        for lvm in lvm_list:
            if lvm.get_name() == name:
                return lvm
    
        return None

    ## get_raid_sb_version
    # A hook for setting the RAID metadata/superblock version
    # If None, then we nail the version to 0.9 (backwards compatible)
    # Other options are "default" (use the native mdadm default)
    # or any flag that goes after mdadm's "--metadata=" flag
    def get_raid_sb_version(self):
            return self.__raid_sb_version

## Container for all spec's in the specs.xml file.
class SpecMap:
    ## SpecMap constructor
    # @param layout_map is a list of layouts defined in specs.xml
    # @param xml is the root xml node containing all spec nodes in the 
    #        specs.xml file
    def __init__(self, layout_map, xml, storage_map):
        self.__spec_map = {}
        self.__class_map = {}
           
        for spec_node in xml.getElementsByTagName('spec'):
            name = spec_node.getAttribute('name')

            spec = Spec(layout_map, xml, name, storage_map)
            self.__spec_map[spec.get_name()] = spec

            if self.__class_map.has_key(spec.get_real_class()):
                self.__class_map[spec.get_real_class()].append(spec)
            else:
                self.__class_map[spec.get_real_class()] = [ spec ] 

    ## string representation of the SpecMap
    def __str__(self):
        result = ''
        result += 'Spec List [%d specs]\n' % len(self.__spec_map)
        for spec in self.__spec_map.values():
            result += str(spec)

        result += 'Spec Classes [%d classes]\n' % len (self.__class_map)
        for m_list in self.__class_map.values():
            if m_list != []:
                result += 'Class %s : [' % m_list[0].get_real_class()
                for spec in m_list:
                    result += '%s ' % spec.get_name()
                result += ']\n'

        return result

    def get_all_specs(self):
        return self.__spec_map

    ## return a spec object given the name of the spec.
    # None is returned if the name does not exist
    def get_spec_by_name(self, name):
        if self.__spec_map.has_key(name):
            return self.__spec_map[name]
        else:
            return None
                
    ## returns a list of spec's in that share the same machine class
    # None is returned if there is no such machine class
    def get_specs_by_class(self, mclass, subclass = None):
        if subclass != None and subclass != '':
            search_class = '%s,%s' % (mclass, subclass)
        else:
            search_class = mclass
            
        if self.__class_map.has_key(search_class):
            return self.__class_map[search_class]
        else:
            return None

    ## validate_specs_by_class
    # @param mclass model class
    # validate all specs within the model class for storage config
    # consistency. If any of them has a storage config,
    # they all have to have the same storage base storage config
    # it should not be possible to have models in the same class
    # that don't have the same set of profils associated with them
    def validate_specs_by_class(self, mclass):
        storage_config = None
        for spec in self.get_specs_by_class(mclass):
            if spec.has_storage_cfg():
                if storage_config == None:
                    storage_config = spec.get_storage_cfg().get_name()

                if storage_config != spec.get_storage_cfg.get_name():
                    raise AssertionError('%s model class is inconsistent' \
                                         ' with spec %s is invalid' % \
                                         (mclass, spec.get_name()))
            elif storage_config != None:
                raise AssertionError('%s storage config inconsistent' \
                                     ' with previous spec' % \
                                     spec.get_name())

    ## validate_all_specs
    # Validate all specs associated with the same class.  Specs 
    # within the same class should all have the same storage config
    def validate_all_specs(self):
        for class_key in self.__class_map.keys():
            self.validate_specs_by_class(class_key)

## DeviceList
# The Device list is an abstraction used when translating 
# configuration information into a set of devices used in the 
# creation of a Raid array or other logical construct
#
# It can be instantiated from either a set of zone information
# (zone_disk_array, array config)
# or (global_disk_array, LogicalVolumeConfig)
#
# The difference being that a zone volume is a definition for a group
# partitions for all disks in a zone, and the lvm is a definition for
# a collection of devices in the system referred to by zone/logical drive
#
class DeviceList:
    ## Init Method
    # @param spec System spec object for the current spec
    # @param lvm_context 2-tuple of:
    #             global_disk_array - Disk array for all managed system disks
    #             lvm - LogicalVolumeConfig object
    # @param zone_context 2-type of:
    #             zone_disk_array - Disk array for all disks in a zone
    #             array           - VolumeConfig array object describing 
    #                               the array on a partition in the zone
    #
    # @raise AssertionError Invalid configuration
    #
    # Only one of the lvm_context or zone_context should be specified
    def __init__(self,
                 spec,
                 lvm_context = None,
                 zone_context = None):
        self.__dev_list = []

        if lvm_context != None:
            global_disk_array = lvm_context[0]
            lvm               = lvm_context[1]
            self.__create_from_lvm(lvm, global_disk_array, spec)
        elif zone_context != None:
            zone_disk_array = zone_context[0]
            array = zone_context[1]
            self.__create_from_zone(zone_disk_array, array)
        else:
            raise AssertionError('Invalid Device List arguments')

    ## __create_from_zone
    # @param zone_disk_array DiskArray object containing the drives in the zone
    # @param array VolumeConfig object describing the array
    #
    # @raise AssertionError Invalid configuration
    # 
    # Internal method to create a device list from the zone
    def __create_from_zone(self,
                           zone_disk_array,
                           array):
        logical_port = 0
        for disk in zone_disk_array.get_drive_list():
            part = disk.part_tbl.find_partition_by_id(array.get_part_id())
            if part != None:
                lpart = LogicalPartition(part.part_id,
                                         part.size_mb,
                                         part.type,
                                         part.hd,
                                         part.name,
                                         part.fstype,
                                         logical_port)
                                     
                self.__dev_list.append(lpart)
            else:
                raise AssertionError('Invalid array %s partition %s in' \
                                     ' zone disk array' % \
                                     (array.get_name(),
                                      array.get_part_id()))
            logical_port += 1

    ## __create_from_lvm
    # @param lvm LogicalVolumeConfig object
    # @param global_disk_array DiskArray object for all system disks
    # @param spec Spec object describing the current system spec
    #
    # @raise AssertionError Invalid configuration
    #
    # Internal method to create a device list from a lvm/spec
    def __create_from_lvm(self,
                          lvm,
                          global_disk_array,
                          spec):
        logical_port = 0
        for dev_cfg in lvm.get_device_list():
            zname    = dev_cfg.get_zone()
            ldisk    = dev_cfg.get_logical_disk()
            partname = dev_cfg.get_part_name()
            zone     = spec.get_zone_spec_by_name(zname)
            phys_disk_id = spec.get_pdrive_from_zone_logical(zname,
                                                             ldisk)
            # now look up the physical disk and we can make the 
            # partition
            vol = spec.get_zone_volume(zname, partname)
            hd  = global_disk_array.find_drive_by_id(phys_disk_id)
        
            part = hd.part_tbl.find_partition_by_name(partname)
            if part == None:
                raise AssertionError('Invalid lvm partition %s:%s' % \
                                     (lvm.get_name(), 
                                      partname))
            lpart = LogicalPartition(part.part_id,
                                     part.size_mb,
                                     part.type,
                                     part.hd,
                                     part.name,
                                     part.fstype,
                                     logical_port)
                                     
            self.__dev_list.append(lpart)
            logical_port += 1

    def __str__(self):
        result = ''
        for dev in self.__dev_list:
            result += 'devlist/%d/devname=%s\n' % (dev.hd.portnum,
                                                   dev.get_devname())
            result += 'devlist/%d/partnum=%s\n' % (dev.hd.portnum,
                                                   dev.part_id)

        return result

    ## get_devices
    # Returns the list of partition object associated with this list
    def get_devices(self):
        return self.__dev_list

    ## get_expected_drives
    # Returns the number of drives for this list based on the configuration
    def get_expected_drives(self):
        return len(self.__dev_list)

    ## is_disk_in_devlist
    # @param drive int drive portnum
    # Returns True if the drive number is in the list, False otherwise
    def is_disk_in_devlist(self,
                           drive):
        for dev in self.__dev_list:
            if drive == dev.hd.portnum:
                return True

        return False

    ## find_devices_on_disk
    # @param disk int portnum of a disk in the system
    # Scan the device list and return all device entries
    # residing on the given system disk
    def find_devices_on_disk(self,
                             drive):
        result = []
        for dev in self.__dev_list:
            if drive == dev.hd.portnum:
                result.append(dev)

        return result

#### Storage Profile/Logical Volume Definitions ########################

## MetadataConfig
# Class to wrap configuration values for specific models/profiles
# Today these are set up more like MFDB nodes, though it could
# be extended later
class MetadataConfig:
    md_cfg_mfdb        = 'mfdb'
    supported_cfg_types= [ md_cfg_mfdb ]
    ## Init Method
    # @param name string description of the config
    # @param type string type of the config node
    # @param value string value of the config node
    # @param node  string path for the config node
    # @param config_type string type of config (e.g. mfdb)
    #
    # for example segstore_size /rbt/mfd/store/size uint32 100000
    def __init__(self, 
                 name,
                 type,
                 value,
                 node,
                 config_type):
        self.__name     = name
        self.__type     = type
        self.__value    = value
        self.__node     = node
        self.__config_type = config_type

        if self.__name in [ None, '' ]:
            raise AssertionError('Missing name in metadata node')
    
        # Value can be an empty string, but needs to be specified
        # the rest require an entry and a value
        if self.__type in [ '', None ] or \
            self.__value in [ None ] or \
            self.__node in [ '', None ]:
            raise AssertionError('Invalid paramter for metadata %s' % \
                                 self.__name)

        if self.__type != "string" and self.__value == "":
            raise AssertionError('Non string type metadata %s requires a non-blank value' % \
                                 self.__node)

        if self.__config_type not in self.supported_cfg_types:
            raise AssertionError('Invalid config type for metadata %s:%s' % \
                                  (self.__name, self.__config_type))

    ## String method 
    # display as the metadata as key value pairs
    def __str__(self):
        result = 'metadata/%s/type=%s\n' % (self.__name,
                                            self.__type) 
        result += 'metadata/%s/value=%s\n' % (self.__name,
                                              self.__value)
        result += 'metadata/%s/node=%s\n' % (self.__name,
                                             self.__node)
        return result

    #### External Methods #####################################################
    def get_name(self):
        return self.__name
    
    def get_type(self):
        return self.__type

    def get_value(self):
        return self.__value

    def get_node(self):
        return self.__node

    def get_cfg_type(self):
        return self.__config_type

## MetadataXmlConfig
# Subclass of MetadataConfig for managing config elements that are
# specified in XML
class MetadataXmlConfig(MetadataConfig):
    ## Init Method
    # @param xml xml.dom.minidom node for <node > in specs.xml
    def __init__(self,
                 xml):
        name  = xml.getAttribute('name')
        type  = xml.getAttribute('type')
        value = xml.getAttribute('value')
        node  = xml.getAttribute('node')
        config_type = xml.getAttribute('config_type')
        MetadataConfig.__init__(self, 
                                name, 
                                type, 
                                value,
                                node,
                                config_type)

## ProfileMetadataConfig
# Object to manage metadata associated with a storage profile
class ProfileMetadataConfig:
    # Init Method
    # @param xml xml.dom.minidom node for the <metadata node in specs.xml
    def __init__(self, 
                 xml):

        # dictionary of metadata indexed by name
        self.__metadata_map = {}

        for node in xml.getElementsByTagName('node'):
            metacfg = MetadataXmlConfig(node)
            self.__metadata_map[metacfg.get_name()] = metacfg
        
    def __str__(self):
        result = ''
        for metadata in self.__metadata_map.values():
            result += str(metadata)
        return result
    
    ## get_metadata_keys
    # Return the set of metadata names associated with the profile
    def get_metadata_keys(self):
        return self.__metadata_map.keys()
    
    ## get_metadata_by_name
    # @param name string name identifier for a metadata object
    def get_metadata_by_name(self, name):
        if self.__metadata_map.has_key(name):
            return self.__metadata_map[name]
        else:
            return None

    ## get_metadata
    # Return a list of MetadataConfig objects
    def get_metadata(self):
        return self.__metadata_map.values()
        
## DeviceConfig class
# The device config class abstracts a member of a logical volume
# the members are defined by a particular zone, logical disk within
# the zone and the name of a partition.  The names of partitions
# are defined in the zone config layout of the given spec disk 
# layout
class DeviceConfig:
    ## Init Method
    # @param xml xml.dom.minidom node element for a <device in specs.xml
    #
    def __init__(self,
                 xml):
        self.__zone      = xml.getAttribute('zone')
        self.__log_disk  = xml.getAttribute('disk')
        self.__part_name = xml.getAttribute('part')
        
        self.__validate()

    ## __validate
    # Perform consistency checks on the configuration of the device
    # Validation of the correctness of the entry is performed later
    # as the system spec object is required to resolve
    # device names to physical partitions
    def __validate(self):
        if self.__zone in [ None, '' ] or \
           self.__log_disk in [ None, '' ] or \
           self.__part_name in [ None, '' ]:
            raise AssertionError('Invalid device node (%s,%s,%s)' % \
                                 (self.__zone, 
                                  self.__log_disk,
                                  self.__part_name))
        try:
            test = int(self.__log_disk)
        except ValueError:
            raise AssertionError('Invalid device node logical disk (%s,%s,%s)' % \
                                 (self.__zone, 
                                  self.__log_disk,
                                  self.__part_name))

    def __str__(self):
        prefix = 'device'
        result = ''
        result += 'zone=%s\n' % self.__zone
        result += 'logical_disk=%s\n' % self.__log_disk
        result += 'part_name=%s\n' % self.__part_name
        return result

    #### External Methods
    ## get_zone
    # Returns the zone associated with the device
    def get_zone(self):
        return self.__zone

    ## get_logical_disk
    # Returns the logical drive for the device within the associated zone
    def get_logical_disk(self):
        return self.__log_disk

    ## get_part_name
    # Returns the partition name associated with the device within the zone
    def get_part_name(self):
        return self.__part_name

## LogicalVolumeFormatMethod
# The LogicalVolumeFormatMethod class describes a given initialization method
# for a Logical Volume.  Each method has a method name, and a set of options 
# associated with the method.  This class is a virtual class,
# and meant to be subclassed by a particular format method.
class LogicalVolumeFormatMethod:
    ## Init method
    # @param xml format_method xml tag for a logical volume
    def __init__(self,
                 xml):
        self.__method_name = xml.getAttribute('method')
        self.__options     = {}
        options_list = xml.getAttribute('options')
        if options_list != '' and options_list != None:
            options = options_list.split(',')
            for opt in options:
                parts = opt.split('=')
                if len(parts) != 2:
                    raise AssertionError('Invalid Format Method Params [%s]' % options_list)
                self.__options[parts[0]] = parts[1]

    def __str__(self):
        result = ''
        result += 'format_method/%s/method=%s\n' % (self.get_method_name(), 
                                                    self.get_method_name())
        for opt in self.__options.keys():
            result += 'format_method/%s/option/%s=%s\n' % (self.get_method_name(),
                                                           opt,
                                                           self.get_option(opt))
        return result

    ## get_option_str
    # return a comma seperated string of the options associated with 
    # this format method
    def get_option_str(self):
        result = ''
        for key in self.__options.keys():
            result += '%s=%s,' % (key, self.__options[key])
        return result

    ## get_method_name
    # returns the name of the method
    def get_method_name(self):
        return self.__method_name

    ## get_option
    # @param key option parameter key within the format_method option list
    # Returns the value of a given format method option or None,
    # if the key does not exist
    def get_option(self,
                   key):
        if self.__options.has_key(key):
            return self.__options[key]
        else:
            return None

    ## do_format
    # @param devname Name of the device to format
    # @raise OSError when the device does not exist
    #
    # Does basic common checks needed before a subclass can perform the format
    # of the device
    def do_format(self,
                  devname):
        if not exists(devname):
            raise OSError(errno.ENOENT, "device %s does not exist" % devname)

## Ext3FormatMethod
# Format method used to make an EXT3 filesystem on a device
# 
# node options are:
# option : parameters passed to mke2fs -O <option>
# cmdline opts : additional params passed to mke2fs such as -j -q
# label : label parameter passed to -L
# i.e. mke2fs [-O <option>] <cmdline opts> -L <label>
#
# Today a label is required
#
class ExtFormatMethod(LogicalVolumeFormatMethod):
    ext3_name = 'ext3'
    ext4_name = 'ext4'
    supported_fs_list = [ ext3_name, 
                          ext4_name ]
    def __init__(self,
                 fstype,
                 xml):
        if fstype not in self.supported_fs_list:
            raise AssertionError('Invalid LVM fstype [%s] for ExtFormatMethod' % fstype)

        self.fstype = fstype

        LogicalVolumeFormatMethod.__init__(self, xml)
        # perform validation checks on the options
        self.__validate_options()

    ## __validate_options
    # Perform range checking and validation of the required options
    # for this FormatMethod
    #
    def __validate_options(self):
        # ensure that required options are present
        label_str = self.get_option('label')
        if label_str == None or label_str == '':
            raise AssertionError('Invalid label [%s] for FormatMethod' % count_str)
        
    ## __make_cmdline
    # @param devname the device name to be initialized
    # Generate a RawFormatMethod command line (basically dd) based on the options
    # and devname
    def get_cmdline(self,
                     devname):
        cmdline = "/sbin/mke2fs"
        
        cmdline += ' -t %s' % (self.fstype)
        if self.get_option('option') not in [ '', None ]:
            cmdline += ' -O %s' % self.get_option('option')

        cmd_opts = self.get_option('cmdlineopts')
        if cmd_opts not in [ None, '' ]:
            cmdline += ' %s' % cmd_opts

        if self.get_option('label') not in [ None, '' ]:
            cmdline += ' -L %s' % self.get_option('label')

        cmdline += ' %s' % devname

        return cmdline

    ## do_format
    # @param devname Device name to be initialized
    # @raise rrdm_error on failure to format the device
    #
    # Format the given device name for RAW use
    def do_format(self,
                  devname,
                  verbose = False):
        LogicalVolumeFormatMethod.do_format(self, devname)
        cmdline = self.get_cmdline(devname)
        if verbose:
            print 'executing format command : [%s]' % cmdline
            rlog_notice('executing format command: [%s]' % cmdline)
        run_shell_cmd(cmdline)

## Ext4FormatMethod
# Format method used to make an EXT4 filesystem on a device
# 
# node options are:
# option : parameters passed to mke2fs -O <option>
# cmdline opts : additional params passed to mke2fs such as -t ext4
# label : label parameter passed to -L
# i.e. mke2fs [-O <option>] <cmdline opts> -L <label>
#
# Today a label is required
#
class Ext4FormatMethod(LogicalVolumeFormatMethod):
    def __init__(self,
                 fstype,
                 xml):
        if fstype != 'ext4':
            raise AssertionError('Invalid LVM fstype [%s] for Ext4FormatMethod' % fstype)

        LogicalVolumeFormatMethod.__init__(self, xml)
        # perform validation checks on the options
        self.__validate_options()

    ## __validate_options
    # Perform range checking and validation of the required options
    # for this FormatMethod
    #
    def __validate_options(self):
        # ensure that required options are present
        label_str = self.get_option('label')
        if label_str == None or label_str == '':
            raise AssertionError('Invalid label [%s] for FormatMethod' % label_str)
        
    ## __make_cmdline
    # @param devname the device name to be initialized
    # Generate a RawFormatMethod command line (basically dd) based on the options
    # and devname
    def get_cmdline(self,
                     devname):
        cmdline = "/sbin/mke2fs"
        if self.get_option('option') != '':
            cmdline += ' -O %s' % self.get_option('option')

        cmd_opts = self.get_option('cmdlineopts')
        if cmd_opts not in [ None, '' ]:
            cmdline += ' %s ' % cmd_opts

        if self.get_option('label') not in [ None, '' ]:
            cmdline += ' -L %s' % self.get_option('label')

        cmdline += ' %s' % devname

        return cmdline

    ## do_format
    # @param devname Device name to be initialized
    # @raise rrdm_error on failure to format the device
    #
    # Format the given device name for RAW use
    def do_format(self,
                  devname,
                  verbose = False):
        LogicalVolumeFormatMethod.do_format(self, devname)
        cmdline = self.get_cmdline(devname)
        if verbose:
            print 'executing format command : [%s]' % cmdline
            rlog_notice('executing format command: [%s]' % cmdline)
        run_shell_cmd(cmdline)


## RawFormatMethod
# Generic format method used to zero data on a device
# supported dd parameters are
#     bsize=<value> which corresponds to the dd bs= parameter
#     count=<value> which corresponds to the dd count= parameter
class RawFormatMethod(LogicalVolumeFormatMethod):
    def __init__(self,
                 fstype,
                 xml):
        if fstype != 'none':
            raise AssertionError('Invalid LVM fstype [%s] for RawFormatMethod' % fstype)

        LogicalVolumeFormatMethod.__init__(self, xml)
        # perform validation checks on the options
        self.__validate_options()

    ## __validate_options
    # Perform range checking and validation of the required options
    # for this FormatMethod
    def __validate_options(self):
        # ensure that required options are present
        bsize = self.get_option('bsize')
        if bsize == '' or bsize == None:
            raise AssertionError('Invalid bsize [%s] for FormatMethod' % bsize)

        count_str = self.get_option('count')
        if count_str == None or count_str == '':
            raise AssertionError('Invalid count [%s] for FormatMethod' % count_str)
        try:
            count_int = int(count_str)
        except ValueError:
            raise AssertionError('Count [%s] is not a valid integer for' \
                                 ' FormatMethod' % count_str)
        
    ## __make_cmdline
    # @param devname the device name to be initialized
    # Generate a RawFormatMethod command line (basically dd) based on the options
    # and devname
    def get_cmdline(self,
                     devname):
        src_devname = "/dev/zero"
        cmdline = "/bin/dd if=%s of=%s bs=%s count=%s" % \
                    (src_devname,
                     devname,
                     self.get_option('bsize'),
                     self.get_option('count'))
        return cmdline

    ## do_format
    # @param devname Device name to be initialized
    # @raise rrdm_error on failure to format the device
    #
    # Format the given device name for RAW use
    def do_format(self,
                  devname,
                  verbose = False):
        LogicalVolumeFormatMethod.do_format(self, devname)
        cmdline = self.get_cmdline(devname)
        if verbose:
            print 'executing format command : [%s]' % cmdline
            rlog_notice('executing format command: [%s]' % cmdline)
        run_shell_cmd(cmdline)

## FormatMethodFactory
# Class for taking inputs from a Logical Volume specification and 
# creating a particular instance of a LogicalVolumeFormatMethod object
class FormatMethodFactory:
    # raw method is basically a wrapper around dd of /dev/zero
    raw_method = 'raw'
    ext3_method = 'ext3'
    ext4_method = 'ext4'

    # list of supported methods
    supported_methods = [ raw_method,
                          ext3_method,
                          ext4_method ]
    def __init__(self):
        pass

    ## create_format_method
    # @param fstype Filesystem type string
    # @param xml format_method xml node
    # Given parameters from a Logical Volume config, create a 
    # LogicalVolumeFormatMethod instance according to the config
    # 
    # Today only raw methods are supported, see RawFormatMethod 
    # for details
    def create_format_method(self,
                             fstype,
                             xml):
        method = xml.getAttribute('method')
        if method not in self.supported_methods:
            raise AssertionError('Invalid format method type %s' % method)

        if method == self.raw_method:
            return RawFormatMethod(fstype, xml)
        elif method in [ self.ext3_method,
                         self.ext4_method ]:
            return ExtFormatMethod(fstype, xml)
        elif method == self.ext4_method:
            return Ext4FormatMethod(fstype, xml)
        else:
            raise AssertionError('No format method associated with %s' % method)

class SysfsXmlConfig:

    def __init__(self,
                 xml):
	self.type = ''
	self.path = ''
	self.value = '' 
        self.__parse_xml(xml)

    def __parse_xml(self, xml):
        self.type = xml.getAttribute('type')
        self.path = xml.getAttribute('path')
        self.value = xml.getAttribute('value')


## LogicalVolumeAttributeMap
# Class that wraps nodes in spec.xml under a logical volume xml tag
# representing arbitrary metadata associated with an LVM in key/value form.
# 
class LogicalVolumeAttributeMap(dict):
    attr_xml_tag = 'attribute'
    name_xml_tag = 'name'
    val_xml_tag  = 'value'

    ## Init method
    # @param root_xml logical volume xml entry
    def __init__(self,
                 root_xml):
        dict.__init__(self)
        self.__parse_xml(root_xml)

    ## Stringify
    # Turn the attribute map into a string of key=value pairs
    def __str__(self):
        result = ''
        for key in self.keys():
            result += '%s=%s\n' % (key, self[key])

        return result

    ## __parse_xml
    # @param root_xml logical volume xml entry
    # Reads the xml entries in and stores in the dictionary
    def __parse_xml(self,
                    root_xml):
        for lvm_xml_attr in root_xml.getElementsByTagName(self.attr_xml_tag):
            name = lvm_xml_attr.getAttribute(self.name_xml_tag)
            val  = lvm_xml_attr.getAttribute(self.val_xml_tag)
            self[name] = val

## LogicalVolumeConfig
# A logical volume is a mechanism for specifying an array, or ftraid volume
# within the system. The primary difference with this mechanism and the old
# mechanism is that logical volumes defined here can span zones, and reside
# on different partitions on different disks within the system
class LogicalVolumeConfig:

    # defines for LVM attributes
    usable_size_mb_key = 'usable_size_mb'

    # Defines for acceptable types for a logical volume
    raid10_type = 'raid10'
    raid5_type  = 'raid5'
    raid6_type  = 'raid6'
    raidlinear_type = 'linear'
    ftraid_type = 'ftraid'
    # A direct type is a logical volume represented by a single disk partition
    direct_type = 'direct'

    # list of supported type fields
    supported_types = [ raid10_type, 
                        raid5_type, 
                        raid6_type, 
                        raidlinear_type, 
                        direct_type,
                        ftraid_type ] 
    # list of MD raid types (these require specific config elements)
    raid_types = [ raid10_type, 
                   raid6_type, 
                   raid5_type, 
                   raidlinear_type ] 
    
    ## Init Method
    # @param xml xml.dom.minidom node corresponding to a <volume in specs.xml
    # @raise AssertionError on Invalid configuration
    def __init__(self,
                 xml):

        self.__name         = xml.getAttribute('name')
        self.__type         = xml.getAttribute('type')
        self.__chunk        = xml.getAttribute('chunk')
        self.__ptype        = xml.getAttribute('ptype')
        self.__fstype       = xml.getAttribute('fstype')
        self.__devname      = xml.getAttribute('devname')
        self.__layout_opts  = xml.getAttribute('layout')
        self.__mount        = xml.getAttribute('mount')
        
        # populate a list of extended attributes
        self.__lvm_attr_map = LogicalVolumeAttributeMap(xml)
        self.__mount_opts   = xml.getAttribute('mount_opts')
        self.__device_list  = []
        self.__format_method = None
	self.__sysfscfg_list = []

        # size is late binding info, as in the LVM spec today
        # we refer to devices contained within a zone, which
        # is only known when we associate a volume to a spec
        # the value is set from the spec processing logic
        # in the system object
        self.__size_mb      = 0

        self.__setup_format_method(xml)

        for device in xml.getElementsByTagName('device'):
            self.__device_list.append(DeviceConfig(device))

        self.__num_devices = len(self.__device_list)
	
	self.__setup_sysfs_param(xml)

        self.__validate()

    def __str__(self):
        prefix = 'lvolume'
        result = ''
        result += '%s/%s/type=%s\n' % (prefix, self.__name, self.__type) 
        result += '%s/%s/chunk=%s\n' % (prefix, self.__name, self.__chunk) 
        result += '%s/%s/ptype=%s\n' % (prefix, self.__name, self.__ptype) 
        result += '%s/%s/fstype=%s\n' % (prefix, self.__name, self.__fstype) 
        result += '%s/%s/devname=%s\n' % (prefix, self.__name, self.__devname) 
        result += '%s/%s/mount=%s\n' % (prefix, self.__name, str(self.__mount)) 
        result += '%s/%s/layout_opts=%s\n' % (prefix, self.__name, 
                                              self.__layout_opts) 

        for key in self.__lvm_attr_map.keys():
            result += '%s/%s/attribute/%s=%s\n' % (prefix,
                                                   self.__name,
                                                   key,
                                                   self.__lvm_attr_map[key])
        count = 0
        for device in self.__device_list:
            result += '%s/%s/device/%d/zone=%s\n' % (prefix, self.__name, 
                                                     count, device.get_zone())
            result += '%s/%s/device/%d/ldisk=%s\n' % (prefix, 
                                                      self.__name, 
                                                      count, 
                                                      device.get_logical_disk())
            result += '%s/%s/device/%d/pname=%s\n' % (prefix, self.__name, 
                                                      count, 
                                                      device.get_part_name())
            count += 1
        return result

    ## __setup_format_method
    # @param xml Logical Volume xml tag entry in specs.xml
    # @raise AssertionError on Invalid format method config
    #
    # Parse the sub nodes of the volume config entry, and if we 
    # find a format method, create the appropriate format method object 
    def __setup_format_method(self, 
                              xml):
        # handle logical volume format methods
        lv_fmt_xml = xml.getElementsByTagName('format_method')
        if lv_fmt_xml != None and lv_fmt_xml != []:
            if len(lv_fmt_xml) > 1:
                raise AssertionError('Unsupported number of format methods' \
                                     ' for LV [%s]' % self.__name())
            else:
                self.__format_method = FormatMethodFactory(). \
                                        create_format_method(self.__fstype,
                                                             lv_fmt_xml[0])

    def __setup_sysfs_param(self,
                              xml):
	# set any sysfs params as necessary
	spattrnodes = xml.getElementsByTagName('sys_param')
        for spnode in spattrnodes:
            syscfg = SysfsXmlConfig(spnode)
            self.__sysfscfg_list.append(syscfg)

    ## __validate
    # Perform consistency checks on the config values, ensuring that
    # the xml data has valid data
    def __validate(self):
        if self.__name == None or self.__name == '':
            raise AssertionError('Invalid logical volume name')

        if self.__type not in self.supported_types:
            raise AssertionError('Invalid raid type for logical volume %s' % \
                                 self.__name)

        if self.__type == self.direct_type:
            if len(self.__device_list) != 1:
                raise AssertionError('Invalid direct volume %s, only one' \
                                     ' device is allowed' % \
                                     (self.__name))
            if self.__devname not in [ None, '' ]:
                raise AssertionError('Invalid direct device node  %s name %s' % \
                                     (self.__name, self.__devname))

        if self.__type in self.raid_types:
            # raid types require a devname and chunk size
            try:
                if self.__chunk == None or int(self.__chunk) <= 0:
                    raise AssertionError('Invalid raid chunk size' \
                                         ' for logical volume %s' % \
                                         self.__name)
            except ValueError:
                    raise AssertionError('Invalid raid chunk size' \
                                         ' for logical volume %s' % \
                                         self.__name)

            if self.__devname == None or self.__devname == '':
                raise AssertionError('Invalid raid device name for logical' \
                                     ' volume %s' % \
                                     self.__name)
            if self.__type == self.raid5_type:
                if self.__num_devices < 3:
                    raise AssertionError('Raid5 types require at least 3' \
                                         ' devices %d specified' % \
                                         self.__num_devices)
            if self.__type == self.raid6_type:
                if self.__num_devices < 4:
                    raise AssertionError('Raid6 types require at least 4' \
                                         ' devices %d specified' % \
                                         self.__num_devices)
            if self.__type == self.raid10_type:
                if self.__num_devices % 2 != 0:
                    raise AssertionError('Raid10 types require an even number' \
                                         ' of devicess, %d specified' % \
                                         self.__num_devices)
        else:
            # this is a non raid type, or ftraid type it 
            # shouldn't have raid options
            if self.__devname != None and self.__devname != '':
                raise AssertionError('Invalid device name for logical' \
                                     ' volume %s' % \
                                     self.__name)
                if self.__chunk != None and self.__chunk != '':
                    raise AssertionError('Invalid chunk size for logical' \
                                         ' volume %s' % \
                                         self.__name)

    ## get_usable_size_mb
    # Given an LVM check to see if it has an explicitly configured
    # attribute defining its usable size.  If it does not then
    # return the total size of the LVM.
    # 
    # @return integer usablee size of the LVM in MB
    def get_usable_size_mb(self):
        result = 0
        if self.__lvm_attr_map.has_key(self.usable_size_mb_key):
            result = int(self.__lvm_attr_map[self.usable_size_mb_key])
        else:
            result = self.get_size_mb()

        if result > self.get_size_mb():
            raise AssertionError('LVM %s usable size is > max size [%d:%d]' % \
                                 (self.get_name(),
                                  result, 
                                  self.get_size_mb()))

        return result

    ## __compute_raid10_size
    # @param num_disks int number of disks in the volume
    # @param psize int usable size of the partition
    def __compute_raid10_size(self,
                              num_disks,
                              psize):
        return psize * (num_disks / 2)

    ## __compute_raid5_size
    # @param num_disks int number of disks in the volume
    # @param psize int usable size of the partition
    def __compute_raid5_size(self,
                             num_disks,
                             psize):
        return psize * (num_disks - 1)

    ## __compute_raid6_size
    # @param num_disks int number of disks in the volume
    # @param psize int usable size of the partition
    def __compute_raid6_size(self,
                             num_disks,
                             psize):
        return psize * (num_disks - 2)

    ## __compute_ftraid_size
    # @param num_disks int number of disks in the volume
    # @param psize int size of the ftraid partition
    # Note that at the moment, sport's usable disk size
    # is less than this value and also, if the partitions
    # are uneven in size, the smallest one is used
    def __compute_ftraid_size(self,
                              num_disks,
                              psize):
        return psize*num_disks

    ## __get_volume_in_zone
    # @param devcfg DeviceConfig object
    # @param zone_map DiskZoneSpec object
    # 
    # Given a device config object and a zone return the VolumeConfig
    # object associated with the partition name
    def __get_volume_in_zone(self,
                             devcfg,
                             zone_map):
        zone = zone_map[devcfg.get_zone()]
        layout = zone.get_layout()
        return layout.get_volume_by_name(devcfg.get_part_name())

    #### External Methods ##################################################

    ## has_format_method
    # Returns True if the logical volume has an associated format method
    # or False otherwise
    def has_format_method(self):
        return self.__format_method != None

    ## get_format_method
    # Returns the format method associated with this logical volume, or 
    # None if there is no method associated with this volume
    def get_format_method(self):
        return self.__format_method

    ## get_size_mb
    # Return the size of the LVM in MB.  Note that this is only populated
    # after the LVM has been associated with a given spec/zone_map
    def get_size_mb(self):
        return self.__size_mb

    def __get_volume_in_zone(self,
                             devcfg,
                             zone_map):
        zone = zone_map[devcfg.get_zone()]
        layout = zone.get_layout()
        return layout.get_volume_by_name(devcfg.get_part_name())

    ## validate_lvm_by_zones
    # @param zone_map Dictionary mapping zones for a given disk config
    # 1) Checks the LVM devices for consistency with the given zone_map
    # 2) Checks the lvm to ensure that disk capacity requirements are met
    # for lvm types that require similar sized disks
    def validate_lvm_by_zones(self,
                              spec_disk_config,
                              scfg_name):
        
        disk_zones = spec_disk_config.get_zone_map()

        # check a volume definition against the spec definition
        # to ensure that all names are valid and able to be resolved
        # to a given device in the config.
        rlog_debug('-- Checking volume %s consistency for disk cfg %s:%s' % \
                   (self.get_name(),
                    scfg_name,
                    spec_disk_config.get_name()))
        for device in self.get_device_list():
            # we need to look up the storage config associated with this
            # profile

            # check the device params against our config
            if not disk_zones.has_key(device.get_zone()):
                raise AssertionError('Storage Config %s volume %s has' \
                                     ' invalid zone name %s' % \
                                     (scfg_name,
                                      self.get_name(),
                                      device.get_zone()))

            zone = disk_zones[device.get_zone()]

            if not int(device.get_logical_disk()) < zone.get_disk_count():
                raise AssertionError('Storage Config %s volume %s has' \
                                     ' invalid device zone %s' \
                                     ' logical disk %s' % \
                                     (scfg_name,
                                      self.get_name(),
                                      device.get_zone(),
                                      device.get_logical_disk()))

            if not zone.has_volume_by_name(device.get_part_name()):
                raise AssertionError('Storage Config %s volume %s has' \
                                     ' invalid device zone %s' \
                                     ' partition name %s' % \
                                     (scfg_name,
                                      self.get_name(),
                                      device.get_zone(),
                                      device.get_part_name()))

        # For RAID /FtRaid types we need to ensure that
        # the configured devices are all the same size     
        if self.__type in [ self.raid5_type, 
                            self.raid6_type,
                            self.raid10_type,
                            self.ftraid_type ]:
            psize = None
            for devcfg in self.get_device_list():
                if psize == None:
                    psize = self.__get_volume_in_zone(devcfg, disk_zones). \
                                get_cfg_size()
                else:
                    nsize = self.__get_volume_in_zone(devcfg, disk_zones). \
                                get_cfg_size()
                    if nsize != psize:
                        raise AssertionError('Storage Config %s invalid raid' \
                                             ' configuration for lvm %s' % \
                                              (scfg_name, self.get_name()))
                
        

    ## update_lvm_by_zones
    # @param zone_map Dictionary mapping zones for a given spec
    #             to their DiskZoneSpec objects
    #
    # Perform late binding updates for the LVM once we have specific
    # zone_map definitions for the current spec
    def update_lvm_by_zones(self,
                            zone_map):
        # we need to determine the size of the LVM by its type
        # and the size of the member devices within the zones
        if self.__type == self.direct_type:
            devcfg = self.get_device_list()[0]
            psize = self.__get_volume_in_zone(devcfg, zone_map). \
                        get_cfg_size()
            self.__size_mb = psize
            
        elif self.__type == self.raidlinear_type:
            # linear is handled as a special raid case, as for
            # disk concat we can have arbitrarily sized
            # partitions. For other raid levels,
            # the partitions have to be roughly the same size
            # for MD to not complain. (about 1% diff is acceptable to MD)
            # which should be well within cylinder rounding on partitioning.
            for devcfg in self.get_device_list():
                # validation on zone presence has already been done
                # so we know we can look this up
                psize = self.__get_volume_in_zone(devcfg, zone_map). \
                            get_cfg_size()
                self.__size_mb += psize
                
        elif self.__type in self.raid10_type:
            # we already require the partitions to be configured
            # for the same size, so we simply take the first device size and
            # use that, no error checking needed as the config
            # was already validated
            devcfg = self.get_device_list()[0]
            psize = self.__get_volume_in_zone(devcfg, zone_map). \
                        get_cfg_size()
            self.__size_mb = self.__compute_raid10_size(self.__num_devices, 
                                                        psize)

        elif self.__type in self.raid5_type:
            devcfg = self.get_device_list()[0]
            psize = self.__get_volume_in_zone(devcfg, zone_map). \
                get_cfg_size()
            self.__size_mb = self.__compute_raid5_size(self.__num_devices,
                                                       psize)

        elif self.__type in self.raid6_type:
            devcfg = self.get_device_list()[0]
            psize = self.__get_volume_in_zone(devcfg, zone_map). \
                get_cfg_size()
            self.__size_mb = self.__compute_raid6_size(self.__num_devices,
                                                       psize)

        elif self.__type in self.ftraid_type:
            # the number of devices has already been verified so we can assume
            # there is at least one device, and the size of the ftraid device
            # is the number of devices * size of the partition on any device
            psize = self.__get_volume_in_zone(self.get_device_list()[0], 
                                              zone_map).get_cfg_size()
            self.__size_mb = self.__compute_ftraid_size(self.__num_devices,
                                                         psize)
        else:
            raise AssertionError('Invalid LVM %s type %s in zone update' % \
                                 (self.__name, self.__type))

    ## get_name
    # Return the name of this logical volume
    def get_name(self):
        return self.__name
 
    ## get_chunk
    # for RAID types, return the chunk size of the LVM.  For non-raid
    # types the chunk size shall be ''
    def get_chunk(self):
        return self.__chunk
    
    ## get_ptype
    # get the partition type associated with this LVM.  For non-direct volumes
    # this should be ''
    def get_ptype(self):
        return self.__ptype

    ## get_device_list
    # Return the list of DeviceConfig objects associated with this LVM
    def get_device_list(self):
        return self.__device_list

    ## get_type
    # Return the type of this LVM (see header above for types)
    def get_type(self):
        return self.__type

    ## get_layout
    # for MD Raid arrays additional layout options can be specified
    # in the config to change the way MD configures a raid array
    def get_layout(self):
        return self.__layout_opts

    ## get_devname
    # Return the device name associated with this LVM, for MD arrays this 
    # shall be mdX, etc.  For Ftraid arrays, this will be '', as those
    # have no aggregate logical device
    def get_devname(self):
        return self.__devname

    ## get_mount
    # Return the mount point associated with this LVM, or None if there 
    # mount point is not specified
    def get_mount(self):
        return self.__mount

    ## get_mount_opts
    # Return the mount options associated with this LVM, or None if there 
    # mount point is not specified
    def get_mount_opts(self):
        return self.__mount_opts

    ## get_fstype
    # Returns the fstype associated with the LVM
    def get_fstype(self):
        return self.__fstype

    def get_sysfscfg_list(self):
	return self.__sysfscfg_list

    def is_raid(self):
        return self.__type in self.raid_types

    def is_direct(self):
        return self.__type == self.direct_type

    def is_ftraid(self):
        return self.__type == self.ftraid_type

## LogicalVolumeConfigMap
# This class wraps a set of Logical Volumes associated with a profile/
# storage config
class LogicalVolumeConfigMap:
    ## Init Method
    # @param xml xml.dom.minidom node for <logical_volumes specs.xml entry
    def __init__(self,
                 xml):
        self.__lvm_map = {}

        for node in xml.getElementsByTagName('volume'):
            lvmcfg  = LogicalVolumeConfig(node)
            lvmname = lvmcfg.get_name() 

            if self.__lvm_map.has_key(lvmname):
                raise AssertionError('Duplicate logical volume name %s' % \
                                     lvmname)
                                     
            self.__lvm_map[lvmcfg.get_name()] = lvmcfg

    def __str__(self):
        result = ''
        for lvmcfg in self.__lvm_map.values():
            result += str(lvmcfg)
            result += '\n'
        return result

    #### External Methods #####################################################
    def has_volume_by_name(self, name):
        return self.__lvm_map.has_key(name)

    def get_volume_by_name(self, name):
        if self.has_volume_by_name(name):
            return self.__lvm_map[name]     
        else:
            return None

    def get_volumes(self):
        return self.__lvm_map.values()
        
## ProfileConfig
# A profile is a named container around a set of logical volumes
# profiles are also associated with metadata derived from the
# configuration described in the LVM section of the profile
class ProfileConfig:
    ## Init Method
    # @param xml xml.dom.minidom node for a <profile specs.xml entry
    def __init__(self,
                 xml):
        self.__name         = xml.getAttribute('name')
        self.__description  = xml.getAttribute('description')
        self.__featurekey   = xml.getAttribute('featurekey')
        
        lvm_nodes = xml.getElementsByTagName('logical_volumes')
        if lvm_nodes == None:
            raise AssertionError('Profile %s does not contain a logical' \
                                 ' volume tag' % self.__name)
        elif lvm_nodes == []:
            self.__lvmcfg_map = None
        else:
            # a profile should only have one set of logical volume
            # entries
            self.__lvmcfg_map = LogicalVolumeConfigMap(lvm_nodes[0])

        mnodes = xml.getElementsByTagName('metadata')
        if mnodes not in [ None, [] ]:
            # only one set of metadata supported
            self.__metadata   = ProfileMetadataConfig(mnodes[0])
        else:
            self.__metadata   = None

    def __str__(self):
        prefix = 'profile'
        result = ''
        result += '%s/%s/description=%s\n' % (prefix,
                                              self.get_name(),
                                              self.get_description())
        result += '%s/%s/featurekey=%s\n' % (prefix,
                                             self.get_name(),
                                             self.get_featurekey())
        for lvmcfg in self.__lvmcfg_map.get_volumes():
            for line in str(lvmcfg).strip().split('\n'):
                result += '%s/%s/%s\n' % (prefix, 
                                          self.__name, 
                                          line)

        if self.__metadata != None:
            for metacfg in self.__metadata.get_metadata():
                for line in str(metacfg).strip().split():
                    result += '%s/%s/%s\n' % (prefix, 
                                              self.__name,
                                              str(line))
        return result

    #### External Methods #####################################################
    def get_name(self):
        return self.__name
    
    def get_description(self):
        return self.__description

    def get_featurekey(self):
        return self.__featurekey

    def get_volumes(self):
        if self.__lvmcfg_map != None:
            return self.__lvmcfg_map.get_volumes()
        else:
            return []
    

    def get_metadata(self):
        return self.__metadata

    def has_volume_by_name(self, 
                           lvm_name):
        return self.__lvmcfg_map.has_volume_by_name(lvm_name)
        

## ProfileConfigMap
# A wrapper around a set of storage profiles associated with a given
# Spec
class ProfileConfigMap:
    ## Init Method
    # @param xml xml.dom.minidom node for a <profiles spec.xml node
    def __init__(self,
                 xml):
        profile_nodes = xml.getElementsByTagName('profile')
        
        if profile_nodes in [ None, [] ]:
            raise AssertionError('Profiles tag is missing profile elements')
        self.__profile_map = {}

        for pnode in profile_nodes:
            pcfg = ProfileConfig(pnode)
            if self.__profile_map.has_key(pcfg.get_name()):
                raise AssertionError('Duplicate profile entry %s' % \
                                     pnode.get_name())

            self.__profile_map[pcfg.get_name()] = pcfg

    def __str__(self): 
        result = ''
        for profile in self.__profile_map.values():
            result += str(profile)
        return result

    #### External Methods #####################################################
    def get_profiles(self):
        return self.__profile_map.values()

    def get_profile_names(self):
        return self.__profile_map.keys()

    def get_profile(self,
                    pname):
        if self.__profile_map.has_key(pname):
            return self.__profile_map[pname]
        else:
            return None

## StorageConfig
# A Storage config is a named set of possible storage configurations
# comprising a set of persistant volumes (these volumes are immutable to
# a profile change) and a set of possible profiles associated with the 
# storage configuration. 
#
# Some profiles may require a repartitioning of the disks, and as such
# they can be associated with different disk configurations in the spec class
class StorageConfig:
    ## Init Method
    # @param xml xml.dom.minidom xml node corresponding to a <storage_config
    #                            specs.xml entry
    # @param layout_map DiskLayoutMap object with all the common layout
    #                   definitions
    def __init__(self,
                 xml,
                 layout_map):
        self.__name             = xml.getAttribute('name')
        self.__persist_cfg_map  = None
        self.__profile_map      = None
        self.__disk_cfg_map     = None
        self.__layout_map       = layout_map

        persist_nodes = xml.getElementsByTagName('persist_volumes')
        if persist_nodes not in [ None, [] ]:
            # only one persistant_volume entry is expected
            self.__persist_cfg_map = LogicalVolumeConfigMap(persist_nodes[0])
        
        profile_nodes = xml.getElementsByTagName('profiles')
        if profile_nodes not in [ None, [] ]:
            # only one profiles tag is expected
            self.__profile_map = ProfileConfigMap(profile_nodes[0])

        # read in the disk info section, this describes the disk 
        # partition maps based on the storege config/profile
        self.__populate_disk_layouts(xml)

        self.__validate_storage_config()

    def __populate_disk_layouts(self,
                                xml):
        disk_layouts = xml.getElementsByTagName('disk_layout_profiles')
        if disk_layouts == []:
            raise AssertionError('Storage config %s requires' \
                                 ' disk_layout_profile nodes' % \
                                 self.get_name())

        if len(disk_layouts) > 1:
            raise AssertionError('Storage config %s only supports one' \
                                 ' disk_layout_profile node' % \
                                 self.get_name())
        
        self.__disk_cfg_map = SpecDiskConfigMap(layout_map = self.__layout_map,
                                                xml = disk_layouts[0],
                                                is_legacy = False)

    def __validate_storage_config(self):
        # after populating the disk layouts, we now can make sure
        # that all the profile and logical volume entries are logically.
        # a few cases need to be verified:
        # 1) persistant volumes need to have their device entries validated
        #    across all possible disk configurations (these are shared)
        #    
        # 2) all device entries in any profiles LVM need to have an appropriate
        #    disk config entry for the specified profile
        # 
        # 3) specific LVM objects can be verified by type
        #    Ftraid requires all partitions to be configured for the same size
        #    Similarly for non-linear raid arrays, etc
        rlog_debug('Checking storage config %s' % self.get_name())
        for pvolume in self.get_persist_volumes():
            # persist volumes are invariant across profiles
            # therefore we need to verify them against all possible
            # spec disk configs
            for spec_disk_cfg in self.get_disk_cfg_map(). \
                get_disk_configs():
                self.__validate_lvolume(pvolume, spec_disk_cfg)

        for sprofile in self.get_storage_profiles():
            spec_disk_cfg = self.get_disk_cfg_map(). \
                                get_disk_config(sprofile.get_name())
            if spec_disk_cfg == None:
                raise AssertionError('Spec:%s Storage profile %s does not' \
                                     ' have an associated disk config spec' % \
                                     (self.__name, sprofile.get_name()))

            for svolume in sprofile.get_volumes():
                self.__validate_lvolume(svolume, spec_disk_cfg)

    def __validate_lvolume(self,
                           pvolume,
                           spec_disk_config):
        disk_zones = spec_disk_config.get_zone_map()

        # Make sure the LVM config is consistent and valid
        pvolume.validate_lvm_by_zones(spec_disk_config, self.get_name())
   
        # configured size of the raid partition members, are appropriate
        # for the raid level.  We can also at this time fill
        # in the size of a logical volume
        pvolume.update_lvm_by_zones(disk_zones)

    def __str__(self):
        result = ''
        prefix = 'storageconfig'
        for line in str(self.__persist_cfg_map).strip().split('\n'):
            result += '%s/persist/%s/%s\n' % (prefix, self.__name, line)

        for line in str(self.__profile_map).strip().split('\n'):
            result += '%s/%s/%s\n' % (prefix, self.__name, line)

        return result

    #### External Methods #####################################################
    def get_name(self):
        return self.__name

    def get_persist_volumes(self):
        return self.__persist_cfg_map.get_volumes()

    def get_storage_profiles(self):
        if self.__profile_map != None:
            return self.__profile_map.get_profiles()
        else:
            return []

    def get_storage_profiles_names(self):
        if self.__profile_map != None:
            return self.__profile_map.get_profile_names()
        else:
            return []

    def get_profile_volumes(self,
                            profile_name):
        return self.get_profile(profile_name).get_volumes()

    def get_disk_cfg_map(self):
        return self.__disk_cfg_map

    def uses_sw_raid(self, profile):
        lvm_list = self.get_logical_volumes(profile)
        for lvm in lvm_list:
            if lvm.get_type() in LogicalVolumeConfig.raid_types:
                return True
        return False

    ## is_persist_volume
    # @param profile the name of the profile
    # @param lvm_name name of a logical volume
    # @raise AssertionError on invalid profile/lvm names
    # 
    # Returns True if the given LVM is a persistant
    # volume for a given StorageConfig/profile, or False 
    # if it is not.
    # 
    def is_persist_volume(self,
                          profile_name,
                          lvm_name):
        if self.__persist_cfg_map.has_volume_by_name(lvm_name):
            return True

        profile = self.__profile_map.get_profile(profile_name)
        if profile == None:
            raise AssertionError('Profile %d does not exist for' \
                                 ' StorageConfig %s' % self.__name)
        if profile.has_volume_by_name(lvm_name):
            return False

        raise AssertionError('Invalid lvm_name %s for profile %s' % \
                             (lvm_name, profile_name))

    ## get_logical_volumes
    # @param profile_name name of a given storage profile
    # Returns a list of LogicalVolumeConfig objects associated
    #    with a given storage profile.  Includes both
    #    persistant LVM's and ones associated with the profile
    def get_logical_volumes(self, 
                            profile_name):
        lvm_list = []
        lvm_list.extend(self.__persist_cfg_map.get_volumes())
        lvm_list.extend(self.get_profile(profile_name).get_volumes())
        return lvm_list

    def get_profile(self,
                    profile_name):
        return self.__profile_map.get_profile(profile_name)


## StorageConfigMap
# Class used to index all possible storage configs defined in specs.xml
# 
class StorageConfigMap:
    ## Init Method
    # @param xml xml.dom.minidom node for a storage_configs tag
    # @param layout_map DiskLayoutMap object with the common layout defs
    def __init__(self, 
                 xml,
                 layout_map):
        self.__stor_cfg_map = {}

        storage_nodes = xml.getElementsByTagName('storage_config')
        if storage_nodes in [ None, [] ]:
            raise AssertionError ('Empty storage configs section')

        for snode in storage_nodes:
            scfg = StorageConfig(snode, layout_map)
            if self.__stor_cfg_map.has_key(scfg.get_name()):
                raise AssertionError('Duplicate storage config %s' % \
                                     scfg.get_name())
        
            self.__stor_cfg_map[scfg.get_name()] = scfg


    def __str__(self):
        result = ''
        for scfg in self.__stor_cfg_map.values():
            for line in str(scfg).strip().split():
                result += 'storagecfgs/%s\n' % line
        return result

    #### External Methods #####################################################
    def get_storage_config(self, name):
        if self.__stor_cfg_map.has_key(name):
            return self.__stor_cfg_map[name]
        else:
            return None

################################################################################
# Partition Structures
# - mainly used for generating the partition table for a drive and used as a base
#   class for Raid Partitions
#
################################################################################
#
class Partition:
    part_id=''
    device_name='unknown'
    name='unknown'
    fstype=''
    size=''
    type=''
    # link back to the hd owner of this partition
    hd=None
    serialnum = 'unknown'
    fstype  =   ""
    size_mb = 0
    fill_to_end='false'

    def printto(self):
        print 'Partition %s, Name %s, Size %s, Status %s' % (self.dev_name, self.name, self.size, self.status)

    def __init__(self):
        self.hd         = None
        self.dev_name   ='unknown'
        self.size       = ''
        self.type       = ''
        self.serialnum  = ''


    ###########################################################################
    # get_devname
    #
    # return the device name for the partition, will return an empty string
    # if no hd has been attached to the partition
    #
    ###########################################################################
    def get_devname(self):
        return self.dev_name

    ###########################################################################
    # assign_hd
    #
    # Attach a hd structure to a partition element, and extract the appropriate
    # info from the hd for access in the partition.
    #
    # only called after a partition has been made with make_partition()
    #
    ###########################################################################
    def assign_hd (self, hd):
        self.hd = hd

        # if the disk is missing update the status and device name
        # appropriately
        if not hd.is_missing():
            self.status = 'online'
        else:
            self.status = 'missing'

        self.dev_name = 'disk%sp%s' % (hd.portnum, self.part_id)
        self.hd = hd
        self.serial_num = hd.serialnum


    ###########################################################################
    # make_partition
    #
    # build a partition object from the config, and optionally attach hd 
    # system parameters to it if supplied.
    #
    ###########################################################################
    def make_partition(self, part_id, size, type, hd = None, name='', fstype='',
                       fill_to_end='false'):
        # fill in the configuration filled parts of the partition
        self.part_id = part_id
        self.name = name
        self.size = '%s' % size
        self.size_mb = size
        self.type = type
        self.name = name
        self.fstype = fstype
        self.fill_to_end = fill_to_end

        if hd == None:
            # if we havent specified an HD, don't fill in the additional
            # hd related fields.  will be filled in by the assign_hd 
            # call.
            self.hd = None
        else:
            self.assign_hd (hd)

    def get_detail_status(self):
        print '\t%s\t%s' % (self.dev_name, 'online')

    def get_fill_to_end(self):
        return self.fill_to_end

class LogicalPartition(Partition):
    def __init__(self,
                 part_id,
                 size,
                 type,
                 hd = None,
                 name='',
                 fstype='',
                 logical_device=-1):
        Partition.__init__(self)
        self.logical_device = -1
        Partition.make_partition(self, part_id, size, type, hd, name, fstype)
        self.logical_device = logical_device

    def get_logical_device(self):
        return self.logical_device


## parse_storage_configs
# @param xml xml.dom.minidom xml root node, of which spec_defs is
#            a child
def parse_storage_configs(xml, layout_map):
    spec_nodes = xml.getElementsByTagName('spec_defs')[0]
    stor_nodes = spec_nodes.getElementsByTagName('storage_configs')

    if stor_nodes == []:
        return None
    else:
        # only one storage config section is supported.
        smap = StorageConfigMap(stor_nodes[0],
                                layout_map)
    return smap 


SPEC_CACHE_MNT="/tmp"
SPEC_MAP_CACHE_FILE="%s/specmap.pickle" % SPEC_CACHE_MNT

def populate_specmap_from_system(spec_file):
    from xml.dom.minidom import parse

    spec_xml = parse(spec_file)
    disk_layouts = DiskLayoutMap(spec_xml)
    storage_map = parse_storage_configs(spec_xml, disk_layouts)
    specmap = SpecMap(disk_layouts, spec_xml, storage_map)

    return specmap


def read_specmap(spec_file,
                 cached_spec_path = SPEC_MAP_CACHE_FILE):
    specmap = None

    # spec cache is only usable if the SPEC_CACHE_MNT is mounted
    have_usable_spec_cache_mnt = ismount(SPEC_CACHE_MNT) 
    if not have_usable_spec_cache_mnt:
        return populate_specmap_from_system(spec_file)
    
    if exists(cached_spec_path):
        # cache file exists
        try:
            cache_file = open(cached_spec_path, "rb")
            specmap = pickle.load(cache_file)
            cache_file.close()
            rlog_debug('Using cached specmap file %s' % (cached_spec_path))
        except (IOError, pickle.UnpicklingError, EOFError):
            # if we cannot open the cache file or having problem unpickling the
            # python object, bail out. We should NEVER fail the 
            # operation because of pickling.
            os.remove(cached_spec_path)
            specmap = None
            pass

    if specmap == None:
        specmap = populate_specmap_from_system(spec_file)
        try:
            cache_file = open(cached_spec_path, "wb")
            pickle.dump(specmap, cache_file, pickle.HIGHEST_PROTOCOL)
            cache_file.close()
        except (IOError, pickle.PicklingError):
            return specmap

    return specmap



def generate_spec_cache( spec_file,
                          cached_spec_path = SPEC_MAP_CACHE_FILE ):

    # spec cache is only usable if the SPEC_CACHE_MNT is mounted
    have_usable_spec_cache_mnt = ismount(SPEC_CACHE_MNT) 
    if not have_usable_spec_cache_mnt:
        return False
                          
    specmap = populate_specmap_from_system(spec_file)
    try:
        cache_file = open(cached_spec_path, "wb")
        pickle.dump(specmap, cache_file, pickle.HIGHEST_PROTOCOL)
        cache_file.close()
        return True
    except (IOError, pickle.PicklingError):
        return False
    
