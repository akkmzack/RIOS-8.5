#!/usr/bin/python

from os import listdir
from os.path import isfile
from os.path import isdir
from re import compile as recompile
from re import sub
from sys import exit
from hwtool_util import *
from hwconfig import Pci_link
from VmxUtils import *
from subprocess import Popen,PIPE
from os import devnull

BOB_VMX = "/tmp/BOB.vmx"
VMX_CLIENT = "/sbin/vmx_client"

##############################################################
# NIC, container class for NIC information in the system
##############################################################

class NIC:
    """NIC part information 
    """

    def __init__(self, mobo, nics, cards, gateway_naming=False):
        self.mobo = mobo
        self.nics = nics
        self.cards = cards
        self.gateway_naming = gateway_naming


    def _walk(self, root_dir, pref = ''):
        dir = listdir(root_dir)
        ret = []
        for f in dir:
            if f.startswith('0000:'):
                sd = self._walk(root_dir + f + '/', pref + f + '/')
                if len(sd) > 0:
                    ret.extend(sd)
                else:
                    ret.append(pref + f)
        return ret


    def _read_strip(self, path):
        fd = open(path)
        ret = fd.readline().strip()
        fd.close()
        return ret

    def _read_uuid(self, path):
        return self._read_strip(path).replace("{", "").replace("}", "").replace("-", "")

    def _read_id(self, path):
        return self._read_strip(path)[2:]

    # reads a device's vendor:device, busid_match (?), busid (?), and resource
    def _gen_pci_tup(self, root_dir, path):
        try:
            subvend = self._read_id(root_dir + path + '/subsystem_vendor')
            subid = self._read_id(root_dir + path + '/subsystem_device')
            mem = self._read_id(root_dir + path + '/resource')
        except:
            return ''

        if subvend == '0000':
            return ''

        mem = mem.split(' ')[0]

        dirs = path.split('/')
        busid = dirs[len(dirs)-1][5:]
        busid_match = ''

        for d in dirs:
            busid_match += d[8:] + ':'
        busid_match = busid_match[:-1]

        return (subvend, subid, busid_match, busid, mem)


    # looks up NIC/card info by matching pci_subid (vendor:device) with name_keys
    def get_card_from_link(self, link):
        for n in self.nics:
            for k in n.name_keys:
                if k == link.pci_subid:
                    return n

        for c in self.cards:
            for k in c.name_keys:
                if k == link.pci_subid:
                    return c

        return None


    def _get_nic_card_from_link(self, link):
        for n in self.nics:
            for k in n.name_keys:
                if k == link.pci_subid:
                    return n


    def get_links_from_pattern(self, pat, links):
        pattern = recompile('^'+pat.upper())

        ret = []
        for l in links:
            if pattern.search(l.tnv_string.upper()):
                ret.append(l)

        return ret


    def _get_nic_brand_str(self, interface, offset):
        output = ethtool(arg = '-e %s offset %s length 0x14' % (interface, offset))
        #Parse output, I dont like this at all
        secret = ''
        for n in range(2, 4):
            line = output[n]
            line = line.split('\t')
            line = line[2].replace(' ', '')
            secret += line

        return secret[0:40]

    @staticmethod
    def valid_brand_string(bstr):
        if compareSecretStr(bstr):
            print "true"
        else:
            print "false"

    def _filter_mgmt_from_links(self, links, redir_info):
        if not redir_info:
            return links
        flinks = []
        for l in links:
            match = 0
            for r in redir_info:
                if l.bdf == r['mgmt']:
                    match = 1
                    break
            if match == 0:
                flinks.append(l)

        return flinks

    # if you want management interfaces filtered from the output 
    # of _print_rename_pairs() (and you almost certainly do want 
    # that) populate redir_info by calling  _get_redirect_info()
    def _print_rename_pairs(self, card, links, ifcelist, slotNameMapping, 
                            slot, out_file, gateway_naming = False, 
                            quiet_print=False, redir_info=[]):
        links = self._filter_mgmt_from_links(links, redir_info)
        ln = len(links)
        if not hasattr(card, 'ordering'):
            return
        if ln % 2 != 0:
            return

        iter = range(ln)
        orders = card.ordering.split(':')
        for ord in orders:
            if ord == "descending":
                iter.reverse()
            elif ord == "ascending":
                pass
            elif ord == "ascending-reverse":
                new_iter = []
                for ix in iter:
                    if ix % 2 == 0:
                        new_iter.append(ix+1)
                    else:
                        new_iter.append(ix-1)

                iter = new_iter
            else:
                lst = ord.split(',')
                if ln != len(lst):
                    continue
                ct = 0
                for idx in lst:
                    ct += 1
                    if ct > ln:
                        break
                    iter[ct-1] = int(idx)

        if self.gateway_naming:
            prefix = 'eth'
        else:
            if card.if_naming != 'hp':
                prefix = 'lan'
            else:
                prefix = 'eth'

        if slotNameMapping.has_key(slot):
             if slotNameMapping[slot] == 'data':
                 prefix = 'eth'
                 gateway_naming = True
             else:
                 prefix = 'lan'

        if card.if_naming == 'hp':
            nic = 1
        else:
            nic = 0
        for i in iter:
            for a in ifcelist:
                if links[i].memory_base == a.memory_base:
                    if self.gateway_naming:
                        pnic = nic
                    else:
                        pnic = nic/2

                    if card.if_naming == 'hp':
                        interface = "%s%d" % (prefix, nic)
                    else:
                        interface = "%s%d_%d" % (prefix,slot,pnic)

                    print >>out_file, "%s" % (interface), a.mac

                    if not card.if_naming == 'hp':
                        if prefix == 'lan':
                            prefix = 'wan'
                        elif prefix == 'wan':
                            prefix = 'lan'
            nic += 1

    ## _get_net_dev_bar0
    #
    # @param self caller object
    # @param virt_name name of the virtual network device
    #
    # Gets the network device's resource data, if available (i.e. when it
    # can be read from devices that are connected to the PCI bus). If the
    # data is not found in the expected place, look in a secondary location
    # (i.e. in the virtio case for KVM). If the data is not on the PCI bus,
    # send back functionally-equivalent data to distinguish network devices
    # (i.e. in the vmbus case for Hyper-V).
    #
    # Postponing the virtio handling case for kauai.
    #
    def _get_net_dev_bar0(self, virt_name):
        # well-behaved PCI case (typical)
        res_path = "/sys/class/net/" + virt_name + "/device/resource"
        # if not exists(res_path):
            # check for virtio, with one more layer of indirection (KVM)
            # res_path = "/sys/class/net/" + virt_name + "/device/../resource"
        if exists(res_path):
            return self._read_id(res_path).split(' ')[0]
        # fall back to device_id GUID (Hyper-V)
        res_path = "/sys/class/net/" + virt_name + "/device/device_id"
        if exists(res_path):
            # return UUID as hex string
            return self._read_uuid(res_path)
        # error
        return None

    def get_bob_nic_info(self, slot, query):
        try:
            device_info = vmwarerpctool('\'info-get guestinfo.slotcard\' 2>/dev/null')[0]
            slot_no     = vmwarerpctool('\'info-get guestinfo.slot\' 2>/dev/null')[0]
        except HwtoolError:
            # This means there is no passthru slot
            # no need to do any further processing
            return 

        card = self.get_card_from_device_and_vendor(device_info)
        if slot == slot_no:
            if query == 'if_util':
                print "%s" % (card.utility)
            elif query == 'if_type':
                print "%s" % (card.wdt_type)
            elif query == 'if_part_num':
                print "%s" % (card.part_num)
            elif query == 'if_block':
                print "%s" % (card.block)
            else:
                print "Unknown query"
        else:
            # No card in this slot so return
            return

    def _get_redirect_info(self):
# the type of NIC we're looking for looks like this in lspci -tvn:
# 
# +-[0000:c0]-+-00.0-[c1]--
# |           +-02.0-[c2-c8]----00.0-[c3-c8]--+-01.0-[c4-c5]--+-00.0  8086:10f9
# |           |                               |               \-00.1  8086:10f9
# |           |                               +-08.0-[c6-c7]--+-00.0  8086:10f9
# |           |                               |               \-00.1  8086:10f9
# |           |                               \-09.0-[c8]----00.0  8086:1537
#
# i.e., four devices of type 8086:10f9 differing by 2 in bus number, 
# and one of type 8086:1537, two bus positions higher. The subvendor 
# is also set to Silicom (0x1374).

        p=Popen(["/sbin/lspci", "-vmd", "8086:10f9"], stdout=PIPE)
        output=p.communicate()[0]

        # Make sure that the subvendor, and subdevice are as expected. If so, 
        # save the bus:device.function. 
        r = re.compile(r"""Device:\s+([0-9a-f]{2}:[0-9a-f]{2}\.[0-9a-f]) 
                                         # bus:dev.func
                           \nClass:.*    #ignore
                           \nVendor:.*   #ignore
                           \nDevice:.*   #ignore
                           \nSVendor:\s+Silicom.*  # Silicom Ltd.
                           \nSDevice:\s+.*018[cde].*   # 018c,018d,018e
                           \nRev:.*      #ignore""", re.X)
        eth_bdfs = r.findall(output)

        # If the bus and device numbers are the same, make sure that there are 
        # 2 associated functions. (Otherwise, ignore the function numbers are 
        # ignored.)  
        cnt = {}
        for tmp in eth_bdfs:
            bd = tmp.split('.')[0]
            if cnt.has_key(bd):
                cnt[bd] += 1
            else:
                cnt[bd] = 1

        eth_bds = []
        for k, v in cnt.items():
            if v == 2:
                eth_bds.append(k)

        # Find pairs of devices which differ in bus position by 2 - these 
        # identify candidate redirector NICs.
        candidate_redirectors = []
        for i in range(len(eth_bds)):
            bus1=eth_bds[i].split(':')[0]
            c1 = int(bus1, base=16) + 2
            for j in range(i + 1, len(eth_bds)):
                bus2=eth_bds[j].split(':')[0]
                c2 = int(bus2, base=16) + 2
                # for convenience, sort each elements entries (and don't 
                # assume any particular ordering of the lspci output).
	        if (c2 == c1 + 2):
                    candidate_redirectors.append([eth_bds[i], eth_bds[j]])
                elif (c1 == c2 + 2):
                    candidate_redirectors.append([eth_bds[j], eth_bds[i]])

        # Now search for the associated management interfaces 
        positions =[]
        for cr in candidate_redirectors:
            # cr[1] has the higher bus index
            bus=cr[1].split(':')[0]
            mb = int(bus, base=16) + 2
            bi = hex(mb)
            bi += ":*"

            p=Popen(["/sbin/lspci", "-d", "8086:1537", "-s", bi], stdout=PIPE)
            output = p.communicate()[0]
            if output:
                # we have a match - save the locations so the names 
                # can be found with ethtool
                positions.append(dict(dev1=cr[0], dev2=cr[1], \
                                 mgmt=output.split(' ')[0]))

        # the index is bogus - for now we have no way of reading it, but 
        # this is ultimately OK since we program all devices identically
        index = 0

        # finally, identify the slot, mgmt interface name, etc.
        # we return a list of dictionary entries. Each dictionary 
        # entry contains:
        #   dev1: bus.device for the first ethernet device (e.g,. "c4:00")
        #   dev2: bus.device for the second ethernet device (e.g,. "c6:00")
        #   mgmt: bus.device.func for the management interface (e.g., c8:00.0)
        #  index: index of NIC (i.e., the "N" used by 'rdifctl dev N ...')
        #   slot: slot of NIC (as known by RiOS)
        # one entry per redirector NIC
        for pos in positions:
            pos['slot'] = "invalid"
            pos['index'] = -1
            links = self.make_pci_links()

            nicview = self.generate_nic_view()
            for (slotnum, slotlinks) in nicview.get_all_slots():
                r = re.compile(pos['dev1'])
                m = r.match(slotlinks.bdf)
                if m:
                    pos['slot'] = slotnum
                    break
            p=Popen(['/bin/ls', '/sys/class/net'], stdout=PIPE)
            output=p.communicate()[0]
            interfaces= output.split()
            for interface in interfaces:
                fnull=open(devnull, "w")
                p1=Popen(['/usr/sbin/ethtool', '-i', interface], stdout=PIPE, \
                         stderr=fnull)
                p2=Popen(['/bin/grep', '^bus-info'], stdin=p1.stdout, \
                         stdout=PIPE)
                p1.stdout.close()
                fnull.close()
                output=p2.communicate()[0]
                if output:
                    r = re.compile("^bus-info:\s+[0-9]*:"+pos["mgmt"])
                    m = r.match(output)
                    if m:
                        pos['name']=interface
                        break
            pos['index'] = index
            index += 1
        return positions

    # get_redirect_nics spits out the info required to configure the 
    # fulcrum switches: 
    #    <slot number>  <management interface name> <index)
    # one such line per switch
    def get_redirect_nics(self):
        tmp = self._get_redirect_info()
        for t in tmp:
            print "  %s        %s         %d" % \
                  (t['slot'], t['name'] , t['index'])

    def get_nic_info(self, slot, query):
        ct = 0
        nicview = self.generate_nic_view()
        for (slotnum, slotlinks) in nicview.get_all_slots():
            try:
                if slotlinks:
                    card = self._get_nic_card_from_link(slotlinks[0])
                    if slot == slotnum:
                        if query == 'if_util':
                            print "%s" % (card.utility)
                        elif query == 'if_type':
                            print "%s" % (card.wdt_type)
                        elif query == 'if_part_num':
                            print "%s" % (card.part_num)
                        elif query == 'if_block':
                            print "%s" % (card.block)
                        else:
                            print "Unknown query"
            except AttributeError:
                continue
            ct += 1


    def get_bob_card_list(self):
	# First figure out if this is bluedell or redfin 1U or redfin 2 U
	# and then assign range_max as 1, 3 and 5 respectively
	part_num = self.mobo.part_num
	type = self.mobo.type
	if part_num == '425-00135-01':
            range_max = 1;
	elif part_num == '425-00205-01':
	    if type  == '1U_LSI':
	        range_max = 3;
  	    elif type == '2U_LSI':
	        range_max = 5;
	    else:
		print "Error: Redfin MOBO not recognized"
	else:
	    print "Error: MOBO not recognized"
	    return	
	
	try:
            device_info = vmwarerpctool('\'info-get guestinfo.slotcard\' 2>/dev/null')[0]
            slot_no     = vmwarerpctool('\'info-get guestinfo.slot\' 2>/dev/null')[0]
        except HwtoolError:
            # This means there is no passthru slot
            # no need to do any further processing
            return

	card = self.get_card_from_device_and_vendor(device_info)
	if card == None:
            part_num = "Unknown"
	else:
            part_num = card.part_num

	for i in range(0,range_max):
	    if i == int(slot_no):
		print "%s %s" % (i, part_num)
            else:
		print "%s missing" % i	


    def get_card_list(self):
        nicview = self.generate_nic_view(if_only = False)
        for (slotnum, slotlinks) in nicview.get_all_slots():
            if slotlinks:
                card = self.get_card_from_link(slotlinks[0])
                if card == None:
                    part_num = "Unknown"
                else:
                    part_num = card.part_num

                print "%s %s" % (slotnum, part_num)
            else:
                print "%s missing" % slotnum


    def has_card(self, arg):
        """Given arg (a regex) return True if the card is in any slot in
        the system, or False otherwise
        """
        creg = recompile(arg)
        has_card = False

        links = self.make_pci_links()

        nicview = self.generate_nic_view(if_only = False)
        for (slotnum, slotlinks) in nicview.get_all_slots():
            if slotlinks:
                card = self.get_card_from_link(slotlinks[0])
                if card == None:
                    part_num = "Unknown"
                else:
                    part_num = card.part_num

                if creg.match(part_num):
                    has_card = True
                    break

        return has_card

    # displays known info about slotted NICs
    def get_nic_card(self):

        ct = 0
        nicview = self.generate_nic_view()
        for (slotnum, slotlinks) in nicview.get_all_slots():
            try:
                if slotlinks:
                    card = self.get_card_from_link(slotlinks[0])
                    print "%s, %s, %s, %s, %s" % (slotnum,
                                               card.utility,
                                               card.block,
                                               card.part_num,
                                               card.wdt_type)
            except AttributeError:
                continue
            ct += 1

    # scans bus for devices and generates link objects (vendor:device, resource)
    def make_pci_links(self):
        links = []

        # first, scan PCI bus
        device_root = '/sys/devices/'
        prelinks = []
        trees = {}

        bases = [ d for d in listdir(device_root) if d.startswith('pci0000:') ]

        for base in bases:
            trees[base] = self._walk(device_root+base+'/')
            # put everything into a standard order
            trees[base].sort()

        for base in bases:
            ct = 0
            for pl in trees[base]:
                pl = base + '/' + pl
                trees[base][ct] = pl
                ct += 1
            prelinks.extend(trees[base])
        base_len = len(bases)

        for node in prelinks:
            fail = self._gen_pci_tup(device_root, node)
            if fail == '':
                continue
            (vend, id, match, str, mem) = fail
            link = Pci_link()
            link.bdf = str
            link.pci_subid = vend+':'+id
            if base_len > 1:
                link.tnv_string = match
            else:
                link.tnv_string = match[3:]
            link.memory_base = mem
            links.append(link)

        # then, check vmbus (hyper-v)
        dev_bus = '/sys/bus/vmbus/drivers/hv_netvsc/'
        if isdir(dev_bus):
            hv_links = []
            for dev_code in listdir(dev_bus):
                if dev_code.startswith('vmbus_'):
                    dev_path = dev_bus + dev_code
                    ### dev_net = dev_path + '/net/'
                    ### for dev_label in listdir(dev_net):
                    ###     dev_mac = self._read_strip(dev_net + dev_label + '/address')
                    # hyper-v NICs lack subsystem_device, but have a consistent UUID
                    dev_class = self._read_uuid(dev_path + '/class_id')
                    # hyper-v dev_num assignment varies, but its *order* is persistent
                    dev_num = self._read_strip(dev_path + '/id')
                    # hyper-v vmbus devices lack /resource, so key on /device_id
                    dev_uuid = self._read_uuid(dev_path + '/device_id')
                    # hyper-v NICs lack subsystem_vendor, but functionally it
                    # just has to match the NIC's name_keys in config.xml
                    dev_vendor = 'hyperv'
                    dev_link = Pci_link()
                    dev_link.pci_subid = dev_vendor + ':' + dev_class
                    # Pci_link.tnv_string must match the motherboard's slots' pattern
                    # as defined in bus_number_pattern in config.xml. for hyper-v,
                    # slots are just logical constructs grouping pairs of NICs.
                    # only legacy hyper-v NICs are onboard, so both pri and aux should
                    # logically occupy slots 0 and 1. therefore we add inpath pairs
                    # to slots 2/3, 4/5, etc. we don't necessarily encounter vmbus
                    # NICs in ascending order, so for now we just save /device_id
                    dev_link.tnv_string = 'hyperv.' + dev_num
                    # there's no vmbus equivalent of PCI's /resource; we instead use
                    # a unique hex number to identify and distinguish NICs reliably
                    dev_link.memory_base = dev_uuid
                    hv_links.append(dev_link)
            # NIC id *order* is consistent; sort in case we picked them up differently
            hv_links.sort(key=lambda x: x.tnv_string)
            i = 0
            # assign them to slots in successive pairs
            for dev_link in hv_links:
                dev_link.tnv_string = "hyperv.{0:02d}".format(i)
                i += 1
                links.append(dev_link)

        return links

    ## get_card_from_device_and_vendor
    #
    # @nics list of all the NIC we know about
    # @param subdevice ID, subvendor ID of the passthru device
    #
    # pass in the device ID and the vendor ID string and get the card information
    # note that the card has to be a NIC card or else skip it
    def get_card_from_device_and_vendor(self, nicid):
        for n in self.nics:
            for k in n.name_keys:
                if nicid == k:
                    return n


    ## _print_bob_passthru_pairs
    #
    # @param card that we need to name the interfaces for
    # @param pairs interface information for each NIC that is unnamed
    # @param slot number where the card is inserted
    # @param out_file where the mactab output is redirected
    #
    # This will give the interfaces names for mactab if they are unnamed
    def _print_bob_passthru_pairs(self, card, pairs, slot, out_file):
        brand_support = self.mobo.branding
        # This flag is used to indicate unbranded hardware found in system
        unbranded_found = False
        iter = pairs.keys()
        ln = len(iter)
        if not hasattr(card, 'ordering'):
            return
        if ln % 2 != 0:
            return

        iter.sort()
        if card.guest_order != None and card.guest_order != '':
            ord = card.guest_order
        else:
            ord = card.ordering

        if ord == "descending":
            iter.reverse()
        elif ord == "ascending":
            pass

        prefix = 'lan'
        nic = 0
        for i in iter:
            nicinfo = pairs[i]
            pnic = nic/2

            interface = "%s%s_%d" % (prefix, slot, pnic)
            if "true" == brand_support:
                if not self.brandcheck(nicinfo[0], card):
                    unbranded_found = True
                    continue

            print >>out_file, "%s" % (interface), nicinfo[1]
            if prefix == 'lan':
                prefix = 'wan'
            elif prefix == 'wan':
                prefix = 'lan'
            nic += 1

        return unbranded_found


    ## get_bob_mactab
    #
    # @param list of all the NIC cards we know about
    # @param filename where the MAC output needs to be printed
    #
    # Get the interface to MAC mapping for all BOB boxes
    # This will read the VMX file from the host and parse it
    # based on the MAC's in the VMX file apply the name
    #
    def get_bob_mactab(self, out_path):
        out_file = None
        if out_path != '':
            out_file = open(out_path, 'w')
        # This is the first attempt to get the mactab, read the 
        # VMX file
        if not isfile(BOB_VMX):
            try:
                vmx_client()
            except HwtoolError:
                print "Could not get the VMX file in the guest"
                exit(1)

        # These are the ifaces that are already named via VMX file
        # For passthru NIC naming, we need to skip all the named NIC's
        named_ifaces = {}

        pvf = ParseVMXFile(BOB_VMX);
        pnics = pvf.get_nic()
        p_nic_keys = pnics.keys()
        for p in p_nic_keys:
            if pnics[p].name() != "":
                # These are RSP NICS, to get the name of the interface
                # get the FilterParam value
                print >>out_file, pnics[p].param0().replace('"', ''), pnics[p].generatedAddress().replace('"', '').upper()
                named_ifaces[pnics[p].generatedAddress().replace('"', '').upper()] = 1
            else:
                # These are the NON RSP NICS
                # For primary, aux, hpn, get rid of the 'vm' suffix
                ifacename = pnics[p].networkName().replace('"', '')
                if ifacename == 'primaryvm' or ifacename == 'auxvm':
                    ifacename = re.sub(recompile('vm$'), "", ifacename)
                    print >>out_file, ifacename, pnics[p].address().replace('"', '').upper()
                    named_ifaces[pnics[p].address().replace('"', '').upper()] = 1
                elif ifacename == 'hpnvm':
                    ifacename = re.sub(recompile('vm$'), "", ifacename)
                    print >>out_file, ifacename, pnics[p].generatedAddress().replace('"', '').upper()
                    named_ifaces[pnics[p].generatedAddress().replace('"', '').upper()] = 1
                else:
                    print >>out_file, ifacename, pnics[p].generatedAddress().replace('"', '').upper()
                    named_ifaces[pnics[p].generatedAddress().replace('"', '').upper()] = 1

        try:
            device_info = vmwarerpctool('\'info-get guestinfo.slotcard\' 2>/dev/null')[0]
            slot_no     = vmwarerpctool('\'info-get guestinfo.slot\' 2>/dev/null')[0]
        except HwtoolError:
            # This means there is no passthru slot
            # no need to do any further processing
            return 

        # This dict will be used if the pairs aren't named as yet
        # We will need more information to do the naming
        pairs = {}

        # This list will be used if the ifaces are already named
        # If will use the name and MAC and just display the interface
        named_pairs = []

        ifaces = recompile("^eth[\d]+|^[l|w]an\d_\d")

        # This flag indicates that the passthru NIC is not named
        # and we need to rename the pairs
        passthru_is_unnamed = False
        dir_list = listdir('/sys/class/net/')
        dir_list.sort()
        for nicname in dir_list:
            if ifaces.search(nicname):
               mac = self._read_strip("/sys/class/net/" + nicname + "/address").upper()
               bar0 = self._read_id("/sys/class/net/" + nicname +
                              "/device/resource").split(' ')[0]
               device = self._read_strip("/sys/class/net/" + nicname + "/device/device")
               vendor = self._read_strip("/sys/class/net/" + nicname + "/device/vendor")

               if not named_ifaces.has_key(mac):
                   if nicname[0:3] == 'eth':
                       pairs[int(nicname[3:])] = [ nicname, mac, bar0, device, vendor ]
                       passthru_is_unnamed = True
                   else:
                       named_pairs.append([nicname, mac])

        passthru_nic = self.get_card_from_device_and_vendor(device_info)
        if passthru_is_unnamed:
            self._print_bob_passthru_pairs(passthru_nic, pairs, slot_no, out_file)
        else:
            # XXX/munirb: Do not change the order of allowed_ifaces
            # it is used to control the output
            # lan/wan interfaces need to be added as well, from XanY_0 .. XanY_2
            # (for 6 port copper if ever used)
            
            allowed_ifaces = [ z + 'an' + str(x)+ '_' + str(y) for z in ['l', 'w'] for x in range(6) for y in range(3) ]
            for ifname in allowed_ifaces:
                for nic in named_pairs:
                    if ifname == nic[0]:
                        print >>out_file, nic[0], nic[1]


    ## __parse_mgmt_mac_naming
    #
    # parse the file /config/mgmt_mac_naming written by mgmtd 
    # by default we will pick the naming as 'inpath'. On firstboot
    # the file will be missing so we will name all interfaces lan/wan 
    # (apply gateway naming for other appliances), but for every successive boot
    # the file will be written and we will do the naming accordingly.
    # File format is ...
    # <slot>:<data|inpath>
    #
    # Return a map with slot to type mappting
    def __parse_mgmt_mac_naming(self):
        slotMapping = {}
        mgmtFile = '/config/mgmt_mac_naming'
        if not exists(mgmtFile):
            # The file isn't present means that either its firstboot
            # or this product has no idea about mixed interfaces 
            return slotMapping

        try:
            fp = open(mgmtFile, 'r')
            for line in fp:
                (slot, type) = line.split(':')
                if type not in ['inpath', 'data']:
                    # Junk type in the file, I would love to throw an exception
                    # but will have to continue and ignore this line
                    pass
                slotMapping[int(slot)] = type.strip()
            fp.close()
        except:
            pass

        return slotMapping

    @staticmethod
    def allowed_interface_names():
        '''return all possible interface names on any appliance in a canonical order'''
        # XXX/munirb: Do not change the order of allowed_ifaces
        # it is used to control the output

        # interface name can be eth0 .. eth39 max at mfg prompt
        allowed_ifaces = [ 'eth' + str(x) for x in range(40) ]
        # Append primary, aux and prihw
        allowed_ifaces.extend(['primary', 'aux', 'prihw'])
        # lan/wan interfaces need to be added as well, from XanY_0 .. XanY_2
        # (for 6 port copper if ever used)
        allowed_ifaces.extend(
                [ z + 'an' + str(x)+ '_' + str(y) \
                        for z in ['l', 'w'] \
                        for x in range(6) \
                        for y in range(3) ])

        # For corsica which names interfaces ethX_Y
        allowed_ifaces.extend(
                [ 'eth' + str(x)+ '_' + str(y) \
                        for x in range(6) \
                        for y in range(6) ])

        return allowed_ifaces

    class ifconfig_entry:
        def __init__(self, name, mac, memory_base):
            self.name = name
            self.mac = mac
            self.memory_base = memory_base
        def __str__(self):
            return "ifce %s %s %s" % \
                    (self.name, self.mac, self.memory_base)

    def get_filtered_ifconfig(self):
        '''ifconfig_entry's, sorted & filtered by allowed_ifaces.'''

        raw_ifc = self.get_ifconfig()

        allowed_ifnames = self.allowed_interface_names()

        aid = dict(zip(allowed_ifnames, range(len(allowed_ifnames))))
        pos_dict = dict([ (aid[ifce.name], ifce) \
                            for ifce in raw_ifc \
                            if ifce.name in aid ])
        return [ pos_dict[i] for i in sorted(pos_dict.keys()) ]


    def get_brandsplit_ifconfig(self):
        nicview = self.generate_nic_view()
        return nicview.brandsplit_ifconfig()

    def get_ifconfig(self):
        '''Return a list of ifconfig_entry's, filtered for expected ifnames.'''
        # This flag is to check if the prihw interface is present or not
        # For non SH and IB appliances the prihw interface won't be present 
        # if the flag is not set, no need to rename primary for sysfs nodes
        # XXX/munirb: Bug 68779
        # We also do the same for aux and auxhw (found only on VSP appliances)
        has_prihw = True
        if not exists('/sys/class/net/prihw'):
            has_prihw = False

        has_auxhw = True
        if not exists('/sys/class/net/auxhw'):
            has_auxhw = False

        ifce_list = []

        if self.gateway_naming:
            prefixes = ('primary', 'aux', 'eth', 'lan', 'wan')
        else:
            prefixes = ('prihw', 'primary', 'auxhw', 'aux', 'eth', 'lan', 'wan')
        ifcs = []
        try:
            fp = open('/proc/net/dev', 'r')
            for line in fp:
                i = line.find(':')
                if i == -1:
                    continue
                ifname = line[:i].strip()
                for p in prefixes:
                    if ifname.startswith(p):
                        ifcs.append(ifname)
            fp.close()
        except:
            pass

        for nm in ifcs:
            virt_name = nm
            # In canary we have a primary interface and a prihw interface
            # both share the same MAC, primary is a virtual interface
            # while prihw is the real interface
            # The easiest fix is to replace the 'primary' with 'prihw' to 
            # get all the sysfs information, but for printing purpose
            # use 'primary'. This is a bit different to samoa, the address_map
            # query will print primary instead of prihw, but since no one
            # uses that query, we should not have any issues.
            # In hope, there is a similar mechanism for aux and auxhw on VSP
            # appliances.
            if virt_name == 'primary' and has_prihw:
                virt_name = 'prihw'
            elif virt_name == 'aux' and has_auxhw:
                virt_name = 'auxhw'
            elif virt_name == 'prihw' or virt_name == 'auxhw':
                # Skip this interface as we don't
                # want to duplicate entries
                continue
            mac = self._read_strip("/sys/class/net/" + virt_name + "/address").upper()
            bar0 = self._get_net_dev_bar0(virt_name)

            ifce_list.append( NIC.ifconfig_entry(nm, mac, bar0) )

        return ifce_list

    def brandcheck(self, ifname, card):
        ok = True
        if card.ethtool_offset:
            ok = compareSecretStr(
                    self._get_nic_brand_str(ifname,
                        card.ethtool_offset))
        return ok

    def get_mactab(self, out_path):
        out_file = None
        if out_path != '':
            out_file = open(out_path, 'w')

        nicview = self.generate_nic_view(check_branding=True)
        ob_links = nicview.get_onboard_links()
        if len(ob_links) == 0:
            ifc = ifconfig(arg = "-a")
            link = recompile("Link")
            for l in ifc:
                lk = link.search(l, 1)
                if lk:
                    parts = l.split()
                    if len(parts) > 4:
                        print >>out_file, 'primary', parts[4]
            return

        if self.mobo.num_ifs == 2 and len(ob_links) > 1:
            if self.mobo.primary_first:
                primary = ob_links[0]
                aux = ob_links[1]
            else:
                primary = ob_links[1]
                aux = ob_links[0]

            dev_map_list = [{'device':primary, 'name':'primary'},
                            {'device':aux, 'name':'aux'}]
        
        else:
            # we only have primary no aux
            primary = ob_links[0]
            dev_map_list = [{'device':primary, 'name':'primary'}]

        for i in nicview.ifcelist:
            for nic in dev_map_list:
                if nic['device'].memory_base == i.memory_base:
                    print >>out_file, nic['name'], i.mac

        slotNameMapping = self.__parse_mgmt_mac_naming()

        redir_info = self._get_redirect_info()
        for (slot, links) in nicview.get_all_slots():
            if links:
                card = self.get_card_from_link(links[0])
                self._print_rename_pairs(card, links,
                        nicview.ifcelist, slotNameMapping,int(slot), out_file,
                        False, False, redir_info)

    class NicView:
        def __init__(self, nicobj, onboards, slots, ifcelist):
            self.nicobj = nicobj
            # list of lci_entry's
            self.onboards = onboards
            # list of (int(slotnum), lci_entry) tuples for existing links, sorted by
            # slotnum
            self.slots = slots
            # the ifconfig entry list used to generate the above
            self.ifcelist = ifcelist

        def get_all_slots(self):
            '''return list of (slotnum_str, slotlinks) for every slot in mb's
            config.xml, wrapping vsh special cases'''
            for (numstr,p) in self.nicobj.mobo.slot_patterns:
                num = int(numstr)
                lci_for_slot = [lci for (slotnum,lci) in self.slots if slotnum == num]
                yield (numstr, [ lci.link for lci in lci_for_slot ])

        def get_onboard_links(self):
            '''return list of links matching motherboard onboard pattern, wrapping
            vsh special cases'''
            return [ lci.link for lci in self.onboards ]

        def lci_for_memory_base(self, memory_base):
            for lci in self.onboards:
                if lci.link.memory_base == memory_base:
                    return lci
            for (slotnum, lci) in self.slots:
                if lci.link.memory_base == memory_base:
                    return lci

        def brandsplit_ifconfig(self):
            '''stably split ifcelist into (branded,unbranded)]'''
            # XXX/alfred - note that I'm not looking at whether the mb supports
            # branding, and instead letting the couple of checks on the card
            # determine whether this is valid.

            branded = []
            unbranded = []
            for iface in self.ifcelist:
                ok = True
                lci = self.lci_for_memory_base(iface.memory_base)
                if lci != None and lci.card != None and lci.card.part_num != 'Integrated':
                    ok = self.nicobj.brandcheck(iface.name, lci.card)
                if ok:
                    branded.append(iface)
                else:
                    unbranded.append(iface)

            return (branded, unbranded)

    def generate_nic_view(self, check_branding = False, if_only = True):
        '''Return Nic_View obj that provides a consistent, cross-boot layout
        of the interfaces for this vm motherboard.'''

        # in the directpath usage case, the virtual interfaces for primary &
        # aux can end up on pci slots that don't match the "onboard" patterns
        # of the vm motherboard entry, and the virtual interfaces for primary &
        # aux can end up on "slot" patterns.  And even if the directpath
        # interfaces are removed, esx can leave the virtual interfaces in
        # their "wrong" places.

        # So the strategy below is to try and recognize when the interfaces
        # are all virtual & lining up with the values from config.xml - the
        # common case - and make sure that works.
        # When that's not true, we will:
        #   - if there are both virtual and physical interfaces present, we will
        #   assume that primary/aux are supposed to be virtual.

        # So we build up the list of virtual interfaces, whereever they end up,
        # and then grab the first two - we put the 'onboard_pattern' matches at
        # the beginning of the list to keep the results the same for the
        # non-directpath case.

        onboards = []
        slots = []
        physical_in_onboard = 0
        virtual_in_onboard = 0
        pci_links = self.make_pci_links()
        ifcelist = self.get_ifconfig()

        for lci in self.get_lci_entries(self.mobo.onboard_pattern, pci_links, ifcelist, if_only = if_only):
            if lci.card != None and lci.card.wdt_type != "VSH":
                physical_in_onboard += 1
            else:
                virtual_in_onboard += 1
            onboards.append(lci)

        for (_slotnum, pattern) in self.mobo.slot_patterns:
            slotnum = int(_slotnum)
            for lci in self.get_lci_entries(pattern, pci_links, ifcelist, if_only = if_only):
                slots.append((slotnum,lci))

        #for i in onboards:
            #print "onboard: %s %s %s %s" % (i.link, i.card, i.ifce, i.pattern)
        #for n, i in slots:
            #print "slot %s: %s %s %s %s" % (n, i.link, i.card, i.ifce, i.pattern)

        # key here is to ensure we don't use anything other than
        # the slot number to sort on, ensuring that we get
        # stable sorts based on however we pull from patterns
        slots.sort(key=lambda x: x[0])

        if not virtual_in_onboard and self.mobo.part_num == "VM":
            # directpath nic's may have caused ESX to move what was
            # primary/aux virtual nic's into "slot" patterns.
            # if possible, grab the last two virtual interface with same pattern
            virt_slots = [ (slotnum, lci) for (slotnum, lci) in slots if lci.card != None and lci.card.wdt_type == "VSH" ]
            tomove = virt_slots[-2:]
            onboards.extend([lci for (slotnum, lci) in tomove ])
            slots = [t for t in slots if t not in tomove]

        if physical_in_onboard and self.mobo.part_num == "VM":
            # directpath nic's ended up in the "onboard" slots;
            # want to move them out since we won't support having
            # primary/aux as directpath.

            phys_onboards = [ lci for lci in onboards if lci.card != None and lci.card.wdt_type != "VSH" ]
            # sort the patterns to ensure determinism across calls
            po_patterns = sorted(set([lci.pattern for lci in phys_onboards]))
            for p in po_patterns:
                newslot_links = [ lci for lci in phys_onboards if lci.pattern == p ]
                next_slotnum = next_lowest_int([ slotnum for (slotnum, _) in slots ])
                slots = slots + [(next_slotnum, link) for link in newslot_links]
                slots.sort(key=lambda x: x[0])

            onboards = [ lci for lci in onboards if lci.card != None and lci.card.wdt_type == "VSH" ]

        # the bpvm0 interface used for ESX 4 support can cause interfaces
        # to shift across slot patterns.
        newslots = []
        while slots:
            slot = slots[0][0]
            nextslots = first_elements_of(slots, lambda el: el[0] == slot)
            incr = len(nextslots)
            if incr % 2 != 0:
                # try to scooch the next matching card type up to
                # this slot
                next_cards = first_elements_of(slots[len(nextslots):],
                        lambda el: el[1].card.wdt_type == nextslots[-1][1].card.wdt_type)

                if next_cards:
                    slots.remove(next_cards[0])
                    nextslots.append((slot, next_cards[0][1]))

            newslots.extend(nextslots)
            slots = slots[incr:]

        slots = newslots

        return NIC.NicView(self, onboards, slots, ifcelist)


    class lci_entry:
        def __init__(self, link, card, ifce, pattern):
            self.link = link
            self.card = card
            self.ifce = ifce
            self.pattern = pattern
        def __str__(self):
            return "link %s %s %s %s" % (self.link, self.card, self.ifce, self.pattern)

    def get_lci_entries(self, pattern, pci_links, ifcelist, if_only = True):
        ret = []

        for link in self.get_links_from_pattern(pattern, pci_links):
            card = self.get_card_from_link(link)

            ifce_val = None
            for ifce in ifcelist:
                if ifce.memory_base == link.memory_base:
                    ifce_val = ifce
                    break
            if ifce_val == None and if_only:
                continue

            ret.append(NIC.lci_entry(link, card, ifce, pattern))

        return ret


def next_lowest_int(x):
    '''return lowest integer higher than element of x,
    x must be sorted, default to 0'''
    ret = 0
    if x:
        ret = x[0] + 1
        if len(x) != 1:
            for i in range(1, len(x)):
                if ret < x[i]:
                    break
                ret = x[i] + 1
    return ret

def first_elements_of(x, func):
    '''return list of first matches to func'''
    ret = []
    for el in x:
        if not func(el):
            break
        ret.append(el)
    return ret
