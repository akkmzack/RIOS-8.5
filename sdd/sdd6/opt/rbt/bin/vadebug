#!/usr/bin/env python
#
# -*- python -*-
#
# (C) Copyright 2003-2009 Riverbed Technology, Inc.
# All rights reserved. Confidential.
#
"""vadebug - VA statistics display and analyze"""
#------------------------------------------------------------------------------
# NOTE: How to debug vadebug with the python debugger.
# ln -s vadebug vadebug.py
# python
# import pdb
# import vadebug
# from vadebug import *
# # Replace the string below with the command line parameters
# sys.argv.extend("-O 0 -v 0 -o pdb -C test1.core.log".split())
# sys.argv[0] = "vadebug"
# pdb.Pdb().run("main()")
#------------------------------------------------------------------------------
import os, glob, sys, getopt, re, math, datetime
from socket import *
import pprint

# Config variables
_core_sock = None
_edge = "000.000.000.000:0000"
_core = "000.000.000.000:0000"
_edge_sock = None
_edgestats = []     # [ ( [ ( stat, use_count), ... ], timestamp, edge ), ... ]
_corestats = []     # [ ( [ ( stat, use_count), ... ], timestamp, core ), ... ]
_outfile = "result"
_template = ""
_version = "0.6"                    # Changed from DVA/EVA to CORE/EDGE
_pp = pprint.PrettyPrinter(indent=4)
_all_core_stat_descriptors = []
_all_edge_stat_descriptors = []

# ------------- CORE API Functions ------------------
#------------------------------------------------------------------------------
# types of return
INT, FLOAT, STR, DICT, LIST, LIST_INT, LIST_FLOAT, LIST_STR, KEYS, \
        KEY_ENUM, BKT = range(1, 12)

# Extract
def extract(stats, what):
    global _debug                   # In
    result = []
    pattern = what.replace("*", "(\S+( \S+)*)")
    regex = re.compile(pattern)
    for stat in stats:
        m = regex.match(stat['key'])
        if None != m:
            if (_debug & 256) != 0:
                print "extract: key='%s', pattern='%s'," \
                      " m.groups()='%s', m.groupdict()='%s'" % (
                    stat['key'], pattern, m.groups(), m.groupdict())
            if () == m.groups():    # Matched with no groups in pattern
                result.append(stat['key'])
            else:                   # Matched with groups
                result.append(m.group(1))
                    

    return result

#------------------------------------------------------------------------------
# List/Tuple functions

# Get list[] or return default if the list is too short.
def list_get_or_default(list, idx, default = None):
    length = len(list)
    if idx >= 0:
        if idx < length:
            return list[idx]
        else:
            return default
    else:
        if (-idx) <= length:
            return list[idx]
        else:
            return default

# Get list[] or add and return default if the list is too short.
def list_get_or_add_default(list, idx, default = None):
    length = len(list)
    if idx >= 0:
        while idx >= length:
            list.append(default)
            length += 1
            return list[idx]
    else:
        while (-idx) > length:
            list.append(default)
            length += 1
    return list[idx]

#------------------------------------------------------------------------------
# Difference of two stats functions

# Difference of two bucket stats: stat2 - stat1
def bucket_stat_diff(stat1, stat2):
    global _debug                   # In
    if (_debug & 256) != 0:
        print "stat1", stat1
        print ""
        print "stat2", stat2
        print ""
    result = {}
    # 'unit'
    unit1 = stat1['unit']
    unit2 = stat2['unit']
    if unit1 != unit2:
        print "Warning BucketStats have different units."
    result['unit'] = unit2
    # 'aggregate'
    result['aggregate'] = stat2['aggregate'] - stat1['aggregate']
    # 'nupdates'
    result['nupdates'] = stat2['nupdates'] - stat1['nupdates']
    # 'data'
    data1 = stat1['data']
    data2 = stat2['data']
    data_result = [0] * max(len(data1), len(data2))
    num1 = 0
    num2 = 0
    num_result = 0
    max_bkt_idx = None
    for idx in range(0, len(data_result)):
        bkt1 = data1[idx]
        num1 += bkt1
        bkt2 = data2[idx]
        num2 += bkt2
        if bkt2 < bkt1:
            print "Warning: stat1.bkt[%d] < stat2.bkt[%d], i.e. %d < %d" % \
                  (idx, idx, bkt1, bkt2)
            bkt2 = bkt1
        bkt_result = bkt2 - bkt1
        data_result[idx] = bkt_result
        num_result += bkt_result
        if bkt_result > 0:
            max_bkt_idx = idx
    result['data'] = data_result
    # 'avg'
    if num_result != 0:
        result['avg'] = result['aggregate'] / num_result
    else:
        result['avg'] = "NaN"
    # 'max'
    max1 = stat1['max']
    max2 = stat2['max']
    if max2 > max1:
        if (_debug & 256) != 0:
            print "Note: 'max' from stat2 since stat2['max'] > stat1['max']"
        max_result = max2
    else:
        bkt_idx_max2 = get_bucket_index(max2)
        if data_result[bkt_idx_max2] > 0:
            if (_debug & 256) != 0:
                print "Note: 'max' from stat2" \
                      " since the corresponding bucket is occupied in result"
            max_result = max2
        elif max_bkt_idx == None:
            if (_debug & 256) != 0:
                print "Note: 'max' is 0 since result is empty"
            max_result = 0
        else:
            max_bucket = get_bucket_from_index(max_bkt_idx)
            max_result = max_bucket[1]
            if (_debug & 256) != 0:
                print "Note: approximated 'max'" \
                      " to max value of highest non-empty bucket in result"
    if max_bkt_idx != None:
        bkt_idx_max_result = get_bucket_index(max_result)
        if bkt_idx_max_result != max_bkt_idx:
            print "Warning: result['max']" \
                  " is not in the highest non-empty bucket in result"
    result['max'] = max_result
    #
    if (_debug & 256) != 0:
        print "stat2 - stat1", result
        print ""
    return result

# Difference of two stats: stat2 - stat1
def stat_diff(stat1, stat2, return_type=LIST):
    if (stat1 == None) or (stat2 == None):
        return None                     # At least one stat not found
    if return_type in [ INT, FLOAT ]:
        return stat2 - stat1
    if return_type == BKT:
        return bucket_stat_diff(stat1, stat2)
    if return_type in [ LIST_INT, LIST_FLOAT ]:
        return [stat1[idx] - stat2[idx]
                for idx in range(0, min(len(stat1), len(stat2)))]
    # Invalid return_type.  Return second statistic.
    return stat2

# Get difference of two CORE stats: [idx2] - [idx1]
def get_core_stat_diff(statname, return_type=LIST, idx1=-2, idx2=-1):
    stat1 = get_core_stat(statname, return_type, idx1)
    stat2 = get_core_stat(statname, return_type, idx2)
    return stat_diff(stat1, stat2, return_type)

# Get difference of two EDGE stats: [idx2] - [idx1]
def get_edge_stat_diff(statname, return_type=LIST, idx1=-2, idx2=-1):
    stat1 = get_edge_stat(statname, return_type, idx1)
    stat2 = get_edge_stat(statname, return_type, idx2)
    return stat_diff(stat1, stat2, return_type)

# Get CORE stat if idx1 == idx2 or the difference of two CORE stats if idx1 !=
# idx2
def get_core_stat_or_diff(statname, return_type=LIST, idx1=-2, idx2=-1):
    if idx1 == idx2:
        return get_core_stat(statname, return_type, idx1)
    else:
        return get_core_stat_diff(statname, return_type, idx1, idx2)

# Get EDGE stat if idx1 == idx2 or the difference of two EDGE stats if idx1 !=
# idx2
def get_edge_stat_or_diff(statname, return_type=LIST, idx1=-2, idx2=-1):
    if idx1 == idx2:
        return get_edge_stat(statname, return_type, idx1)
    else:
        return get_edge_stat_diff(statname, return_type, idx1, idx2)

#------------------------------------------------------------------------------
# Get stat functions

STATS_LINES, STATS_VALUE, STATS_TIMESTAMP, STATS_DATE = range(0, 4)

# Append to CORE or EDGE stats
def append_to_stats(stats, value, msg=""):
    global _debug                   # In
    if stats == None:
        print "WARNING: %s stats == None" % msg
        return
    len_stats = len(stats)
    if (_debug & 256) != 0:
        print "Append %s stats[%d]='%s'" % (msg, len_stats, value)

    except1 = None
    try :
        len_value = len(value)
    except Exception, except1:
        print "Warning: len(value): Appending %s stats[%d]:" \
              " Exception(%s): len('%s')" % (msg, len_stats, except1, value)
    else:
        if len_value < 4:
            print "Warning: value too short: Appending %s stats[%d]:" \
                  " len('%s') == %d" % (msg, len_stats, value, len_value)

    stats.append(value)

# Fetch a CORE stat
def get_core_stat(statname, return_type=LIST, idx=-1, quiet=False):
    global _debug                   # In
    if (_debug & 256) != 0:
        print ""
        print "Get CORE stat", statname, "return_type", return_type, "idx", idx
    global _corestats                # In
    stat = list_get_or_default(_corestats, idx, None)
    if stat == None:
        return None
    return get_stat(list_get_or_default(stat, 0, None),
                    statname, return_type, quiet)

# Fetch a EDGE stat
def get_edge_stat(statname, return_type=LIST, idx=-1, quiet=False):
    global _debug                   # In
    global _edgestats                # In
    if (_debug & 256) != 0:
        print ""
        if _edgestats != None:
            print "Get EDGE stat '%s', return_type %d, [%d] from len(_edgestats)=%d" % (
                statname, return_type, idx, len(_edgestats))
        else:
            print "_edgestats == None"
    stat = list_get_or_default(_edgestats, idx, None)
    if stat == None:
        return None
    return get_stat(list_get_or_default(stat, 0, None),
                    statname, return_type, quiet)

bucket_pattern = "^([ 0-9]| *max:| *Aggregate :)"
bucket_regex = re.compile(bucket_pattern)
def get_stat(stats, statname, return_type, quiet):
    global _debug                       # In
    global bucket_pattern               # In
    global bucket_regex                 # In
    global STATS_LINES                  # In
    global STATS_VALUE                  # In
    if (_debug & 256) != 0:
        print "get_stat(statname='%s', return_type=%d, quiet=%d)" % (
            statname, return_type, quiet)
    if stats == None:
        return None
    result = []
    stat_pattern = "^(?P<key>%s) (?P<value>\S+)\s*$" % \
                   statname.replace("*", "\S+( \S+)*")
    stat_regex = re.compile(stat_pattern)
    bucket_stat_2_pattern = "^(?P<key>%s)  +(?P<units>\S+(\s\S+)*)\s*$" % \
                            statname.replace("*", "\S+( \S+)*")
    bucket_stat_2_regex = re.compile(bucket_stat_2_pattern)
    bucket_stat_1_pattern = "^(?P<key>%s) (?P<units>\S+(\s\S+)*)\s*$" % \
                            statname.replace("*", "\S+")
    bucket_stat_1_regex = re.compile(bucket_stat_1_pattern)
    if (_debug & 256) != 0:
        print "stat_pattern='%s', bucket_stat_2_pattern='%s'," \
              " bucket_stat_1_pattern='%s'" % (
            stat_pattern, bucket_stat_2_pattern, bucket_stat_1_pattern )
    for i in xrange(0, len(stats)):
        except1 = None
        try :
            stat = stats[i][STATS_LINES]
        except TypeError, except1:
            print "TypeError(%s) of stats[%d][%d]='%s'" % (
                except1, i, stats[i], STATS_LINES)
            continue
        except IndexError, except1:
            print "IndexError(%s) of stats[%d][%d]='%s'" % (
                except1, i, stats[i], STATS_LINES)
            continue
        m = stat_regex.match(stat)
        if m != None:
            if (_debug & 256) != 0:
                print "Matched stat_regex: [%d] '%s', m is '%s'" % (
                    i, stat, m.groups())
            # This could be a bucket stat
            if (i < (len(stats) - 1)) and bucket_regex.match(stats[i+1][STATS_LINES]):
                if (_debug & 256) != 0:
                    print "Possible bucket stat: [%d] '%s'" % ( i, stats[i][STATS_LINES] )
                    print "Matched bucket regex: [%d] '%s'" % ( i+1, stats[i+1][STATS_LINES] )
                data = get_bucket_stat(stats, statname, i);
                if data != None:
                    stats[i][STATS_VALUE] += 1
                    result.append(dict(key=m.group(1).strip(), val=data))
                    if (_debug & 256) != 0:
                        print "Increment [%d] '%s' from %d to %d" % \
                              ( i, stat, (stats[i][STATS_VALUE] - 1), stats[i][STATS_VALUE] )
                        print ""
                    continue
            else:
                stats[i][STATS_VALUE] += 1
                result.append(dict(key=m.group('key').strip(),
                                   val=m.group('value').strip()))
                if (_debug & 256) != 0:
                    print "Not a bucket stat: [%d] '%s'" % ( i, stats[i][STATS_LINES] )
                    if i < (len(stats) - 1):
                        print "Did not match bucket regex: [%d] '%s'" % ( i+1, stats[i+1][STATS_LINES] )
                    print "Increment [%d] '%s' from %d to %d" % \
                          ( i, stat, (stats[i][STATS_VALUE] - 1), stats[i][STATS_VALUE] )
                    print ""
                continue
        elif (_debug & 256) != 0:
            print "Did not match stat_regex: [%d] '%s'" % (i, stat )
        mb = bucket_stat_2_regex.match(stat)
        bucket_pattern = 2
        if mb == None:
            mb = bucket_stat_1_regex.match(stat)
            bucket_pattern = 1
        if mb != None:
            # This could be a bucket stat
            if (i < (len(stats) - 1)) and bucket_regex.match(stats[i+1][STATS_LINES]):
                if (_debug & 256) != 0:
                    print "Matched bucket_stat_%d_regex: [%d] '%s', mb is '%s'" % (
                        bucket_pattern, i, stat, mb.groups())
                    print "Matched bucket regex: [%d] '%s'" % (
                        i+1, stats[i+1][STATS_LINES] )
                data = get_bucket_stat(stats, statname, i);
                if data != None:
                    result.append(dict(key=mb.group('key').strip(), val=data))
                    stats[i][STATS_VALUE] += 1
                    if (_debug & 256) != 0:
                        print "Increment [%d] '%s' from %d to %d" % \
                              ( i, stat, (stats[i][STATS_VALUE] - 1), stats[i][STATS_VALUE] )
                elif (_debug & 256) != 0:
                    print "Matched bucket regex, but not a bucket stat:" \
                          " [%d] '%s'" % ( i, stat )
            elif (_debug & 256) != 0:
                print "Neither a stat nor a bucket stat: [%d] '%s'" % ( i, stat )
                if i < (len(stats) - 1):
                    print "Did not match bucket regex: [%d] %s" % (
                        i+1, stats[i+1][STATS_LINES] )
        elif (_debug & 256) != 0:
            print "Did not match either bucket stat regex: [%d] %s" % (
                i, stat )
        if (_debug & 256) != 0:
            print ""
    if (_debug & 256) != 0:
        if return_type in [ STR, BKT ]:
            print "result", result
    if len(result) == 0:
        if quiet:
            pass
        elif return_type == BKT:
            print "BKT stat not found:", statname
        else:
            print "Stat not found:", statname
        return None

    if return_type == INT:
        result = int(result[0]['val'])
    elif return_type == STR:
        result = result[0]['val']
    elif return_type == FLOAT:
        result = float(result[0]['val'])
    elif return_type == DICT:
        result = result[0]
    elif return_type == LIST_INT:
        result = [int(x['val']) for x in result]
    elif return_type == LIST_FLOAT:
        result = [float(x['val']) for x in result]
    elif return_type == LIST_STR:
        result = [(x['val']) for x in result]
    elif return_type == KEYS:
        result = [(x['key']) for x in result]
    elif return_type == KEY_ENUM:
        result = extract(result, statname)
    elif return_type == BKT:
        result = result[0]['val']

    if (_debug & 256) != 0:
        print "get_stat returns:", str(result)
        print ""

    return result

def log_unused_stats(stats, index):
    global _debug                   # In
    global bucket_regex             # In
    global STATS_LINES              # In
    global STATS_VALUE              # In
    # Derived from dump_raw()
    str =  "<div id=\"rawstats%d-nav\" class=\"listNav\"></div>" % index
    str += "<ul id=\"rawstats%d\">" % index
    pattern = "^(?P<key>\S+( \S+)*)  +(?P<value>\S+( \S+)*)"
    regex = re.compile(pattern)
    num_unused = 0
    for i in xrange(0, len(stats)):
        stat_entry = stats[i]
        if stat_entry[STATS_VALUE] > 0:
            continue
        stat = stat_entry[STATS_LINES]
        m = regex.match(stat)
        if m != None:
            # This could be a bucket stat
            if (i < (len(stats) - 1)) and bucket_regex.match(stats[i+1][STATS_LINES]):
                # neglect bucket stat
                while bucket_regex.match(stats[i+1][STATS_LINES]):
                    i += 1
                # Skip /average and /aggregate
                i += 2
            else:
                str += ( "<li>%s</li>" % m.group('key').strip()[1:] )
                num_unused += 1
    str += '</ul>'
    
    str += ( "<script>$('#rawstats%d').listnav({initLetter: 'a'});</script>" %
             index )
    
    ui_output(str)

    if (_debug & 256) != 0:
        print "%d. Unused: %d out of %d" % ( index, num_unused, len(stats) )

def unused_debug():
    global _cmd_options_set
    global CMD_OPTION_CORE
    global CMD_OPTION_EDGE
    global STATS_LINES
    if (_cmd_options_set & CMD_OPTION_EDGE) != 0:
        if len(_edgestats) > 0:
            ui_subsection("EDGE")
            log_unused_stats(_edgestats[-1][STATS_LINES], 3)
    if (_cmd_options_set & CMD_OPTION_CORE) != 0:
        if len(_corestats) > 0:
            ui_subsection("CORE")
            log_unused_stats(_corestats[-1][STATS_LINES], 4)

#------------------------------------------------------------------------------
# Bucket stat functions

# Resolve bucket stat
def get_bucket_stat(stats, statname, index):
    global _debug                   # In
    global STATS_LINES              # In
    global STATS_VALUE              # In
    index += 1
    #      1 : 0
    pattern_bkt = "^\s*(?P<bucket>\d+) : (?P<count>\S+( \S+)*)"
    regex_bkt = re.compile(pattern_bkt)
    #  max: 69071 pages
    pattern_max = "^\s*max: (?P<max>[.\d]+) (?P<units>\S+( \S+)*)"
    regex_max = re.compile(pattern_max)
    #      Aggregate : 5356703 pages. Avg size : 22697.9
    pattern_agg_avg = "^\s*Aggregate : (?P<aggregate>[\d]+) (\S+( \S+)*). Avg size : (?P<avg>[-+eE.\d]+)"
    regex_agg_avg = re.compile(pattern_agg_avg)
    #/disk/0/stats/RW Seeks/aggregate 11011164
    pattern_aggregate = "^(?P<key>%s/aggregate) (?P<value>\S+( \S+)*)" % \
                        statname.replace("*", "\S+( \S+)*")
    regex_aggregate = re.compile(pattern_aggregate)
    #/disk/0/stats/RW Seeks/average 22697.9
    pattern_average = "^(?P<key>%s/average) (?P<value>\S+( \S+)*)" % \
                      statname.replace("*", "\S+( \S+)*")
    regex_average = re.compile(pattern_average)
    #/disk/0/stats/RW Seeks/nupdates 236
    pattern_nupdates = "^(?P<key>%s/nupdates) (?P<value>\S+( \S+)*)" % \
                       statname.replace("*", "\S+( \S+)*")
    regex_nupdates = re.compile(pattern_nupdates)
    bdivs = get_bucket_divisions()
    bstats = [0]*get_bucket_count()
    max = 0
    agg = 0
    avg = 0
    nup = 0
    unit = ""
    while True:
        s = stats[index][STATS_LINES]
        stats[index][STATS_VALUE] += 1
        if (_debug & 256) != 0:
            print "Increment %d. '%s' from %d to %d" % \
                  ( index, s, (stats[index][STATS_VALUE] - 1), stats[index][STATS_VALUE] )
        index += 1
        m = regex_bkt.match(s)
        if None != m:
            # find bucket for stat
            for j in range(0, len(bdivs)):
                if bdivs[j] == m.group('count').strip():
                    bstats[j] = int(m.group('bucket'))
                    if (_debug & 256) != 0:
                        print "[%d] BKT %s: Found bucket %s: %s" % \
                              ( ( index - 1), statname, bdivs[j], s )
                    break;
            continue
        m = regex_max.match(s)
        if None != m:
            max = int(m.group('max'))
            unit = m.group('units').strip()
            if (_debug & 256) != 0:
                print "[%d] BKT %s: Found max: %s" % \
                      ( ( index - 1), statname, s )
            continue
        m = regex_agg_avg.match(s)
        if None != m:
            agg = int(m.group('aggregate'))
            avg = float(m.group('avg'))
            if (_debug & 256) != 0:
                print "[%d] BKT %s: Found avg: %s" % \
                      ( ( index - 1), statname, s )
            continue
        m = regex_aggregate.match(s)
        if None != m:
            if (_debug & 256) != 0:
                print "[%d] BKT %s: Found /aggregate: %s" % \
                      ( ( index - 1), statname, s )
            agg = int(m.group('value'))
            continue
        m = regex_average.match(s)
        if None != m:
            if (_debug & 256) != 0:
                print "[%d] BKT %s: Found /average: %s" % \
                      ( ( index - 1), statname, s )
            avg = float(m.group('value'))
            continue
        m = regex_nupdates.match(s)
        if None != m:
            if (_debug & 256) != 0:
                print "[%d] BKT %s: Found /nupdates: %s" % \
                      ( ( index - 1), statname, s )
            nup = int(m.group('value'))
            break
        if (_debug & 256) != 0:
            print "[%d] BKT %s: Did not find: %s" % ( (index - 1), statname, s)
        raise Exception("Could not parse bucket stats")

    return dict(data=bstats, max=max, aggregate=agg, avg=avg, nupdates=nup,
                unit=unit)

# Bucket divisions (from rbt/misc/bucketstats.h)
def get_buckets():
    # Buckets 0..32 count
    # n in [0], [1], [2], [3,4], [5,8], ..., [2^29+1,2^30], [2^30+1,inf)
    buckets = [[0,0], [1,1], [2,2]]
    for i in range(3, get_bucket_count()):
        buckets.append([(1 << (i-2)) + 1, 1 << (i - 1)])

    return buckets

def get_bucket_divisions():
    buckets = get_buckets()
    divs = ["0", "1", "2"]
    for i in range(3, len(buckets)):
        n = buckets[i][0];
        m = buckets[i][1];
        divs.append("%s-%s" % (to_unit(n), to_unit(m)))

    return divs

# Which bucket contains value?
def get_bucket_index(value):
    buckets = get_buckets()
    for idx, bucket in enumerate(buckets):
        if (bucket[0] <= value) and (value <= bucket[1]):
            return idx
    return len(buckets) - 1

def get_bucket_from_index(index):
    buckets = get_buckets()
    return buckets[index]

def to_unit(n):
    c = ""
    if n >= (1 << 30):
        n >>= 30
        c = 'G'
    elif n >= (1 << 20):
        n >>= 20
        c = 'M'
    elif n >= (1 << 10):
        n >>= 10
        c = 'K'

    return "%d%s" % (n, c)

def get_bucket_count():
    # from rbt/misc/bucketstats.h
    return 33

#------------------------------------------------------------------------------
# Get statistics set functions
# Get statistics set from a file.
# Returns [ ( statistics set, timestamp ), ... ]
# If log_time == None, Return the last value of each statistic in the file.
# Otherwise, file contains /var/log/dc.stats or /var/log/edge.stats.
# Return the statistics set at time log_time.
#Rdisk Stats at ---- ----Mon Mar 05 18:27:31 2012
pattern_any_time = r'^Rdisk Stats at ---- ----(?P<value>.*)$'
regex_any_time = re.compile(pattern_any_time)
pattern_not_in_bucket = "^/"
regex_not_in_bucket = re.compile(pattern_not_in_bucket)
pattern_in_bucket = "^[ 0-9]"
regex_in_bucket = re.compile(pattern_in_bucket)
pattern_statlog = r"^\s+Dumping\s+\S+\s+Stats\s*$"
regex_statlog = re.compile(pattern_statlog)
pattern_not_in_bucket = "^/"
regex_not_in_bucket = re.compile(pattern_not_in_bucket)
def get_stats_from_file(file, log_time=None):
    global _debug                   # In
    if (_debug & 256) != 0:
        print "get_stats_from_file: file='%s' log_time='%s'" \
                  % (str(file), str(log_time) )
    global regex_not_in_bucket      # In
    global bucket_regex             # In
    global regex_any_time           # In
    global regex_set_start          # In
    global regex_statlog            # In
    results = [ ]
    result = ""
    timestamp = None
    fd = open(file, "r")
    if fd == None:
        print "Warning: Could not open file for reading: %s" % file
        assert type(result) == type(""), "Invalid type"
        return results
    line_number = 0
    stat_set_number = 0
    if log_time:
        pattern_log_time = log_time.split()
        pattern_log_time = "\s+".join(pattern_log_time)
        pattern_log_time = ( r'^Rdisk Stats at ---- ----.*(?P<value>%s)$' %
                             pattern_log_time )
        regex_log_time = re.compile(pattern_log_time)
        if (_debug & 256) != 0:
            print "get_stats_from_file: file='%s' log_time='%s' pattern='%s'" \
                  % (file, log_time, pattern_log_time )
    first_stat_found = False
    log_time_found = False
    for one_line in fd:
        line_number += 1
        one_line = one_line.rstrip(" \t\n\r")
        # Skip short lines
        if len(one_line) < 1:
            if (_debug & 256) != 0:
                print "get_stats_from_file", \
                      "Skipping short line", file, line_number, one_line
            continue
        # Skip heading lines from stat_logger.cc
        if regex_statlog.match(one_line):
            if (_debug & 256) != 0:
                print "get_stats_from_file", \
                      "Skipping stat_logger heading", \
                      file, line_number, one_line
            continue
        # Count statistics sets
        m = regex_any_time.match(one_line)
        if m != None:
            if (_debug & 256) != 0:
                print ("get_stats_from_file: Found stat"
                       " groups '%s', file '%s' %d '%s'" %
                       ( str(m.groups()), file, line_number, one_line ) )
            stat_set_number += 1
            if (not log_time) and (stat_set_number > 1):
                print "Warning: Read whole file and" \
                      " file contains more than one statistics set"
                break
        # Skip lines before log_time
        if log_time and (not log_time_found):
            if regex_log_time.match(one_line):
                if (_debug & 256) != 0:
                    print ("get_stats_from_file: Found log_time"
                           " groups '%s', file '%s' %d '%s'" %
                           ( str(m.groups()), file, line_number, one_line ) )
                log_time_found = True
                timestamp = m.group('value').strip()
            continue
        # Statistics group after log_time?
        if log_time and log_time_found and regex_any_time.match(one_line):
            if (_debug & 256) != 0:
                print "get_stats_from_file", \
                      "Found after log_time", file, line_number, one_line
            results.append( ( result, timestamp ) )
            result = ""
            first_stat_found = False
            if log_time != ".*":
                break
            else:
                timestamp = m.group('value').strip()
                continue
        # Skip non-statistics lines
        if regex_not_in_bucket.match(one_line):
            first_stat_found = True
        elif first_stat_found and bucket_regex.match(one_line):
            pass
        else:
            if (_debug & 256) != 0:
                print "get_stats_from_file", \
                      "Skipping", file, line_number, one_line
            continue
        # Found a statistics line
        result += one_line + "\r"
        if (_debug & 256) != 0:
            print "get_stats_from_file", file, line_number, one_line
        if one_line.endswith("cmd>"):
            break
    fd.close()
    if result.endswith("cmd>"):
        result = result[:-4]
    if result != "":
        results.append( ( result, timestamp ) )
    assert type(results) == type([""]), "Invalid type"
    return results

# Parse log_file:Log_time.  Returns log_file, log_time
def parse_log_file_time(file_time, default_log_file):
    colon_idx = file_time.find(":")
    if colon_idx == -1:
        return default_log_file, file_time # No log_file
    elif colon_idx == 0:
        return default_log_file, file_time[colon_idx + 1:] # No log_file
    else:
        return file_time[0:colon_idx], file_time[colon_idx + 1:] # Both

# Save stats to a file to be re-used in a later run
# Returns None if failed, or time stamp if success
def save_stats_to_file(stats, file, time_str):
    global _debug                   # In
    result = ""
    fd = open(file, "a")
    if fd == None:
        print "Warning: Could not open file for appending: %s" % file
        return None
    if (_debug & 256) != 0:
        print "save_stats_to_file", time_str
    fd.write("Rdisk Stats at ---- ----%s\n" % time_str)
    if stats != None:
        lines = stats.splitlines()
        line_number = 0
        for line in lines:
            line_number += 1
            line = line.rstrip(" \r\n")
            if (_debug & 256) != 0:
                print "save_stats_to_file", line_number, line
            fd.write(line + "\n")
    else:
        print "Warning: No statistics to write to file: ", file
    fd.close()
    assert type(time_str) == type(""), "Invalid type"
    return time_str                     # OK

#------------------------------------------------------------------------------
# Miscellaneous functions

def unique_count(vals):
    set = {}
    map(set.__setitem__, vals, [])
    return len(set.keys())

# Print usage
def usage():
    print "Usage: %s [-e [IP|IP:Port]|-E [file|file:time|:time]]" \
          " [-c [IP|IP:Port]|-C [file|file:time|:time]] <options>" % \
          sys.argv[0]
    print " EDGE options"
    print "    -e EDGE ip_port"
    print '    -E file containing EDGE output of rbcmd -s "*" port,'
    print "       file containing EDGE's /var/log/edge.stats:time, or :time"
    print " CORE options"
    print "    -c CORE ip_port"
    print '    -C file containing CORE output of rbcmd -s "*" port,'
    print "       file containing CORE's /var/log/dc.stats:time, or :time"
    print ""
    print "Notes:"
    print "* Must specify either an EDGE option, a CORE option," \
          " or both an EDGE option and a CORE option."
    print "* May specify more than one EDGE option."
    print "* May specify more than one CORE option."
    print "* ip_port, core_ip_port, edge_ip_port can be any of the following:"
    print "  * Access via ssh (Use in-house, Requires root access to CORE/EDGE)"
    print "    username@IP - IP or DNS"
    print "    username defaults to admin" \
        " if not specified. In this case leave off the @."
    print "  * Access via socket (Use in-house, Requires VLAB license)"
    print "    IP:Port or IP: - IP or DNS:Port for comamnd server"
    print "    Port defaults to 7980 if not specified."
    print "  * Access via ssh then socket (Use in the field)"
    print "    username@ssh-IP:command-server-IP:Port"
    print "    username defaults to admin" \
        " if not specified. In this case leave off the @."
    print "    ssh-IP is IP or DNS"
    print "    command-server-IP is only IP"
    print "    command-server-IP defaults to ssh-IP if not specified." \
        " In this case ssh-IP must not contain username and must be" \
        " IP, not DNS."
    print "    Port defaults to 7980 if not specified."
    print ""
    print " options:"
    print "    -A - Do not analyze statistics."
    print "         Used to get statistics without analyzing or graphing."
    print "    -T - edge_ssh_password - Password for ssh only EDGE." \
        " Not needed for access via socket. Default: None."
    print "    -U - core_ssh_password - Password for ssh only CORE." \
        " Not needed for access via socket. Default: None."
    print "    -S - ssh_password - Password for ssh both CORE and EDGE." \
        " Not needed for access via socket. Default: None."
    print "    -g core_stats - Graph CORE statistics core_stats" \
          " (Default do not graph)"
    print "    -o file - Save analysis output to file file.html" \
          " (Default result.html)"
    print "    -r edge_stats - Graph EDGE statistics edge_stats" \
          " (Default do not graph)"
    print "    -s prefix - save stats obtained from EDGE or CORE" \
          " (default: don't save)"
    print "       EDGE stats are saved to prefixedge.log"
    print "       CORE stats are saved to prefixcore.log"
    print "    -v verbosity level - Which statistics to print (default 0)"
    print "       0 = Only statistics with diagnostic messages"
    print "       1 = All performance statistics"
    print "           Omits stats which are for only functional debugging."
    print "       2 = All statistics, both performance and functional"
    print "    -x file - Evaluate python file file before processing" \
          " (default: No file evaluated)"
    print "              Typically this is used to change limits which" \
          " are test dependent."
    print "    -G file - Save graph to file file.html" \
          " (Default stats_graph.core or .edge)"
    print "    -O option_level - A bit mask (default 0)"
    print "       0x0001 =     1 - Log all stats"
    print "                      - Without: Log stats only if out of limits"
    print "       0x0002 =     2 - Log both stat values and stat differences"
    print "                      - Without: Log stat values in first stats" \
          " set, stat differences in others"
    print "       0x0004 =     4 - Log all statistics sets"
    print "                     - Without: Log only last statistics set"
    print "       0x0008 =     8 - Log statistics not used by this script" \
          " (For debugging the script)"
    print "       0x0010 =    16 - Log stat_path instead of stat_description"
    print "       0x0020 =    32 - Log full stat_path instead of" \
          " stat_description"
    print "       0x0040 =    64 - Debug output: ui_log"
    print "       0x0080 =   128 - Debug output: Other ui"
    print "       0x0100 =   256 - Debug output: main or routines"
    print "       0x0200 =   512 - Debug output: hinter"
    print "       0x0400 =  1024 - Debug output: iscsi"
    print "       0x0800 =  2048 - Debug output: prefetch - Basic"
    print "       0x1000 =  4096 - Debug output: prefetch - Verbose"
    print "       0x2000 =  8192 - Debug output: prefetch" \
          " - Log found BKT stats"
    print "       0x4000 = 16384 - Debug output: graph statistics"
    print "    -I Skip iscsi - Due to a bug in this script."

def ASSERT(msg):
    print msg
    sys.exit(-1)

def DIE(msg):
    print "FATAL: %s" % msg
    sys.exit(-1)
#!/usr/bin/env python
#
# -*- python -*-
#
# (C) Copyright 2003-2009 Riverbed Technology, Inc.
# All rights reserved. Confidential.
#
"""rvbd_cmd - Classes related to invoking commands on VA"""
#------------------------------------------------------------------------------
# NOTE: How to debug vadebug with the python debugger.
# python
# import pdb
# import rvbd_cmd
# from rvbd_cmd import *
# # Replace the string below with the command line parameters
# sys.argv.extend("shell ls 10.1.36.211".split())
# sys.argv[0] = "./rvbd_cmd.py"
# pdb.Pdb().run("rvbd_cmd._rvbd_cmd_main()")
#------------------------------------------------------------------------------
import fcntl, os, re, sys, time
from optparse import OptionParser

try :
    import paramiko
except ImportErrror:
    print "Can not import parmiko.  Get and install it as below:"
    print " wget http://apt.sw.be/redhat/el4/en/i386/rpmforge/RPMS" \
          "/python-paramiko-1.7.6-1.el4.rf.noarch.rpm"
    print " wget http://apt.sw.be/redhat/el4/en/i386/rpmforge/RPMS" \
          "/rpmforge-release-0.5.2-2.el4.rf.i386.rpm"
    print " rpm -Uvh rpmforge-release-0.5.2-2.el4.rf.i386.rpm"
    print " yum install python-paramiko-1.7.6-1.el4.rf.noarch.rpm"
    raise ImportError

from socket import *

#------------------------------------------------------------------------------
# Uncomment one of each of these.

# Select the second to debug rvbd_cmd.py called from io_analyzer.sh.
_debug = 0                              # -O Debug option setting
#_debug = 256

# Of .read and .recv
#_size=1
#_size=256
_size=4096

def _report_config():
    global _debug
    global _size
    print >>sys.stderr, \
          "CONFIG: _debug=%d, _size=%d" % (_debug, _size)

#------------------------------------------------------------------------------
# Regular expressions to recogninze the various VA shell prompts
_prompt_command_server = "(cmd> ?|cmdsvr> ?)"

_prompt_shell = "\\[[^\\]\n]+ [^\\]\n]+\\]# ?"
_prompt_cli_basic = "\\S+ > ?"
_prompt_cli_enable = "\\S+ # ?"
_prompt_cli_config = "\\S+ \\(config\\) # ?"

# Combinations
_prompt_cli_any = "(%s|%s|%s)" % (
    _prompt_cli_basic, _prompt_cli_enable, _prompt_cli_config )
_prompt_shell_or_cli = "(%s|%s|%s|%s)" % (
    _prompt_shell, _prompt_cli_basic, _prompt_cli_enable, _prompt_cli_config )
_prompt_command_server_or_cli = "(%s|%s|%s|%s)" % (
    _prompt_command_server, _prompt_cli_basic, _prompt_cli_enable,
    _prompt_cli_config )
_prompt_any = "(%s|%s|%s|%s|%s)" % (
    _prompt_shell, _prompt_cli_basic, _prompt_cli_enable, _prompt_cli_config,
    _prompt_command_server )

#------------------------------------------------------------------------------
# Perform a command-server command
def _recv_from_net(sock, prompt=_prompt_any, remove_prompt=True,
                   recvsize=_size):
    global _debug                   # In
    global _prompt_command_server
    if (_debug & 256) != 0:
        print >>sys.stderr, \
        "_recv_from_net(sock=%s, prompt='%s', remove_promt=%s, recvsize=%d)" %(
            sock, prompt, remove_prompt, recvsize)
    if prompt != None:
        pattern = "(" + prompt + ")$"
        regex = re.compile(pattern, re.DOTALL)
        if (_debug & 256) != 0:
            print >>sys.stderr, "_recv_from_net: pattern is '%s'" % pattern
    result = ""
    times_zero = 0
    while True:
        if (_debug & 256) != 0:
            len_result = len(result)
            if len_result > 256:
                print >>sys.stderr, \
                      "_recv_from_net: Got %d, Receiving %d, Have %d" % (
                    len_buf, recvsize, len_result)

            elif len_result > 0:
                print >>sys.stderr, \
                      "_recv_from_net: Got %d, Receiving %d, Have %d '%s'" % (
                    len_buf, recvsize, len_result, result )
            else:
                print >>sys.stderr, \
                      "_recv_from_net: Receiving %d, Have %d '%s'" % (
                    recvsize, len_result, result )
        buf = sock.recv(recvsize)
        len_buf = len(buf)
        if len_buf == 0:
            times_zero += 1
            if (_debug & 256) != 0:
                print >>sys.stderr, \
                      "_recv_from_net: Got 0 for %d times, so far %d '%s'" % (
                    times_zero, len_result, result )
            if times_zero == 5:
                break
            else:
                continue
        result += buf
        if (_debug & 256) != 0:
            len_result = len(result)
            if len_result <= 256:
                print >>sys.stderr, \
                      "_recv_from_net: Got %d '%s', so far %d '%s'" % (
                    len_buf, buf, len_result, result )
            else:
                print >>sys.stderr, \
                      "_recv_from_net: Got %d '%s', so far %d" % (
                    len_buf, buf, len_result)
        if prompt != None:
            if len_buf >= 100:
                to_search = buf
            else:
                to_search = result
            if regex.search(to_search):
                if (_debug & 256) != 0:
                    print >>sys.stderr, "_recv_from_net: Matched prompt"
                break
    if (prompt != None) and remove_prompt:
        m = regex.search(result)
        if m:
            prompt = m.group(1)
            len_result = len(result) - len(prompt)
            result = result[0:len_result]
            if (_debug & 256) != 0:
                print >>sys.stderr, \
                      "_recv_from_net: Removed prompt: '%s' leaving '%s'" % (
                    prompt, result)
    assert type(result) == type(""), "Invalid type"
    if (_debug & 256) != 0:
        print >>sys.stderr, \
              "_recv_from_net: Returned %d '%s', remove_prompt:%s" % (
            len(result), result, remove_prompt)
    return result

# Perform a command-server command
def do_net_cmd(cmd, sock, remove_prompt=True, recvsize=_size):
    """Perform a command-server command to socket SOCK."""
    global _debug                   # In
    global _prompt_command_server
    if (_debug & 256) != 0:
        print >>sys.stderr, \
              "do_net_cmd(cmd='%s', sock=%s, remove_prompt=%s, recvsize=%d)" %(
            cmd, sock, remove_prompt, recvsize)
    sock.send(cmd + "\n")
#    print >>sys.stderr, "Sleeping...  For command via socket to execute" # New
#    time.sleep(2)
    result = _recv_from_net(sock, _prompt_command_server, remove_prompt,
                            recvsize)
    return result

def _open_socket(msg, ip, port, timeout=100):
    global _debug                   # In
    sock = socket(AF_INET, SOCK_STREAM)
    err = sock.connect_ex((ip, int(port)))
    if err != 0:
        print >>sys.stderr, "Could not telnet to %s: %s:%s" % (
            msg, ip, port)
        return None
    sock.settimeout(timeout)
    if (_debug & 256) != 0:
        print >>sys.stderr, \
              "Opened socket %s: %s:%s timeout %s returned '%s'" % (
            msg, ip, port, timeout, sock)
    print >>sys.stderr, "Sleeping...  For socket opened" # Old
    time.sleep(2)
    return sock

def open_socket_for_command_server(msg, ip, port=7980,
                                   timeout=100, recvsize=_size):
    global _debug                   # In
    sock = _open_socket(msg, ip, port, timeout)
    if sock != None:
        if (_debug & 256) != 0:
            print >>sys.stderr, \
                  "open_socket_for_command_server: Receiving %d" % recvsize
        buf = sock.recv(recvsize)
        if (_debug & 256) != 0:
            print >>sys.stderr, \
                  "open_socket_for_command_server: Got %d '%s'" % (
                len(buf), buf)
        if (not buf.endswith("cmd> ")) and (not buf.endswith("cmdsvr> ")):
            print >>sys.stderr, \
                  "Wrong greeting from %s command server: %s" % (msg, buf)
            if (_debug & 256) != 0:
                print >>sys.stderr, "Closing socket '%s'" % sock
            sock.close()
            sock = None
    return sock

#------------------------------------------------------------------------------
def _do_ssh_cmd_with_prompt(cmd, files, prompt=_prompt_any, remove_prompt=True,
                            close_files=False, recvsize=_size):
    """Perform a shell, command-server, or cli command via ssh via paramiko."""
    global _debug                   # In
    if (_debug & 256) != 0:
        print >>sys.stderr, \
              "do_ssh_cmd_via_paramiko(cmd='%s', files='%s', prompt='%s'," \
              " remove_prompt=%s, recvsize=%d)" % (
            cmd, files, prompt, remove_prompt, recvsize)
    tty = files.get('tty', None)
    if tty == None:
        return None
    tty.send(cmd + "\n")
    if close_files:
        tty.shutdown_read();
#   print >>sys.stderr, "Sleeping... For command via paramiko to execute" # New
#   time.sleep(2)
    result = _recv_from_net(tty, prompt, remove_prompt, recvsize)
    if close_files:
        close_ssh(files)
    return result
    
#------------------------------------------------------------------------------
def _spawn_ssh_paramiko(ssh_ip, login=None, password="",
                        bufsize=4096, timeout=100):
    """Spawn ssh (via paramiko) and return FILES object for the above."""
    global _debug
    if (_debug & 256) != 0:
        print >>sys.stderr, \
              "_spawn_ssh_paramiko(ssh_ip='%s', login='%s', len(password)=%d," \
              " bufsize=%d, timeout=%d)" % (
            ssh_ip, login, len(password), bufsize, timeout)
    client = paramiko.SSHClient()
    client.load_system_host_keys()

    except1 = None
    try :
        client.connect(ssh_ip, username=login, password=password,
                       timeout=timeout)
    except paramiko.BadHostKeyException, except1:
        print >>sys.stderr, \
              "Bad Host Key(%s): Could not connect to ssh at %s@%s" % (
            except1, login, ssh_ip)
        return None
    except paramiko.AuthenticationException, except1:
        print >>sys.stderr, \
              "Authentication error(%s): Could not connect to ssh at %s@%s" % (
            except1, login, ssh_ip)
        return None
    except paramiko.SSHException, except1:
        print >>sys.stderr, \
              "SSH error(%s): Could not connect to ssh at %s@%s" % (
            except1, login, ssh_ip)
        return None
    except socket.error, except1:
        print >>sys.stderr, \
              "Socket error(%s): Could not connect to ssh at %s@%s" % (
            except1, login, ssh_ip)
        return None

    try :
        tty = client.invoke_shell()
    except paramiko.SSHException, except1:
        print >>sys.stderr, \
              "SSH error(%s): Could not invoke shell on %s@%s" % (
            except1, login, ssh_ip)
        client.close()
        return None
        
    result = { 'client': client, 'bufsize': bufsize, 'tty': tty }
    return result

def spawn_ssh(ssh_ip, login=None, password="",
              bufsize=4096, timeout=100):
    global _debug
    global _prompt_any
    # Open ssh connection
    files = _spawn_ssh_paramiko(ssh_ip, login, password, bufsize, timeout)
    if files == None:
        print >>sys.stderr, \
              "Failed: spawn_ssh to '%s', login='%s', len(password)=%d," \
              " bufsize=%d, timeout=%d" % (
            ssh_ip, login, len(password), bufsize, timeout)
        return None
    tty = files.get('tty', None)
    if tty == None:
        files.close()
        return files
    print >>sys.stderr, "Sleeping...  For ssh connection to initialize" # Old
    time.sleep(2)
    # Read prompt of ssh connection
    output = _recv_from_net(tty, prompt=_prompt_any,
                            remove_prompt=False, recvsize=bufsize)
    if (_debug & 256) != 0:
        print >>sys.stderr, \
              "spawn_ssh read after connection returned '%s'" % output
    return files

def close_ssh(files):
    """Close files FILES returned by spawn_ssh."""
    global _debug
    if (_debug & 256) != 0:
        print >>sys.stderr, "close_ssh(files='%s')" % files
    if files == None:
        return
    client = files.get('client', None)
    if client == None:
        return
    tty = files.get('tty', None)
    if tty != None:
        tty.shutdown(2);
        if (_debug & 256) != 0:
            print >>sys.stderr, "close_ssh: Shutdown tty"
        del(files['tty'])
    client.close()
    if (_debug & 256) != 0:
        print >>sys.stderr, "close_ssh: Closed client"
    del(files['client'])

#------------------------------------------------------------------------------
def _open_cli(files):
    """Prepare files FILES for a cli configure terminal command."""
    global _debug
    global _prompt_any
    global _prompt_command_server
    global _prompt_shell
    global _prompt_cli_basic
    global _prompt_cli_enable
    global _prompt_cli_config
    if (_debug & 256) != 0:
        print >>sys.stderr, "_open_cli: Get prompt"
    output = _do_ssh_cmd_with_prompt(" ", files, _prompt_any, False)
    if (_debug & 256) != 0:
        print >>sys.stderr, "_open_cli: prompt is '%s'" % output
    if re.search(_prompt_cli_config, output):
        if (_debug & 256) != 0:
            print >>sys.stderr, "_open_cli: Already at cli config"
            print >>sys.stderr, "_open_cli returned True"
        return True
    if re.search(_prompt_command_server, output):
        if (_debug & 256) != 0:
            print >>sys.stderr, "_open_cli: Exiting command server"
        output = _do_ssh_cmd_with_prompt("exit", files, _prompt_any, False)
    if re.search(_prompt_shell, output):
        if (_debug & 256) != 0:
            print >>sys.stderr, "_open_cli: Starting cli basic"
        output = _do_ssh_cmd_with_prompt("cli", files, _prompt_any, False)
    if re.search(_prompt_cli_basic, output):
        if (_debug & 256) != 0:
            print >>sys.stderr, "_open_cli: Entering cli enable"
        output = _do_ssh_cmd_with_prompt("enable", files, _prompt_any, False)
    if re.search(_prompt_cli_enable, output):
        if (_debug & 256) != 0:
            print >>sys.stderr, "_open_cli: Entering cli configure"
        output = _do_ssh_cmd_with_prompt("configure terminal",
                                         files, _prompt_any, False)
    if re.search(_prompt_cli_config, output):
        result = True
    else:
        result = False
    if (_debug & 256) != 0:
        print >>sys.stderr, "_open_cli returned %s" % result
    return result
    
def _exit_to_shell(files):
    """Prepare files FILES for a shell command."""
    global _debug
    global _prompt_any
    global _prompt_shell
    global _prompt_command_server_or_cli
    regex_shell = re.compile("(.*)" + _prompt_shell + "$")
    regex_command_server_or_cli = re.compile(
        "(.*)" + _prompt_command_server_or_cli + "$")
    if (_debug & 256) != 0:
        print >>sys.stderr, "_exit_to_shell: Get prompt"
    output = _do_ssh_cmd_with_prompt(" ", files, _prompt_any, False)
    if (_debug & 256) != 0:
        print >>sys.stderr, "_exit_to_shell: prompt is '%s'" % output
    while True:
        if regex_shell.search(output):
            if (_debug & 256) != 0:
                print >>sys.stderr, "_exit_to_shell: At shell"
            result = True
            break
        elif regex_command_server_or_cli.search(output):
            if (_debug & 256) != 0:
                print >>sys.stderr, \
                      "_exit_to_shell: Exiting command-server or shell: '%s'" \
                      % output
            output = _do_ssh_cmd_with_prompt("exit", files, _prompt_any, False)
        else:
            print >>sys.stderr, "_exit_to_shell: Wrong prompt: '%s'" % output
            result = False
            break
    if (_debug & 256) != 0:
        print >>sys.stderr, "_exit_to_shell returned %s" % result
    return result

def _open_command_server(files, port=7980):
    """Prepare files FILES for a command-server command."""
    global _debug
    global _prompt_any
    global _prompt_command_server
    global _prompt_shell
    if (_debug & 256) != 0:
        print >>sys.stderr, "_open_command_server: Get prompt"
    output = _do_ssh_cmd_with_prompt(" ", files, _prompt_any, False)
    if (_debug & 256) != 0:
        print >>sys.stderr, "_open_command_server: prompt is '%s'" % output
    if re.search(_prompt_command_server, output):
        if (_debug & 256) != 0:
            print >>sys.stderr, \
                  "_open_command_server: Already at command-server"
            print >>sys.stderr, \
                  "_open_command_server returned True"
        return True
    if not re.search(_prompt_shell, output):
        if (_debug & 256) != 0:
            print >>sys.stderr, "_open_command_server: Calling _exit_to_shell"
        if not _exit_to_shell(files):
            if (_debug & 256) != 0:
                print >>sys.stderr, "_open_command_server returned False"
            return False
    if (_debug & 256) != 0:
        print >>sys.stderr, "_open_command_server: Starting command-server"
    output = _do_ssh_cmd_with_prompt("rbcmd --port=%d" % port,
                                     files, _prompt_any, False)
    if (_debug & 256) != 0:
        print >>sys.stderr, "_open_command_server: prompt is '%s'" % output
    if re.search(_prompt_command_server, output):
        result = True
    else:
        result = False
    if (_debug & 256) != 0:
        print >>sys.stderr, "_open_command_server returned %s" % result
    return result

#------------------------------------------------------------------------------
def _add_login(ip, login):
    login_ip = ip.split("@")
    len_login_ip = len(login_ip)
    if len_login_ip == 1:
        ip = "%s@%s" % ( login, ip )
    elif len_login_ip != 2:
        print >>sys.stderr, "Invalid login@ip: %s" % ip
    return ip

def _remove_login(ip, login):
    login_ip = ip.split("@")
    len_login_ip = len(login_ip)
    if len_login_ip == 2:
        ip = login_ip[1]
        login = login_ip[0]
    elif len_login_ip != 1:
        print >>sys.stderr, "Invalid login@ip: %s" % ip
    return ip, login

def do_ssh_cmdsvr_cmd(cmd, files, port=7980, remove_prompt=True):
    """Perform a command-server command."""
    global _debug
    global _prompt_command_server
    global _prompt_any
    if (_debug & 256) != 0:
        print >>sys.stderr, "do_ssh_cmdsvr_cmd: Calling _open_command_server"
    # Open the command-server
    if not _open_command_server(files, port):
        if (_debug & 256) != 0:
            print >>sys.stderr, "do_ssh_cmdsvr_cmd returned 'None'"
        return None
    # Execute the command
    result = _do_ssh_cmd_with_prompt(cmd, files,
                                     _prompt_any, # _prompt_command_server???
                                     remove_prompt)
    if (_debug & 256) != 0:
        print >>sys.stderr, "do_ssh_cmdsvr_cmd returned '%s'" % result
    return result

def do_ssh_shell_cmd(cmd, files, remove_prompt=True):
    """Perform a shell command."""
    global _debug
    global _prompt_shell
    global _prompt_any
    if (_debug & 256) != 0:
        print >>sys.stderr, "do_ssh_shell_cmd: Calling _exit_to_shell"
    # Exit to the shell
    if not _exit_to_shell(files):
        if (_debug & 256) != 0:
            print >>sys.stderr, "do_ssh_shell_cmd returned 'None'"
        return None
    # Execute the command
    result = _do_ssh_cmd_with_prompt(cmd, files,
                                     _prompt_any, # _prompt_shell???
                                     remove_prompt)
    if (_debug & 256) != 0:
        print >>sys.stderr, "do_ssh_shell_cmd returned '%s'" % result
    return result

def do_ssh_cli_cmd(cmd, files, remove_prompt=True):
    """Perform a cli configure terminal command."""
    global _debug
    global _prompt_cli_any
    global _prompt_any
    if (_debug & 256) != 0:
        print >>sys.stderr, "do_ssh_cli_cmd: Calling _open_cli"
    # Open the cli
    if not _open_cli(files):
        if (_debug & 256) != 0:
            print >>sys.stderr, "do_ssh_cli_cmd returned 'None'"
        return None
    # Execute the command
    result = _do_ssh_cmd_with_prompt(cmd, files,
                                     _prompt_any, # _prompt_cli_any???
                                     remove_prompt)
    if (_debug & 256) != 0:
        print >>sys.stderr, "do_ssh_cli_cmd returned '%s'" % result
    return result
    
#------------------------------------------------------------------------------
def get_command_server(files):
    """Return 'show command-server' output: (ip, port)"""
    global _debug
    if (_debug & 256) != 0:
        print >>sys.stderr, "get_command_server('%s')" % files
    output = do_ssh_cli_cmd("show command-server", files)
    if output != None:
        pattern = "Command server address+\\s+:\\s+(\\S+)\\s*[\r\n]+" \
                      ".*Command server port\\s+:\\s+([0-9]+)\\s"
        if (_debug & 256) != 0:
            print >>sys.stderr, \
                  "get_command_server: pattern is '%s'" % pattern
        m = re.search(pattern, output, re.DOTALL)
        if m:
            ip = m.group(1)
            port = int(m.group(2))
            if (_debug & 256) != 0:
                print >>sys.stderr, \
                      "get_command_server: Matched pattern: '%s'" % output
        else:
            ip = None
            port = None
            if (_debug & 256) != 0:
                print >>sys.stderr, \
                      "get_command_server: Did not match: '%s'" % output
    else:                               # Could not connect to cli.
        ip = None
        port = None
    if (_debug & 256) != 0:
        print >>sys.stderr, \
              "get_command_server returned: (ip='%s', port=%s)" % (ip, port)
    return (ip, port)

def set_command_server(files, ip, port=7980):
    """Set command-server ip and port"""
    global _debug
    if (_debug & 256) != 0:
        print >>sys.stderr, \
              "set_command_server(files='%s', ip=%s, port=%s)" % (
            files, ip, port)
    if ip == None:
        ip = "0.0.0.0"
        port = 0
    if port == None:
        port = 7980
    command = 'command-server modify ip %s port %s' % (ip, port)
    result = do_ssh_cli_cmd(command, files)
    if (_debug & 256) != 0:
        print >>sys.stderr, "set_command_server returned '%s'" % result
    print >>sys.stderr, "Sleeping...  For command-server to initialize" # Old
    time.sleep(2)
    return result
    
def set_command_server_local(files, port=7980):
    """Set command-server ip local and port"""
    return set_command_server(files, "127.0.0.1", port)
    
def set_command_server_off(files, port=7980):
    """Set command-server ip off and port"""
    return set_command_server(files, "0.0.0.0", port)
    
#------------------------------------------------------------------------------
def do_rbcmd_via_ssh(svr_command, files, svr_port=7980, remove_prompt=True):
    global _debug
    if (_debug & 256) != 0:
        print >>sys.stderr, \
              "do_rbcmd_via_ssh(svr_command='%s', svr_port=%d," \
              " remove_prompt=%s)" %(svr_command, svr_port, remove_prompt)
    # Get and Enable command-server
    if (_debug & 256) != 0:
        print >>sys.stderr, \
              "do_rbcmd_via_ssh: Calling get_command_server"
    original_svr_ip, original_svr_port = get_command_server(files)
    if (_debug & 256) != 0:
        print >>sys.stderr, \
              "do_rbcmd_via_ssh: Calling set_command_server"
    output = set_command_server_local(files, svr_port)
    # Execute svr command
    if (_debug & 256) != 0:
        print >>sys.stderr, \
              "do_rbcmd_via_ssh_and_socket: Calling do_ssh_cmdsvr_cmd"
    result = do_ssh_cmdsvr_cmd(svr_command, files, svr_port, remove_prompt)
    # Restore command-server
    if (_debug & 256) != 0:
        print >>sys.stderr, \
              "do_rbcmd_via_ssh: Calling set_command_server"
    output = set_command_server(files, original_svr_ip, original_svr_port)
    if (_debug & 256) != 0:
        print >>sys.stderr, "do_rbcmd_via_ssh returned '%s'" % result
    return result

def do_rbcmd_via_socket(command, ip, port=7980,
                        timeout=10, remove_prompt=True, msg=""):
    global _debug
    if (_debug & 256) != 0:
        print >>sys.stderr, \
              "do_rbcmd_via_socket(command='%s', port=%d, timeout=%d," \
              " remove_prompt=%s, msg=%s)" %(
            command, port, timeout, remove_prompt, msg)
    sock = open_socket_for_command_server(msg, ip, port, timeout)
    if sock != None:
        if (_debug & 256) != 0:
            print >>sys.stderr, "do_rbcmd_via_socket: Calling do_net_cmd"
        result = do_net_cmd(command, sock, remove_prompt)
        if (_debug & 256) != 0:
            print >>sys.stderr, "Closing socket '%s'" % sock
        sock.close()
    else:
        result = None
    if (_debug & 256) != 0:
        print >>sys.stderr, "do_rbcmd_via_socket returned '%s'" % result
    return result

def do_rbcmd_via_ssh_and_socket(svr_command,
                                ssh_ip, login="admin", password="",
                                svr_ip=None, svr_port=7980,
                                timeout=100, remove_prompt=True, msg=""):
    global _debug
    if (_debug & 256) != 0:
        print >>sys.stderr, \
              "do_rbcmd_via_ssh_and_socket(svr_command='%s', ssh_ip='%s'," \
              " login='%s', svr_ip='%s', svr_port=%d, timeout=%d," \
              " remove_prompt=%s, msg=%s)" %(
            svr_command, ssh_ip, login, svr_ip, svr_port,
            timeout, remove_prompt, msg)
    if svr_ip == None:
        svr_ip = ssh_ip
    # Get and Enable command-server
    files = spawn_ssh(ssh_ip, login, password, timeout=timeout)
    if files == None:
        return None
    if (_debug & 256) != 0:
        print >>sys.stderr, \
              "do_rbcmd_via_ssh_and_socket: Calling get_command_server"
    original_svr_ip, original_svr_port = get_command_server(files)
    if (_debug & 256) != 0:
        print >>sys.stderr, \
              "do_rbcmd_via_ssh_and_socket: Calling set_command_server"
    output = set_command_server(files, svr_ip, svr_port)
    # Execute svr_command
    if (_debug & 256) != 0:
        print >>sys.stderr, \
              "do_rbcmd_via_ssh_and_socket: Calling do_rbcmd_via_socket"
    result = do_rbcmd_via_socket(svr_command, svr_ip, svr_port,
                                 timeout, remove_prompt, msg)
    # Restore command-server
    if (_debug & 256) != 0:
        print >>sys.stderr, \
              "do_rbcmd_via_ssh_and_socket: Calling set_command_server"
    output = set_command_server(files, original_svr_ip, original_svr_port)
    close_ssh(files)
    files = None
    if (_debug & 256) != 0:
        print >>sys.stderr, \
              "do_rbcmd_via_ssh_and_socket returned '%s'" % result
    return result
    
def do_cmd(shell, command, ip_port, login=None, password="",
           command_svr_port=7980, timeout=100, remove_prompt=True, msg=""):
    global _debug
    global _shells
    if (_debug & 256) != 0:
        print "do_cmd(shell=%s, command='%s', ip_port='%s', login='%s'," \
              " len(password)=%d, command_svr_port=%d, timeout=%d," \
              " remove_prompt=%s, msg=%s)" % (
            shell, command, ip_port, login, len(password), command_svr_port,
            timeout, remove_prompt, msg)
        _report_config()
    ip_port_tuple = ip_port.split(":")
    len_ip_port_tuple = len(ip_port_tuple)
    if len_ip_port_tuple == 1:          # ssh to shell - IP or DNS
        if login == None:
            if shell == "cli":
                login = "admin"
            else:
                login = "root"
        ssh_ip = ip_port_tuple[0]
        ssh_ip, login = _remove_login(ssh_ip, login)
        files = spawn_ssh(ssh_ip, login, password, timeout=timeout)
        if files == None:
            return None
        if shell == "shell":
            if (_debug & 256) != 0:
                print >>sys.stderr, \
                      "do_cmd: Calling do_ssh_shell_cmd"
            result = do_ssh_shell_cmd(command, files, remove_prompt)
        elif shell == "cli":
            if (_debug & 256) != 0:
                print >>sys.stderr, \
                      "do_cmd: Calling do_ssh_cli_cmd"
            result = do_ssh_cli_cmd(command, files, remove_prompt)
        elif shell == "rbcmd":
            if (_debug & 256) != 0:
                print >>sys.stderr, \
                      "do_cmd: Calling do_rbcmd_via_ssh"
            result = do_rbcmd_via_ssh(command, files,
                                      command_svr_port, remove_prompt)
        else:
            print >>sys.stderr, "Wrong shell type: %s" % shell
            result = None
        close_ssh(files)
    elif len_ip_port_tuple == 2:        # Command server - IP or DMS, Port
        svr_ip = ip_port_tuple[0]
        svr_port = ip_port_tuple[1]
        if svr_port == "":
            svr_port = command_svr_port
        else:
            svr_port = int(svr_port)
        if shell == "rbcmd":
            if (_debug & 256) != 0:
                print >>sys.stderr, \
                      "do_cmd: Calling do_rbcmd_via_socket"
            result = do_rbcmd_via_socket(command, svr_ip, svr_port,
                                         timeout, remove_prompt, msg)
        else:
            print >>sys.stderr, "Wrong shell type: %s" % shell
            result = None
    # ssh to cli - ssh IP or DNS, Command-server IP, Port
    elif len_ip_port_tuple == 3:
        if login == None:
            if shell == "shell":
                login = "root"
            else:
                login = "admin"
        ssh_ip = ip_port_tuple[0]
        ssh_ip, login = _remove_login(ssh_ip, login)
        svr_ip = ip_port_tuple[1]
        if svr_ip == "":
            svr_ip = ssh_ip
        svr_port = ip_port_tuple[2]
        if svr_port == "":
            svr_port = command_svr_port
        else:
            svr_port = int(svr_port)
        if shell == "shell":
            if (_debug & 256) != 0:
                print >>sys.stderr, \
                      "do_cmd: Calling do_ssh_shell_cmd"
            files = spawn_ssh(ssh_ip, login, password, timeout=timeout)
            if files == None:
                return None
            result = do_ssh_shell_cmd(command, files, remove_prompt)
            close_ssh(files)
        elif shell == "cli":
            if (_debug & 256) != 0:
                print >>sys.stderr, \
                      "do_cmd: Calling do_ssh_cli_cmd"
            files = spawn_ssh(ssh_ip, login, password, timeout=timeout)
            if files == None:
                return None
            result = do_ssh_cli_cmd(command, files, remove_prompt)
            close_ssh(files)
        elif shell == "rbcmd":
            if (_debug & 256) != 0:
                print >>sys.stderr, \
                      "do_cmd: Calling do_rbdcmd_via_ssh_and_socket"
            result = do_rbcmd_via_ssh_and_socket(command, ssh_ip,
                                                 login, password,
                                                 svr_ip, svr_port,
                                                 timeout,
                                                 remove_prompt, msg)
        else:
            print >>sys.stderr, "Wrong shell type: %s" % shell
            result = None
    else:
        result = None                   # Wrong length
    if (_debug & 256) != 0:
        print >>sys.stderr, "do_cmd returned '%s'" % result
    return result

#------------------------------------------------------------------------------
def _test_prompt(prompt_name, prompt, message, value):
    global _debug
#    pattern = "^(((.|\n)+?\n)|)(" + prompt + ")$"
    pattern = "(.*?)(" + prompt + ")$"
    regexp = re.compile(pattern, re.DOTALL)
    if (_debug & 256) != 0:
        print >>sys.stderr, "_test_prompt: pattern is '%s'" % pattern
    if regexp.search(value):
        print "%s - '%s': Matches %s '%s'" % (
            message, value, prompt_name, prompt)
    else:
        print "%s - '%s': Does not match %s" % (message, value, prompt_name)

def _rvbd_cmd_main():
    global _debug
    # Parse parameters
    len_sys_argv = len(sys.argv)
    global _prompt_command_server
    global _prompt_shell
    global _prompt_cli_basic
    global _prompt_cli_enable
    global _prompt_cli_config
    global _prompt_cli_any
    global _prompt_shell_or_cli
    global _prompt_command_server_or_cli
    global _prompt_any
    usage = "Usage:\n" \
            "* Test regexps - %prog message string\n" \
            "* Do command - %prog [options] shell command ip_port" \
            " [password [login [svr_port [timeout [remove_prompt" \
            "[message]]]]]]"
    parser = OptionParser(usage=usage)
    parser.add_option("-q", "--quiet", action="store_true", dest="quiet",
                      help="Do not print result of command.")
    parser.add_option("-O", "--options", type="int", dest="options",
                      default=_debug, help="Options.[default %default]")
    (options, args) = parser.parse_args()

    _debug = options.options

    len_args = len(args)
    if len_args == 2:
        message = args[0]
        value = args[1]
        _test_prompt("command_server", _prompt_command_server,
                     message, value)
        _test_prompt("shell", _prompt_shell, message, value)
        _test_prompt("cli_basic", _prompt_cli_basic, message, value)
        _test_prompt("cli_enable", _prompt_cli_enable,
                     message, value)
        _test_prompt("cli_config", _prompt_cli_config,
                     message, value)
        _test_prompt("cli_any", _prompt_cli_any, message, value)
        _test_prompt("shell_or_cli", _prompt_shell_or_cli,
                     message, value)
        _test_prompt("command_server_or_cli", _prompt_command_server_or_cli,
                     message, value)
        _test_prompt("any", _prompt_any, message, value)
        return 0

    if len_args < 3:
        parser.print_help()
        return -1
    shell = args[0]
    command = args[1]
    ip_port = args[2]
    if len_args >= 4:
        password = args[3]
    else:
        password = ""
    if len_args >= 5:
        login = args[4]
    else:
        login = None
    if len_args >= 6:
        command_svr_port = int(args[5])
    else:
        command_svr_port = 7980
    if len_args >= 7:
        timeout = int(args[6])
    else:
        timeout = 100
    if len_args >= 8:
        remove_prompt = int(args[7])
    else:
        remove_prompt = True
    if len_args >= 9:
        msg = args[8]
    else:
        msg = ""
    if (_debug & 256) != 0:
        print >>sys.stderr, \
              "_rvbd_cmd_main: shell='%s', command='%s', ip_port='%s'," \
              " len(password)=%d, login='%s', command_svr_port=%d," \
              " timeout=%d, remove_prompt=%s, msg='%s'" % (
            shell, command, ip_port, len(password), login, command_svr_port,
            timeout, remove_prompt, msg)
    result = do_cmd(shell, command, ip_port, login, password, command_svr_port,
                    timeout, remove_prompt, msg)
    if (not options.quiet) or ((_debug & 256) != 0):
        print "_rvbd_cmd_main result from '%s' on '%s' is '%s'" % (
            shell, ip_port, result)
    if result == None:
        return -2
    return 0

#------------------------------------------------------------------------------
if (__name__ == "__main__") and sys.argv[0].endswith("rvbd_cmd.py"):
    exit_status = _rvbd_cmd_main()
    sys.exit(exit_status)
# -*- python -*-
#
# (C) Copyright 2003-2009 Riverbed Technology, Inc.  
# All rights reserved. Confidential.
#
import string
# ------------- Prefetch debugging ---------------------------
#------------------------------------------------------------------------------
# For detailed explanation of a descriptor, see the comment at the start of
# prefetch_rules.py.  A brief explanation follows.
#
# A descriptor contains: [0] verbosity, [1] stat_path, [2] description,
# [3] units, [4] type, [5] min, [6] max, [7] min_message, [8] max_message,
# [9] test_func, [10] print_func
#
# If len() == 2: Verbosity [0], ui_title([1])
# If len() == 3: Verbosity [0], ui_log([2], alias + [1])
# If len() >= 5: Get the stat and optionally ui_log() it.  See below.
#
# If type < 0, log the statistic difference.  Use abs(type) for the type.
# This is usually used for unresetable stats.
#
# If type > 0, log the statistic value.
# This is usually used for resetable stats.
#------------------------------------------------------------------------------
# Routines to check types of values for assert()

level_vector = [ 'err', 'warn', 'info', True ]
def is_valid_lvl(lvl):
    global level_vector
    return lvl in level_vector

# Returned by test_value_vs_limits()
def is_returned_by_test_value_vs_limits(result):
    # result[1] is a limit.  This is not checked.
    return ((result == False) or
            ((type(result) == type((1, 2))) and
             (len(result) == 2) and
             is_valid_lvl(result[0])))

# Returned by test_value_vs_minimum() or test_value_vs_maximum()
def is_returned_by_test_value_vs_minimum(result):
    return (result == False) or is_valid_lvl(result)

# Returned by test_bucket_stat_one_key_vs_minimums or vs_maximums()
def is_returned_by_bkt_one_key(result):
    # result[1] is a key.  This is not checked.
    return is_returned_by_test_value_vs_limits(result)

# Returned by a test_func if the stat is not a bucket stat
def is_returned_by_test_func_non_bkt_stat(result):
    return (result == False) or is_valid_lvl(result)

# Returned by a test_func if the stat is a bucket stat
def is_returned_by_test_func_bkt_stat(result):
    return ((result == False) or is_valid_lvl(result) or
            ((type(result) == type((1, 2))) and
             (len(result) == 2) and
             is_valid_lvl(result[0]) and
             (type(result[1]) == type(""))))
            
# Passed to a print func if the stat is not a bucket stat
def is_passed_to_print_func_non_bkt_stat(log):
    return (log != False) and is_returned_by_test_func_non_bkt_stat(log)
            
# Passed to a print func if the stat is a bucket stat
def is_passed_to_print_func_bkt_stat(log):
    return (log != False) and is_returned_by_test_func_bkt_stat(log)

#------------------------------------------------------------------------------
# For writting test_funcs

# Usually used for logging statistics highlighted
# ui_err(), ui_warn(), ui_info(), or ui_log()
def ui_log_info_warn_err(lvl, msg, align = 0):
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> ui_log_info_warn_err:", "lvl", lvl, "msg", msg, \
              "align", align
    assert is_valid_lvl(lvl), "Invalid type"
    if lvl == True:
        ui_log(msg, align)
    elif lvl == 'err':
        ui_err(msg, align)
    elif lvl == 'warn':
        ui_warn(msg, align)
    elif lvl == 'info':
        ui_info(msg, align)
    else:
        print "lvl is invalid:", lvl

message_count = {}
message_count['err'] = 0
message_count['warn'] = 0
message_count['info'] = 0
message_count['err_warn_info'] = 0
# Usually used for logging error/warning messages
# ui_err(), ui_warn(), ui_info(), or not logged.
def ui_info_warn_err(lvl, msg, align = 0, link = False):
    global message_count                # In/Out
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> ui_info_warn_err:", "lvl", lvl, "msg", msg, \
              "align", align
    assert is_valid_lvl(lvl), "Invalid type"
    if lvl != True:                     # Not "display only"
        if (lvl in message_count) and link:
            message_count[lvl] += 1
            message_count['err_warn_info'] += 1
            msg = '<a href="#msg%d" name="msg%d">(Next)</a> %s' % (
                    message_count['err_warn_info'] + 1,
                    message_count['err_warn_info'], msg )
        ui_log_info_warn_err(lvl, msg, align)

# Pass to test_value_vs_limits() to test minimum
# Return False if within limit, return ( level, limit ) if not within limit.
def test_minimum(value, minimum, lvl=True):
    assert is_valid_lvl(lvl), "Invalid type"
    if value < minimum:
        return ( lvl, minimum )
    else:
        return False
        
# Pass to test_value_vs_limits() to test maximum
# Return False if within limit, return ( level, limit ) if not within limit.
def test_maximum(value, maximum, lvl=True):
    assert is_valid_lvl(lvl), "Invalid type"
    if value > maximum:
        return ( lvl, maximum )
    else:
        return False
    
# Test a value versus "err/warn/info/display only" limits
# Return False if within limit(s), otherwise return ( level, limit ).
def test_value_vs_limits(value, limits, comparison_func):
    global _debug
    global level_vector
    if limits == None:
        if (_debug & 4096) != 0:
            print ">>> test_value_vs_limits: returns", False
        return False

    elif type(limits) != type([]):
        # Return whether to "display only"
        result = comparison_func(value, limits, True)
        if (_debug & 4096) != 0:
            print ">>> test_value_vs_limits: returns", result
        assert is_returned_by_test_value_vs_limits(result), "Invalid type"
        return result

    length = min(len(limits), len(level_vector))
    for idx in range(0, length):
        level = level_vector[idx]
        limit = limits[idx]
        if limit == None:
            continue
        result = comparison_func(value, limit, level)
        if result:
            if (_debug & 4096) != 0:
                print ">>> test_value_vs_limits: returns", result
            assert is_returned_by_test_value_vs_limits(result), "Invalid type"
            return result

    if (_debug & 4096) != 0:
        print ">>> test_value_vs_limits: returns", False
    return False

# Test value versus minimum(s)
# Return False if within limit(s),
# return level if not within limit(s)
def test_value_vs_minimums(path_prefix, descriptor,
                           stat_description, value, align,
                           minimums=None,
                           min_message=None):
    if minimums == None:
        minimums = list_get_or_default(descriptor, 5)
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> test_value_vs_minimums", \
              "path_prefix", path_prefix, "stat_path", descriptor[1], \
              "value", value, "align", align, \
              "minimums", minimums, "min_message", min_message

    result = test_value_vs_limits(value, minimums, test_minimum)
    assert is_returned_by_test_value_vs_limits(result), "Invalid type"
    if result:
        if min_message == None:
            min_message = list_get_or_default(descriptor, 7)
        if min_message:
            stat_description = min_message + " " + stat_description

        format = "%s is < minimum, i.e. "
        type_value = type(value)
        if type_value == type(1.0):
            format += "%f"
        elif (type_value == type(1)) or (type_value == type(0L)):
            format += "%d"
        else:
            return False

        limit = result[1]
        if type(limit) == type(1.0):
            format += " < %f"
        else:
            format += " < %d"

        result = result[0]
        ui_info_warn_err(result,
                         format % (stat_description, value, limit),
                         align, True)

    if (_debug & 4096) != 0:
        print ">>> test_value_vs_minimums: returns", result
    assert is_returned_by_test_value_vs_minimum(result), "Invalid type"
    return result

# Test value versus maximum(s)
# Return False if within limit(s),
# return level if not within limit(s)
def test_value_vs_maximums(path_prefix, descriptor,
                           stat_description, value, align,
                           maximums=None,
                           max_message=None):
    if maximums == None:
        maximums = list_get_or_default(descriptor, 6)
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> test_value_vs_maximums", \
              "path_prefix", path_prefix, "stat_path", descriptor[1], \
              "value", value, "align", align, \
              "maximums", maximums, "max_message", max_message

    result = test_value_vs_limits(value, maximums, test_maximum)
    assert is_returned_by_test_value_vs_limits(result), "Invalid type"
    if result:
        if max_message == None:
            max_message = list_get_or_default(descriptor, 8)
        if max_message:
            stat_description = max_message + " " + stat_description

        format = "%s is > maximum, i.e. "
        type_value = type(value)
        if type_value == type(1.0):
            format += "%f"
        elif (type_value == type(1)) or (type_value == type(0L)):
            format += "%d"
        else:
            return False

        limit = result[1]
        if type(limit) == type(1.0):
            format += " > %f"
        else:
            format += " > %d"

        result = result[0]
        ui_info_warn_err(result,
                         format % (stat_description, value, limit),
                         align, True)

    if (_debug & 4096) != 0:
        print ">>> test_value_vs_maximums: returns", result
    assert is_returned_by_test_value_vs_minimum(result), "Invalid type"
    return result

# The normal test behavior for a non-bucket stat.
# Test non-BucketStat versus both minimum(s) and maximum(s)
# Can also be used to test a value versus both minimum(s) and maximum(s)
# Return True if unconditional, i.e. both minimum(s) and maximum(s) are None
# Return False if within limit(s), otherwise return level.
def test_func_non_bucket_stat_vs_min_max(path_prefix, descriptor,
                                         stat_description, stat_value, align,
                                         first_set, last_set):
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> test_func_non_bucket_stat_vs_min_max:", \
              "first_set", first_set, "last_set", last_set, \
              "path_prefix", path_prefix, \
              "stat_path", descriptor[1], "stat_value", stat_value

    minimums = list_get_or_default(descriptor, 5)
    maximums = list_get_or_default(descriptor, 6)

    # Test unconditional
    if (minimums == None) and (maximums == None):
        if (_debug & 4096) != 0:
            print ">>> test_func_non_bucket_stat_vs_min_max:" \
                  " (At start) returns", True
        return True

    if minimums != None:
        min_result = test_value_vs_minimums(path_prefix, descriptor,
                                            stat_description, stat_value,
                                            align, minimums)
        assert is_returned_by_test_value_vs_minimum(min_result), "Invalid type"
        if min_result and (min_result != True):
            if (_debug & 4096) != 0:
                print ">>> test_func_non_bucket_stat_vs_min_max:" \
                      " (After min) returns", min_result
            assert is_returned_by_test_func_non_bkt_stat(min_result), "Invalid type"
            return min_result
    else:
        min_result = False

    if maximums != None:
        max_result = test_value_vs_maximums(path_prefix, descriptor,
                                            stat_description, stat_value,
                                            align, maximums)
        assert is_returned_by_test_value_vs_minimum(max_result), "Invalid type"
        if max_result and (max_result != True):
            if (_debug & 4096) != 0:
                print ">>> test_func_non_bucket_stat_vs_min_max:" \
                      " (After max) returns", max_result
            assert is_returned_by_test_func_non_bkt_stat(max_result), "Invalid type"
            return max_result
    else:
        max_result = False

    result = min_result or max_result
    if (_debug & 4096) != 0:
        print ">>> test_func_non_bucket_stat_vs_min_max: (At end) returns", \
              result
    assert is_returned_by_test_func_non_bkt_stat(result), "Invalid type"
    return result

# Test one key of a BucketStat versus minimum(s)
# Return False if within limit(s),
# return ( level, key ) if not within limit(s) or key not found.
def test_bucket_stat_one_key_vs_minimums(path_prefix, descriptor,
                                         stat_description,
                                         key, stat_value, align,
                                         minimums=None,
                                         min_message=None):
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> test_bucket_stat_one_key_vs_minimums", \
              "path_prefix", path_prefix, "stat_path", descriptor[1], \
              "key", key, "stat_value", stat_value, "align", align, \
              "minimums", minimums, "min_message", min_message
    if key in stat_value:
        value = stat_value[key]
        stat_description += ": %s" % key
        result = test_value_vs_minimums(path_prefix, descriptor,
                                        stat_description, value, align,
                                        minimums, min_message)
        assert is_returned_by_test_value_vs_minimum(result), "Invalid type"
        if result:
            result = ( result, key )
    else:
        ui_warn("BucketStat %s does not have '%s'" % (stat_description, key))
        print "BucketStat %s does not have '%s'" % (stat_description, key)
        result = ( True, key )

    if (_debug & 4096) != 0:
        print ">>> test_bucket_stat_one_key_vs_minimums: returns", result
    assert is_returned_by_bkt_one_key(result), "Invalid type"
    return result

# Test one key of a BucketStat versus maximum(s)
# Return False if within limit(s),
# return ( level, key ) if not within limit(s) or key not found.
def test_bucket_stat_one_key_vs_maximums(path_prefix, descriptor,
                                         stat_description,
                                         key, stat_value, align,
                                         maximums=None,
                                         max_message=None):
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> test_bucket_stat_one_key_vs_maximums", \
              "path_prefix", path_prefix, "stat_path", descriptor[1], \
              "key", key, "stat_value", stat_value, "align", align, \
              "maximums", maximums, "max_message", max_message
    if key in stat_value:
        value = stat_value[key]
        stat_description += ": %s" % key
        result = test_value_vs_maximums(path_prefix, descriptor,
                                        stat_description, value, align,
                                        maximums, max_message)
        assert is_returned_by_test_value_vs_minimum(result), "Invalid type"
        if result:
            result = ( result, key )
    else:
        ui_warn("BucketStat %s does not have '%s'" % (stat_description, key))
        print "BucketStat %s does not have '%s'" % (stat_description, key)
        result = ( True, key )

    if (_debug & 4096) != 0:
        print ">>> test_bucket_stat_one_key_vs_maximums: returns", result
    assert is_returned_by_bkt_one_key(result), "Invalid type"
    return result

# Test key(s) of a BucketStat versus both minimum(s) and maximum(s)
# Return True if unconditional, i.e. both minimum(s) and maximum(s) are None
# Return False if all key(s) within limit(s),
# return ( level, key ) if not within limit(s) or key not found,
# return ( True, key ) if all keys within limit(s) and key should be printed.
def test_bucket_stat_keys_vs_min_max(path_prefix, descriptor,
                                     stat_description, keys, stat_value,
                                     align, first_set, last_set):
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> test_bucket_stat_keys_vs_min_max:", \
              "first_set", first_set, "last_set", last_set, \
              "path_prefix", path_prefix, "stat_path", descriptor[1], \
              "keys", keys, "stat_value", stat_value, "align", align
    minimums = list_get_or_default(descriptor, 5)
    maximums = list_get_or_default(descriptor, 6)

    # Test unconditional
    if (minimums == None) and (maximums == None):
        if (_debug & 4096) != 0:
            print ">>> test_func_non_bucket_stat_vs_min_max:" \
                  " (At start) returns", True
        return True

    result = False
    for key in keys:
        if key not in stat_value:
            ui_warn("BucketStat %s does not have '%s'" %
                    (stat_description, key))
            print "BucketStat %s does not have '%s'" % (stat_description, key)
            result = ( True, key )
            if (_debug & 4096) != 0:
                print ">>> test_bucket_stat_keys_vs_min_max:" \
                      " (Key not found) returns", result
            assert is_returned_by_test_func_bkt_stat(result), "Invalid type"
            return result

        value = stat_value[key]
        value_description = "%s: %s" % ( stat_description, key )
        value_result = test_func_non_bucket_stat_vs_min_max(path_prefix,
                                                            descriptor,
                                                            value_description,
                                                            value, align,
                                                            first_set,
                                                            last_set)
        assert is_returned_by_test_func_non_bkt_stat(value_result), "Invalid type"
        if value_result and (value_result != True):
            result = ( value_result, key )
            if (_debug & 4096) != 0:
                print ">>> test_bucket_stat_keys_vs_min_max:" \
                      " (Inside loop) returns", result
            assert is_returned_by_test_func_bkt_stat(result), "Invalid type"
            return result
        elif (not result) and value_result:
            result = ( True, key )

    if (_debug & 4096) != 0:
        print ">>> test_bucket_stat_keys_vs_min_max: (At end) returns", result
    assert is_returned_by_test_func_bkt_stat(result), "Invalid type"
    return result

# The normal test behavior for a bucket stat.
# Test 'avg' of a BucketStat versus both minimum(s) and maximum(s)
# Return True if unconditional, i.e. both minimum(s) and maximum(s) are None
# Return False if all key(s) within limit(s),
# return ( level, key ) if not within limit(s) or key not found,
# return ( True, key ) if all keys within limit(s) and key should be printed.
def test_func_bkt_stat_vs_min_max(path_prefix, descriptor,
                                  stat_description, stat_value, align,
                                  first_set, last_set):
    return test_bucket_stat_keys_vs_min_max(path_prefix, descriptor,
                                            stat_description, [ 'avg' ],
                                            stat_value, align,
                                            first_set, last_set)

# Test a BucketStat versus maximums: avg (from 'min') and max (from 'max')
# Return True if unconditional, i.e. both min and max are None
# Return False if all key(s) within limit(s),
# return ( level, key ) if not within limit(s) or key not found.
def test_func_bkt_avg_and_max(path_prefix, descriptor,
                              stat_description, stat_value, align,
                              first_set, last_set):
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> test_func_bkt_avg_and_max:", \
              "first_set", first_set, "last_set", last_set, \
              "path_prefix", path_prefix, \
              "stat_path", descriptor[1], "stat_value", stat_value, \
              "align", align
    avg_maxs = list_get_or_default(descriptor, 5)
    max_maxs = list_get_or_default(descriptor, 6)

    # Test unconditional
    if (avg_maxs == None) and (max_maxs == None):
        if (_debug & 4096) != 0:
            print ">>> test_func_bkt_avg_and_max: (At start) returns", \
                  True
        return True

    avg_result = test_bucket_stat_one_key_vs_maximums(path_prefix, descriptor,
                                                      stat_description,
                                                      'avg', stat_value, align,
                                                      avg_maxs)
    if avg_result and (avg_result[0] != True):
        if (_debug & 4096) != 0:
            print ">>> test_func_bkt_avg_and_max:" \
                  " (After avg) returns", avg_result
        assert is_returned_by_test_func_bkt_stat(avg_result), "Invalid type"
        return avg_result
    result = avg_result

    max_result = test_bucket_stat_one_key_vs_maximums(path_prefix, descriptor,
                                                      stat_description,
                                                      'max', stat_value, align,
                                                      max_maxs)
    if max_result and (max_result[0] != True):
        if (_debug & 4096) != 0:
            print ">>> test_func_bkt_avg_and_max:" \
                  " (After max) returns", max_result
        assert is_returned_by_test_func_bkt_stat(max_result), "Invalid type"
        return max_result
    elif not result:
        result = max_result

    if (_debug & 4096) != 0:
        print ">>> test_func_bkt_avg_and_max: (At end) returns", result
    assert is_returned_by_test_func_bkt_stat(result), "Invalid type"
    return result

# test_func testing regular expression.
# The compiled expression is in min, the level is in max.
def test_func_not_search_regexp(path_prefix, descriptor,
                                stat_description, stat_value, align,
                                first_set, last_set):
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> test_func_not_search_regexp:", "path_prefix", path_prefix, \
              "stat_path", descriptor[1], "stat_value", stat_value, \
              "align", align
    if descriptor[5].search(stat_value):
        if (_debug & 4096) != 0:
            print ">>> test_func_not_search_regexp: returns", False
        return False
    else:
        if (_debug & 4096) != 0:
            print ">>> test_func_not_search_regexp: returns", descriptor[6]
        assert is_returned_by_test_func_non_bkt_stat(descriptor[6]), "Invalid type"
        return descriptor[6]

#------------------------------------------------------------------------------
# For testing the test_func option

# Return the level in min, or True if not min
def test_func_always_log(path_prefix, descriptor,
                         stat_description, stat_value, align,
                         first_set, last_set):
    global _debug                       # In
    if (_debug & 4096) != 0:
        stat_path = descriptor[1]
        print ">>> stat_func_always_log:", "path_prefix", path_prefix, \
              "stat_path", stat_path, "stat_value", stat_value, "align", align
    min = list_get_or_default(descriptor, 5)
    if not min:
        min = True
    assert is_returned_by_test_func_non_bkt_stat(min), "Invalid type"
    return min

# Always return False
def test_func_never_log(path_prefix, descriptor,
                        stat_description, stat_value, align,
                        first_set, last_set):
    global _debug                       # In
    if (_debug & 4096) != 0:
        stat_path = descriptor[1]
        print ">>> stat_func_never_log:", "path_prefix", path_prefix, \
              "stat_path", stat_path, "stat_value", stat_value, "align", align
    return False
    
#------------------------------------------------------------------------------
def print_bucket_stat_one_key(path_prefix, stat_path, stat_description, unit,
                              key, key_msg, stat, align, log, in_data=False):
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> print_bucket_stat_one_key:", "path_prefix", path_prefix, \
              "stat_path", stat_path, "key", key, "stat", stat, "log", log
    assert is_passed_to_print_func_bkt_stat(log), "Invalid type"
    if type(log) == type((1, 2)):
        log_level = log[0]
        log_key = log[1]
    else:
        log_level = log
        log_key = None

    if type(stat) == type({}):
        if key in stat:
            if (log_key == None) or (log_key == key):
                level = log_level
            else:
                level = True
        else:
            msg = "BucketStat %s does not have '%s'" % (stat_path, key_msg)
            ui_warn(msg)
            print msg
            return False
    else:
        level = True

    if in_data and unit:
        stat_format = "%s: %s  %s: <b>" % ( stat_description, key_msg, unit )
    else:
        stat_format = "%s: %s: <b>" % ( stat_description, key_msg )
    value = stat[key]
    type_value = type(value)
    if type_value == type(1.0):
        stat_format += "%f"
    elif (type_value == type(1)) or (type_value == type(0L)):
        stat_format += "%d"
    elif type_value == type(""):
        stat_format += "%s"
    else:
        print "Invalid type"
        return False

    if unit and not in_data:
        stat_format += "  %s</b>"
        ui_log_info_warn_err(level, stat_format % (value, unit), align)
    else:
        stat_format += "</b>"
        ui_log_info_warn_err(level, stat_format % value, align)

    return True

#------------------------------------------------------------------------------
def print_bucket_stat(path_prefix, stat_path, stat_description,
                      align, stat, log):
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> print_bucket_stat:", "path_prefix", path_prefix, \
              "stat_path", stat_path, "align", align, "stat", stat, "log", log
    if not log:
        return

    assert is_passed_to_print_func_bkt_stat(log), "Invalid type"
    if 'unit' in stat:
        unit = stat['unit']
    else:
        ui_warn("BucketStat " + stat_path + " does not have 'unit'")
        print "BucketStat", stat_path, "does not have 'unit'"
        unit = None

    align_indent = 0                    # Extra align: 0 for first line
    for key in [ 'aggregate', 'avg', 'max' ]:
        printed = print_bucket_stat_one_key(path_prefix, stat_path,
                                            stat_description, unit,
                                            key, key, stat,
                                            align + align_indent, log)
        if printed:
            align_indent = 1

    if 'data' in stat:
        bdivs = get_bucket_divisions()
        data = stat['data']
        for idx in range(0, len(data)):
            value = data[idx]
            if value == 0:
                continue
            printed = print_bucket_stat_one_key(path_prefix, stat_path,
                                                stat_description, unit,
                                                idx, bdivs[idx], data,
                                                align + align_indent, log,
                                                True)
            if printed:
                align_indent = 1
    else:
        ui_warn("BucketStat " + stat_path + " does not have 'data'")
        print "BucketStat", stat_path, "does not have 'data'"

#------------------------------------------------------------------------------
# Format to use to display each type
formats = {}
formats[INT] = "d"
formats[FLOAT] = "f"
formats[STR] = "s"
#formats[DICT] = 0
#formats[LIST] = 0
#formats[LIST_INT] = 0
#formats[LIST_FLOAT] = 0
#formats[LIST_STR] = 0
formats[KEYS] = "s"
formats[KEY_ENUM] = "s"
formats[BKT] = "f"

def print_func_normal(path_prefix, descriptor, stat_path,
                      stat_description, level, align, stat, lvl):
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> print_func_normal:", "path_prefix", path_prefix, \
              "stat_path", stat_path, "level", level, "align", align,\
              "stat", stat, "lvl", lvl
    global formats                      # In
    if stat_description == None:
        stat_description = get_stat_description(path_prefix, descriptor)
    stat_units = descriptor[3]
    stat_type = abs(descriptor[4])
    if stat_type == BKT:
        print_bucket_stat(path_prefix, stat_path, stat_description,
                          align, stat, lvl)
    elif (not stat_units) or (len(stat_units) == 0):
        assert is_passed_to_print_func_non_bkt_stat(lvl), "Invalid type"
        stat_format = formats[stat_type]
        stat_format = stat_description + ": <b>%" + stat_format + "</b>"
        ui_log_info_warn_err(lvl, stat_format % stat, align)
    else:
        assert is_passed_to_print_func_non_bkt_stat(lvl), "Invalid type"
        stat_format = formats[stat_type]
        stat_format = (stat_description +
                       ": <b>%" + stat_format + "  %s</b>")
        ui_log_info_warn_err(lvl, stat_format % (stat, stat_units), align)

#------------------------------------------------------------------------------
def test_and_log_stat(path_prefix, stat_path, descriptor,
                      stat_description, level, align, stat,
                      first_set, last_set):
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> test_and_log_stat:", \
              "first_set", first_set, "last_set", last_set, \
              "path_prefix", path_prefix, "stat_path", stat_path, \
              "level", level, "align", align, "stat", stat
    global _verbosity                   # In
    if first_set != last_set:
        stat_description += " (Difference)"
    # Get fields from descriptor
    stat_verbosity = descriptor[0]
    stat_units = descriptor[3]
    stat_type = abs(descriptor[4])
    test_func = list_get_or_default(descriptor, 9)
    print_func = list_get_or_default(descriptor, 10)
    # Should the stat be logged?
    if stat_verbosity > _verbosity:
        return stat

    if test_func != None:
        log = test_func(path_prefix, descriptor, stat_description,
                        stat, align, first_set, last_set)
        if stat_type == BKT:
            assert is_returned_by_test_func_bkt_stat(log), "Invalid type"
        else:
            assert is_returned_by_test_func_non_bkt_stat(log), "Invalid type"
            
    elif stat_type == BKT:
        log = test_func_bkt_stat_vs_min_max(path_prefix, descriptor,
                                            stat_description, stat, align,
                                            first_set, last_set)
        assert is_returned_by_test_func_bkt_stat(log), "Invalid type"
    else:
        log = test_func_non_bucket_stat_vs_min_max(path_prefix, descriptor,
                                                   stat_description, stat,
                                                   align, first_set, last_set)
        assert is_returned_by_test_func_non_bkt_stat(log), "Invalid type"

    if (_debug & 1) != 0:
        if not log:
            log = True              # Log all statistics

    # Log the stat
    if log:
        if print_func != None:
            print_func(path_prefix, descriptor, stat_path,
                       stat_description, level, align, stat, log)
        else:
            print_func_normal(path_prefix, descriptor, stat_path,
                              stat_description, level, align, stat, log)
                      
#------------------------------------------------------------------------------
def get_stat_description(path_prefix, descriptor):
    global _debug                       # In
    stat_path = descriptor[1]
    stat_description = descriptor[2]
    if (_debug & 32) != 0:
        stat_description = path_prefix + stat_path
    elif ((_debug & 16) != 0) or (stat_description == ""):
        stat_description = stat_path
    return stat_description

#------------------------------------------------------------------------------
fs_stats = {}
def process_descriptor(is_core,
                       stat_idx, path_prefix, descriptor, level, align):
    global _debug                       # In
    global _verbosity                   # In
    global _corestats                   # In
    global _edgestats                   # In
    global fs_stats                     # Out
    # ui_log() or ui_title()?
    length = len(descriptor)
    if length <= 1:
        ui_warn("Descriptor is an invalid length: " + descriptor[1])
        return
    stat_verbosity = descriptor[0]
    if length == 2:
        if stat_verbosity <= _verbosity:
            ui_title(descriptor[1], level)
        return
    elif length == 3:
        if stat_verbosity <= _verbosity:
            ui_log(descriptor[2], align + descriptor[1])
        return
    elif length < 5:
        ui_warn("Descriptor is an invalid length: " + descriptor[1])
        return
    # Get fields from descriptor
    stat_path = descriptor[1]
    escaped_stat_path = stat_path
    stat_description = get_stat_description(path_prefix, descriptor)
    stat_type = descriptor[4]
    if (_debug & 4096) != 0:
        stat_units = descriptor[3]
        min = list_get_or_default(descriptor, 5)
        max = list_get_or_default(descriptor, 6)
        min_message = list_get_or_default(descriptor, 7)
        max_message = list_get_or_default(descriptor, 8)
        test_func = list_get_or_default(descriptor, 9)
        print_func = list_get_or_default(descriptor, 10)
        print ">>> process_descriptor:", "stat_idx", stat_idx, \
              "len(descriptor)", length, \
              "descriptor", descriptor, "stat_verbosity", stat_verbosity, \
              "stat_path", stat_path, "stat_description", stat_description, \
              "stat_units", stat_units, "stat_type", stat_type, \
              "min", min, "min_message", min_message, \
              "max", max, "max_message", max_message, \
              "test_func", test_func, "print_func", print_func
    # Determine whether a stat is resetable.
    stat_resetable = stat_type > 0
    stat_type = abs(stat_type)
    # Adjust fields
    escaped_stat_path = re.escape(stat_path)

    # Determine whether to log statistics difference and/or statistics value
    if is_core:
        len_stats = len(_corestats) 
    else:
        len_stats = len(_edgestats) 
    if stat_idx < 0:
        stat_idx = len_stats + stat_idx

    if stat_resetable:
        # The statistic is resetable.  Always log value.
        log_diff = False
        log_value = True
    elif stat_type not in [ INT, FLOAT, LIST_INT, LIST_FLOAT, BKT ]:
        # Stat difference not possible for this stat_type.  Always log value.
        log_diff = False
        log_value = True
    elif len_stats < 2:
        # Not enough statistics sets to compute difference.  Always log value.
        log_diff = False
        log_value = True
    elif stat_idx == 0:
        # The statistic is not resetable.  Should log difference.
        # First statistics set.  Cannot compute difference.
        if (_debug & 2) != 0:
            log_diff = False
            log_value = True
        else:
            log_diff = False
            log_value = False
    elif (_debug & 2) != 0:
        # Debug option: Log both stat values and stat differences
        log_diff = True
        log_value = True
    else:
        # The statistic is not resetable.  Should log difference.
        # Not first statistics set.  Log difference.
        log_diff = True
        log_value = False

    if (_debug & 4096) != 0:
        print "log_value", log_value, "log_diff", log_diff

    if (not log_diff) and (not log_value):
        return None

    # Get the stat or stat_difference
    if log_value:
        if is_core:
            stat = get_core_stat(path_prefix + escaped_stat_path,
                                stat_type, stat_idx)
        else:
            stat = get_edge_stat(path_prefix + escaped_stat_path,
                                stat_type, stat_idx)
    else:
        if is_core:
            stat = get_core_stat_diff(path_prefix + escaped_stat_path,
                                     stat_type, stat_idx - 1, stat_idx)
        else:
            stat = get_edge_stat_diff(path_prefix + escaped_stat_path,
                                     stat_type, stat_idx - 1, stat_idx)
    if stat == None:
        return None                     # Stat not found
    fs_stats[stat_path] = stat

    if stat_type == BKT:
        if (_debug & 8192) != 0:
            print "Found BKT:", path_prefix + stat_path

    # Test and log it
    if log_diff and log_value:
        # Log value first
        test_and_log_stat(path_prefix, stat_path, descriptor,
                          stat_description, level, align, stat,
                          stat_idx, stat_idx)
        if is_core:
            stat = get_core_stat_diff(path_prefix + escaped_stat_path,
                                     stat_type, stat_idx - 1, stat_idx)
        else:
            stat = get_edge_stat_diff(path_prefix + escaped_stat_path,
                                     stat_type, stat_idx - 1, stat_idx)
        if stat == None:
            return None                 # Stat not found
        fs_stats[stat_path] = stat

    if log_diff:
        # Log difference second or log only difference
        test_and_log_stat(path_prefix, stat_path, descriptor,
                          stat_description, level, align, stat,
                          stat_idx - 1, stat_idx)
    elif log_value:
        # Log only value
        test_and_log_stat(path_prefix, stat_path, descriptor,
                          stat_description, level, align, stat,
                          stat_idx, stat_idx)

    return stat

#------------------------------------------------------------------------------
def process_core_descriptor(stat_idx, path_prefix, descriptor, level, align):
    return process_descriptor(True,
                              stat_idx, path_prefix, descriptor, level, align)

#------------------------------------------------------------------------------
def process_edge_descriptor(stat_idx, path_prefix, descriptor, level, align):
    return process_descriptor(False,
                              stat_idx, path_prefix, descriptor, level, align)

#------------------------------------------------------------------------------
def find_descriptor(descriptors, stat_path):
    for descriptor in descriptors:
        if len(descriptor) < 5:
            continue
        if stat_path == descriptor[1]:
            return descriptor
    return None

#------------------------------------------------------------------------------
def find_descriptor_full_path(descriptors, full_path):
    global _debug                       # In
    for descriptor in descriptors:
        if len(descriptor) < 5:
            continue
        stat_path = descriptor[1]
        len_stat_path = len(stat_path)
        if full_path[-len_stat_path:] == stat_path:
            if (_debug & 4096) != 0:
                print "find_descriptor_full_path", "stat_path", stat_path, "descriptor", descriptor
            return descriptor
    return None
# -*- python -*-
#
# (C) Copyright 2003-2009 Riverbed Technology, Inc.  
# All rights reserved. Confidential.
#
# ------------- UI API Functions ------------------
from time import strftime
import re

_html = ''
_entry_block = ''
_section_block = ''
_section = ''
_subsection = ''
_entry_content = ''
_content = ''
_meta = ''
_nav = ''
_listdepth = 0
_listoutput = ''

def ui_init():
	global _html, _entry_block, _section_block
	_html = base64.decodestring(_template)

	regex = re.compile("ENTRY_BLOCK(.*)ENTRY_BLOCK",re.MULTILINE|re.DOTALL)
	r = regex.search(_html)
	if 0 == len(r.groups()):
		DIE("Template has no entry block")	
	_entry_block = r.groups()[0].strip()

	regex = re.compile("SECTION_BLOCK(.*)SECTION_BLOCK",
                           re.MULTILINE|re.DOTALL)
	r = regex.search(_html)
	if 0 == len(r.groups()):
		DIE("Template has no section block")
		
	_section_block = r.groups()[0].strip()

	
def ui_done():
	global _html
        global _core                    # In
        global _edge                    # In
        global _outfile                 # In
	
	ui_end_subsection()
	ui_end_section()
	
	reps = {
		'@@PAGETITLE@@': "VA Debug Report | EDGE: %s | CORE: %s" %
                (_edge, _core),
		'@@TITLE@@': "VA Debug Report",
		'@@TIME@@': strftime("[ %Y-%m-%d %H:%M:%S ]"),
		'@@NAV@@': _nav,
		'@@VERSION@@': _version,
		'@@CONTENT@@': _content,
	}	
	_html = ui_replace(_html, reps)
		
	f = open(_outfile + ".html", 'w')
	f.write(_html)
	f.close()

	
def ui_section(sec):
        global _debug                   # In
        if (_debug & 128) != 0:
            print ">>> ui_section", "sec", sec
	global _section, _content, _nav
	
	ui_end_subsection()
	ui_end_section()
	_section = sec
	reps = {
		'@@SECTIONTITLE@@': _section,
	}
	_content += ui_replace(_section_block, reps)
	_nav += ( "<li class=\"page_item\"><a href=\"#%s\">%s</a></li>" %
                  (sec, sec) )
	
def ui_end_section():
	global _section
	
	_section = ''
	

def ui_subsection(subsec):
        global _debug                   # In
        if (_debug & 128) != 0:
            print ">>> ui_subsection", "subsec", subsec
	global _subsection
	
	ui_end_subsection()
	_subsection = subsec

	
def ui_end_subsection():
	global _entry_content, _content, _meta, _subsection

	if 0 != len(_entry_content) or 0 != len(_meta):			
		reps = {
			'@@ENTRYTITLE@@': _subsection,
			'@@ENTRYMETA@@': _meta,
			'@@ENTRYCONTENT@@': _entry_content,
		}
		_content += ui_replace(_entry_block, reps)
		
	_subsection = ''
	_entry_content = ''
	_meta = ''	


def ui_meta(mt):
    global _debug                       # In
    if (_debug & 128) != 0:
        print ">>> ui_meta", "mt", mt
    global _meta
    
    _meta += "<li>%s</li>" % mt


def ui_title(tt, lvl = 2):
    global _debug                       # In
    global _entry_content
    if (_debug & 128) != 0:
        print ">>> ui_title", "tt", tt, "lvl", lvl
        _entry_content += "<h%d>%d. %s</h%d>" % (lvl, lvl, tt, lvl)
    else:
        _entry_content += "<h%d>%s</h%d>" % (lvl, tt, lvl)
    
	
def ui_start_ol():
    global _listdepth, _listoutput
    
    _listdepth += 1
    _listoutput += "<ol>"
    

def ui_end_ol():
    global _listdepth, _listoutput
    
    _listdepth -= 1
    _listoutput += "</ol>"
    if 0 == _listdepth:
        ui_output(_listoutput)
        _listoutput = ''


def ui_start_ul():
    global _listdepth, _listoutput
    
    _listdepth += 1
    _listoutput += "<ul>"
    
    
def ui_end_ul():
    global _listdepth, _listoutput
    
    _listdepth -= 1
    _listoutput += "</ul>"
    if 0 == _listdepth:
        ui_output(_listoutput)
        _listoutput = ''


def ui_li(msg, level = ''):
    global _debug                       # In
    global _listoutput
    if (_debug & 128) != 0:
        print ">>> ui_li", "msg", msg, "level", level
        _listoutput += "<li class=\"%s\">%s. %s</li>" % (level, level, msg)
    else:
        _listoutput += "<li class=\"%s\">%s</li>" % (level, msg)

        
def ui_log(msg, align = 0):
    global _debug                       # In
    if (_debug & 64) != 0:
        print ">>> ui_log", "msg", msg, "align", align
        ui_msg(("%d. %s" % (align, msg)), align, '')
    else:
        ui_msg(msg, align, '')

def ui_info(msg, align = 0):
    global _debug                       # In
    if (_debug & 128) != 0:
        print ">>> ui_info", "msg", msg, "align", align
        ui_msg(("%d. %s" % (align, msg)), align, 'info')
    else:
        ui_msg(msg, align, 'info')

	
def ui_warn(msg, align = 0):
    global _debug                       # In
    if (_debug & 128) != 0:
        print ">>> ui_warn", "msg", msg, "align", align
    ui_msg(msg, align, 'warn')

	
def ui_err(msg, align = 0):
    global _debug                       # In
    if (_debug & 128) != 0:
        print ">>> ui_err", "msg", msg, "align", align
        ui_msg(("%d. %s" % (align, msg)), align, 'error')
    else:
        ui_msg(msg, align, 'error')


def ui_msg(msg, align, level):
	global _entry_content
	
	alignstr = "".join(["&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
                            for i in range(align)])
	str = ''
	if type(msg) == type(list()):
		for m in msg:
			str += "%s%s" % (alignstr, m)
	else:
		str = "%s%s" % (alignstr, msg)
	ui_output("<p class=\"%s\">%s</p>" % (level, str))

    
	
# -------------- INTERNAL UI FUNCTIONS (Do not use these directly) ------------
def ui_replace(content, reps):
	for key, val in reps.iteritems():
		content = content.replace(key, val)
	return content
	

def ui_output(msg):
    global _entry_content
    
    _entry_content += msg
# -*- python -*-
#
# (C) Copyright 2003-2009 Riverbed Technology, Inc.  
# All rights reserved. Confidential.
#
# ------------- iSCSI debugging ---------------------------
def iscsi_debug():
	iscsi_edge_debug()
	iscsi_core_debug()

	
def iscsi_edge_debug():
    ui_subsection("EDGE")
    # Targets and Initiators and their LUNs
    tgt_names = get_edge_stat("/iscsi/*/initiator_count", KEY_ENUM)
    if 0 == len(tgt_names):
		ui_warn("No targets exposed from the edge")

    ui_title("Targets and Initiators")
    all_inits = []
    for tgt in tgt_names:
        ui_log("Target: <b>%s</b>" % tgt, 1)
        init_count = get_edge_stat("/iscsi/%s/initiator_count" % tgt, INT)
        if 0 == init_count:
			ui_warn("No initiators connected to this target", 2)
        else:
            ui_log("%d Initiator(s) connected" % init_count, 2)
            init_names = get_edge_stat("/iscsi/%s/*/initiator" % tgt, LIST_STR)
            i = 1
            for init in init_names:
                all_inits.append(init)
                ui_log("%d. %s" % (i, init), 3)
                serials = get_edge_stat("/iscsi/lun/*/bytes_read", KEY_ENUM)
                j = 1
                if 0 == len(serials):
                    ui_warn("%d LUNs exposed to this Initiator" % len(serials), 4)
                else:
                    for serial in serials:
                        ui_log("%d. %s" % (j, serial), 5)
                        j += 1
                    i += 1
    # LUNs
    ui_title("LUNs")
    serials = get_edge_stat("/iscsi/lun/*/bytes_read", KEY_ENUM)
    for serial in serials:
        ui_log("<b>%s</b>" % serial)
        r_bytes = get_edge_stat("/iscsi/lun/%s/bytes_read" % serial, INT)
        r_iops = get_edge_stat("/iscsi/lun/%s/ios_read" % serial, INT)
        r_err_unknown = get_edge_stat("/iscsi/lun/%s/error_unknown_read_" % serial, INT)
        r_err_busy = get_edge_stat("/iscsi/lun/%s/error_busy_read_" % serial, INT)
        r_err_notconn = get_edge_stat("/iscsi/lun/%s/error_notconn_read_" % serial, INT)
        r_err =  r_err_unknown + r_err_busy + r_err_notconn
        r_time = get_edge_stat("/iscsi/lun/%s/read_req_time" % serial)[0]
        w_bytes = get_edge_stat("/iscsi/lun/%s/bytes_write" % serial, INT)
        w_iops = get_edge_stat("/iscsi/lun/%s/ios_write" % serial, INT)
        w_err_unknown = get_edge_stat("/iscsi/lun/%s/error_unknown_write_" % serial, INT)
        w_err_busy = get_edge_stat("/iscsi/lun/%s/error_busy_write_" % serial, INT)
        w_err_notconn = get_edge_stat("/iscsi/lun/%s/error_notconn_write_" % serial, INT)
        w_err =  w_err_unknown + w_err_busy + w_err_notconn
        w_time = get_edge_stat("/iscsi/lun/%s/write_req_time" % serial)[0]
        # total reads
        if r_iops:
            ui_log("Read [bytes, ios, avg_blocks/op]: %s %d %d" % \
                (to_unit(r_bytes), r_iops, r_bytes/512/r_iops), 1)
        else:
            ui_log("Read [bytes ios blocks/op]: 0 0 0", 1)
        if 0 != r_err:
            ui_err("Read errors reported [total, percentage]: %d, %.2f%%" % (r_err, (100*r_err)/r_iops), 1)
        # total writes
        if w_iops:    
            ui_log("Write [bytes, ios, avg_blocks/op]: %s %d %d" % \
                (to_unit(w_bytes), w_iops, w_bytes/512/w_iops), 1)
        else:
            ui_log("Write [bytes ios blocks/op]: 0 0 0", 1)
        if 0 != w_err:
            ui_err("Write errors reported [total, percentage]: %s, %.2f%%" % (w_err, (100*w_err)/w_iops), 1)
        # Initiators
        inits = get_edge_stat("/iscsi/*/lun/%s/bytes_read" % serial)
        ui_log("Active Initiators", 1)
        init_names = extract(inits, "/iscsi/*/lun/%s/bytes_read" % serial)
        if (_debug & 1024) != 0:
            print "len(inits)", len(inits), "len(init_names)", len(init_names)
        active = False
        for i, init in enumerate(inits):
            # reads
            if "0" != init['val'] and r_iops:
                ui_log(init_names[i], 2)
                p_data = (100*int(init['val']))/r_bytes;
                iops = get_edge_stat("/iscsi/%s/lun/%s/ios_read" % \
                                    (init_names[i], serial), INT)
                p_iops = (100*iops)/r_iops
                ui_log("Reads: %.2f%% data, %.2f%% iops" % (p_data, p_iops), 3)
                active = True
            # writes
            # NOTE: the below is getting - IndexError: list index out of range
            if (_debug & 1024) != 0:
                    print "i", i, "init", init
            wstat = get_edge_stat("/iscsi/%s/lun/%s/bytes_write" % \
                                    (init_names[i], serial), INT)
            if "0" != wstat and w_iops:
                p_data = (100*int(wstat))/w_bytes
                iops = get_edge_stat("/iscsi/%s/lun/%s/ios_write" % \
                                    (init_names[i], serial), INT)
                p_iops = (100*iops)/w_iops
                ui_log("Writes: %.2f%% data, %.2f%% iops" % (p_data, p_iops), 3)
                active = True
        if not active:
            ui_log("None", 3)
	#meta
	ui_meta("%d Targets" % len(tgt_names))
	ui_meta("%d Initiators" % unique_count(all_inits))
	ui_meta("%d LUNs" % len(serials))
	
			
def iscsi_core_debug():
	pass
	
# -*- python -*-
#
# (C) Copyright 2003-2009 Riverbed Technology, Inc.  
# All rights reserved. Confidential.
#
import string
# ------------- Prefetch debugging ---------------------------
#------------------------------------------------------------------------------
def vmdk_debug(stat_idx, vmdk_path, partition, vm, scsi_part, level, align):
    global _debug                       # In
    if (_debug & 2048) != 0:
        print ">>> vmdk_debug:", "vmdk_path", vmdk_path,\
              "partition", partition, "vm", vm,\
              "scsi_part", scsi_part, "level", level, "align", align
    global num_vmdks                    # In/Out
    global stats_vmdk_descriptors       # In
    global stats_vmdk_snapshot_descriptors # In
    global fs_stats                     # In
    print "Processing VMDK: %s" % scsi_part
    num_vmdks += 1
    ui_log('<a href="#overview_vmdk%d" name="#vmdk%d">(Overview)</a> VMDK: %s' %
           (num_vmdks, num_vmdks, scsi_part ), align)

    for descriptor in stats_vmdk_descriptors:
        process_core_descriptor(stat_idx,
                               vmdk_path, descriptor, level, align + 2)

    if fs_stats["/type"] == "snapshot":
        for descriptor in stats_vmdk_snapshot_descriptors:
            process_core_descriptor(stat_idx,
                                   vmdk_path, descriptor, level, align + 2)
        
    lun_debug(stat_idx, vmdk_path, scsi_part, False, level, align)

#------------------------------------------------------------------------------
def determine_vm_partitions(stat_idx, vm_path):
    global _debug                       # In
    scsi_parts = get_core_stat(vm_path + "/*/capacity",
                              KEY_ENUM, stat_idx, True)
    diskpart = ""

    if scsi_parts == None:
        scsi_parts = get_core_stat(vm_path + "/*/diskpart/n_ptabmeta_reads_",
                                  KEY_ENUM, stat_idx, True)
        diskpart = "/diskpart"

    if scsi_parts == None:
        scsi_parts = get_core_stat(vm_path +
                                  "/*/diskpart/data/n_ptabmeta_reads_",
                                  KEY_ENUM, stat_idx, True)
        diskpart = "/diskpart/data"

    if (not scsi_parts) or (len(scsi_parts) == 0):
        ui_warn("CORE: SCSI partitions not found for " + vm_path)
        print "CORE: SCSI partitions not found for", vm_path
        return None, None

    if (_debug & 2048) != 0:
        print ">>> determine_vm_partitions:", "stat_idx", stat_idx, \
              "vm_path", vm_path, \
              "diskpart", diskpart, "scsi_parts", scsi_parts

    return diskpart, scsi_parts

#------------------------------------------------------------------------------
def vm_debug(stat_idx, vm_path, partition, vm, level, align):
    global _debug                       # In
    if (_debug & 2048) != 0:
        print ">>> vm_debug:", "vm_path", vm_path, "partition", partition,\
              "vm", vm, "level", level, "align", align
    global num_vms                      # In/Out
    global stats_vm_descriptors         # In
    name = get_core_stat(vm_path + "/name", STR, stat_idx, True)
    num_vms += 1
    if name != None:
        print "Processing VM: %s: %s" % ( vm, name )
        ui_log('<a href="#overview_vm%d" name="#vm%d">(Overview)</a> VM: %s: %s' %
               ( num_vms, num_vms, vm, name ), align)
    else:
        print "Processing VM: %s" % vm
        ui_warn("CORE: Name not found for VM " + vm_path)
        print "CORE: Name not found for VM", vm_path
        ui_log('<a href="#overview_vm%d" name="#vm%d">(Overview)</a> VM: %s' %
               ( num_vms, num_vms, vm ), align)

    for descriptor in stats_vm_descriptors:
        process_core_descriptor(stat_idx, vm_path, descriptor, level, align + 2)

    diskpart, scsi_parts = determine_vm_partitions(stat_idx, vm_path)

    if scsi_parts != None:
        for scsi_part in scsi_parts:
            vmdk_path = vm_path + "/" + scsi_part
            vmdk_debug(stat_idx,
                       vmdk_path, partition, vm, scsi_part, level, align + 1)

#------------------------------------------------------------------------------
def vmfs_stores_debug(stat_idx, store_path, file_system, vmfs_store,
                      level, align, log_it):
    global _debug                       # In
    if (_debug & 2048) != 0:
        print ">>> vmfs_stores_debug:", "store_path", store_path,\
              "file_system", file_system, "vmfs_store", vmfs_store,\
              "level", level, "align", align
    global num_stores                   # In/Out
    global stats_vmfs_store_descriptors # In
    print "Processing VMFS store: %s: %s" % ( file_system, vmfs_store )
    if log_it:
        ui_log('<a href="#overview_store%d" name="#store%d">(Overview)</a> Store: %s' %
               ( num_stores, num_stores, vmfs_store), align)
    for descriptor in stats_vmfs_store_descriptors:
        process_core_descriptor(stat_idx,
                               store_path, descriptor, level, align + 2)

#------------------------------------------------------------------------------
first_file_system = True
def file_system_debug(stat_idx, lun_path, diskpart_path, file_system,
                      level, align):
    global _debug                       # In
    if (_debug & 2048) != 0:
        print ">>> file_system_debug:", "lun_path", lun_path, \
              "diskpart_path", diskpart_path, \
              "file_system", file_system, "level", level, "align", align
    global stats_child_descriptors      # In
    global stats_fs_descriptors         # In
    global stats_file_rah_descriptors   # In
    global stats_next_file_descriptors  # In
    global stats_ntfs_dir_rah_descriptors # In
    global stats_ntfs_win_pf_descriptors # In
    global stats_ntfs_exe_dll_descriptors # In
    global stats_ntfs_next_dir_descriptors # In
    global stats_ntfs_win_boot_descriptors # In
    global stats_ntfs_descriptors       # In
    global stats_vmfs_prefetch_descriptors # In
    global stats_vmfs_vmdk_notifier_descriptors # In
    global first_file_system            # In/Out
    global num_file_systems             # In/Out
    # Determine fs_type
    fs_path = diskpart_path + "/" + file_system
    fs_state = get_core_stat(fs_path + "/fslayer/fs_state_", STR, stat_idx)
    fs_type = "UNKNOWN";
    if fs_state == "NTFS-OK":
        fs_type = "NTFS"
        stores = None
    elif fs_state  == "VMFS-OK":
        fs_type = "VMFS"
        stores = get_core_stat(fs_path + "/fslayer/vmfscrawl/*/status",
                                   KEY_ENUM, stat_idx, True)
    print "Processing %s: %s" % ( fs_type, file_system )
    num_file_systems += 1
    if stores and (len(stores) == 1):
        ui_log(('<a href="#overview_fs%d" name="#fs%d">(Overview)</a> ' +
                'Partition %s: %s Store: %s') %
               (num_file_systems, num_file_systems,
                fs_type, file_system, stores[0]), align)
        store_path = fs_path + "/fslayer/vmfscrawl/" + stores[0]
        vmfs_stores_debug(stat_idx, store_path, file_system, stores[0],
                          level, align, False)
    else:
        ui_log('<a href="#overview_fs%d" name="#fs%d">(Overview)</a> Partition %s: %s' %
               (num_file_systems, num_file_systems,
                fs_type, file_system), align)

    # NTFS
    if fs_type == "NTFS":
        for descriptor in stats_child_descriptors:
            process_core_descriptor(stat_idx,
                                   fs_path, descriptor, level, align + 2)

    # VMFS - Stores
    elif fs_type == "VMFS":
        # stores
        if (not stores) or (len(stores) == 0):
            ui_warn("CORE: Stores not found for " + fs_path)
            print "CORE: Stores not found for", fs_path
        elif len(stores) > 1:
            for store in stores:
                store_path = fs_path + "/fslayer/vmfscrawl/" + store
                vmfs_stores_debug(stat_idx, store_path, file_system, store,
                                  level, align + 1, True)

    # Common to all file system types
    for descriptor in stats_fs_descriptors:
        process_core_descriptor(stat_idx, fs_path, descriptor, level, align + 2)
    
    # file_rah
    stat = get_core_stat(fs_path +
                        "/fslayer/pftech/file_rah/n_read_notifs_", INT,
                        stat_idx, True)
    if stat != None:
        for descriptor in stats_file_rah_descriptors:
            process_core_descriptor(stat_idx,
                                   fs_path, descriptor, level, align + 2)
    elif first_file_system:
        ui_warn("File read ahead is disabled.")
        if (_debug & 2048) != 0:
            print "File read ahead is disabled."

    # next_file
    stat = get_core_stat(fs_path +
                        "/fslayer/pftech/next_file/n_read_notifs_", INT,
                        stat_idx, True)
    if stat != None:
        for descriptor in stats_next_file_descriptors:
            process_core_descriptor(stat_idx,
                                   fs_path, descriptor, level, align + 2)
    elif first_file_system:
        ui_warn("Directory Copy read ahead is disabled.")
        if (_debug & 2048) != 0:
            print "Directory Copy read ahead is disabled."

    # NTFS
    if fs_type == "NTFS":
        # dir_rah
        stat = get_core_stat(fs_path +
                            "/fslayer/pftech/dir_rah/n_read_notifs_", INT,
                            stat_idx, True)
        if stat != None:
            for descriptor in stats_ntfs_dir_rah_descriptors:
                process_core_descriptor(stat_idx,
                                       fs_path, descriptor, level, align + 2)
        elif first_file_system:
            ui_warn("Directory read ahead is disabled.")
            if (_debug & 2048) != 0:
                print "Directory read ahead is disabled."

        # win_pf
        stat = get_core_stat(fs_path +
                            "/fslayer/pftech/win_pf/n_read_notifs_", INT,
                            stat_idx, True)
        if stat != None:
            for descriptor in stats_ntfs_win_pf_descriptors:
                process_core_descriptor(stat_idx,
                                       fs_path, descriptor, level, align + 2)
        elif first_file_system:
            ui_warn("Windows prefetch read ahead is disabled.")
            if (_debug & 2048) != 0:
                print "Windows prefetch read ahead is disabled."

        # exe_dll
        stat = get_core_stat(fs_path +
                            "/fslayer/pftech/exe_dll/n_read_notifs_", INT,
                            stat_idx, True)
        if stat != None:
            for descriptor in stats_ntfs_exe_dll_descriptors:
                process_core_descriptor(stat_idx,
                                       fs_path, descriptor, level, align + 2)
        elif first_file_system:
            ui_warn("Exe/dll prefetch read ahead is disabled.")
            if (_debug & 2048) != 0:
                print "Exe/dll prefetch read ahead is disabled."

        # next_dir
        stat = get_core_stat(fs_path +
                            "/fslayer/pftech/next_dir/n_read_notifs_", INT,
                            stat_idx, True)
        if stat != None:
            for descriptor in stats_ntfs_next_dir_descriptors:
                process_core_descriptor(stat_idx,
                                       fs_path, descriptor, level, align + 2)
        elif first_file_system:
            ui_warn("Recursive Dir read ahead is disabled.")
            if (_debug & 2048) != 0:
                print "Recursive Dir read ahead is disabled."

        # win_boot
        stat = get_core_stat(fs_path +
                            "/fslayer/pftech/win_boot/n_read_notifs_", INT,
                            stat_idx, True)
        if stat != None:
            for descriptor in stats_ntfs_win_boot_descriptors:
                process_core_descriptor(stat_idx,
                                       fs_path, descriptor, level, align + 2)
        elif first_file_system:
            ui_warn("Windows boot read ahead is disabled.")
            if (_debug & 2048) != 0:
                print "Windows boot read ahead is disabled."

        for descriptor in stats_ntfs_descriptors:
            process_core_descriptor(stat_idx,
                                   fs_path, descriptor, level, align + 2)
    # VMFS
    elif fs_type == "VMFS":
        # vmdk_notifier
        stat = get_core_stat(fs_path +
                            "/fslayer/pftech/vmdk_notifier/n_read_notifs_",
                            INT, stat_idx, True)
        if stat != None:
            for descriptor in stats_vmfs_vmdk_notifier_descriptors:
                process_core_descriptor(stat_idx,
                                       fs_path, descriptor, level, align + 2)
        elif first_file_system:
            ui_warn("vmdk_notifier is disabled.")
            if (_debug & 2048) != 0:
                print "vmdk_notifier is disabled."

        for descriptor in stats_vmfs_descriptors:
            process_core_descriptor(stat_idx,
                                   fs_path, descriptor, level, align + 2)

        # VMs
        vms_path = lun_path + "/" + file_system
        vms = get_core_stat(vms_path + "/*/name", KEY_ENUM, stat_idx, True)
        if (not vms) or (len(vms) == 0):
            ui_warn("CORE: VMs not found for " + fs_path)
            print "CORE: VMs not found for", fs_path
        else:
            for vm in vms:
                vm_path = vms_path + "/" + vm
                vm_debug(stat_idx, vm_path, file_system, vm, level, align + 1)
    first_file_system = False

#------------------------------------------------------------------------------
def determine_diskpart_path(stat_idx, lun_path):
    global _debug                       # In
    stat = get_core_stat(lun_path + "/diskpart/n_ptabmeta_reads_", INT,
                        stat_idx, True)

    if stat != None:
        return lun_path + "/diskpart"

    stat = get_core_stat(lun_path + "/diskpart/data/n_ptabmeta_reads_", INT,
                        stat_idx, True)
    if stat != None:
        diskpart_path = lun_path + "/diskpart/data"
    else:
        diskpart_path = None

    if (_debug & 2048) != 0:
        print ">>> determine_diskpart_path:", "stat_idx", stat_idx, \
              "lun_path", lun_path, "returns", diskpart_path

    return diskpart_path

#------------------------------------------------------------------------------
def lun_debug(stat_idx, lun_path, serial, top_level, level, align):
    global _debug                       # In
    global num_luns                     # In/Out
    global stats_connector_descriptors  # In
    global stats_lun_descriptors        # In
    global stats_diskpart_descriptors   # In
    if (_debug & 2048) != 0:
        print ">>> lun_debug:", "lun_path", lun_path, "serial", serial,\
              "top_level", top_level, "level", level, "align", align
    print "Processing LUN: %s" % serial
    num_luns += 1
    ui_log('<a href="#overview_lun%d" name="#lun%d">(Overview)</a> LUN: %s' %
           ( num_luns, num_luns, serial), align)

    if top_level:
        connector_path = "/rdiskPFS_connector/" + serial
        for descriptor in stats_connector_descriptors:
            process_core_descriptor(stat_idx, connector_path, descriptor,
                                   level, align + 2)
        for descriptor in stats_lun_descriptors:
            process_core_descriptor(stat_idx,
                                   lun_path, descriptor, level, align + 2)

    # DiskPartLayer
    diskpart_path = determine_diskpart_path(stat_idx, lun_path)
    if diskpart_path == None:
        return

    # DiskPartLayer is present
    for descriptor in stats_diskpart_descriptors:
        process_core_descriptor(stat_idx, diskpart_path, descriptor,
                               level, align + 2)

    # Partitions
    lun_partitions = get_core_stat(diskpart_path +
                                  "/*/fslayer/fs_state_", KEY_ENUM,
                                  stat_idx, True)
    if (not lun_partitions) or (len(lun_partitions) == 0):
        ui_warn("CORE: Partitions not found for " + diskpart_path)
        print "CORE: Partitions not found for", diskpart_path
        return
    for partition in lun_partitions:
        file_system_debug(stat_idx, lun_path, diskpart_path, partition,
                          level, align + 1)

#------------------------------------------------------------------------------
vmdks = []
num_vmdks = 0
def vmdk_overview(stat_idx, vmdk_path, partition, vm, scsi_part, align):
    global _debug                       # In
    if (_debug & 2048) != 0:
        print ">>> vmdk_overview:", "vmdk_path", vmdk_path,\
              "partition", partition, "vm", vm, "scsi_part", scsi_part,\
              "align", align
    global vmdks                        # Out
    global num_vmdks                    # In/Out
    print "Overview VMDK: %s" % scsi_part
    num_vmdks += 1
    ui_log('<a href="#vmdk%d" name="#overview_vmdk%d">(Details)</a> VMDK: %s' %
           (num_vmdks, num_vmdks, scsi_part ), align)
    vmdks.append( [partition, vm, scsi_part] )
    lun_overview(stat_idx, vmdk_path, scsi_part, align)

#------------------------------------------------------------------------------
vms = []
num_vms = 0
def vm_overview(stat_idx, vm_path, partition, vm, align):
    global _debug                       # In
    if (_debug & 2048) != 0:
        print ">>> vm_overview:", "vm_path", vm_path,\
              "partition", partition, "vm", vm, "align", align
    global vms                          # Out
    global num_vms                      # In/Out
    name = get_core_stat(vm_path + "/name", STR, stat_idx, True)
    num_vms += 1
    if name != None:
        print "Overview VM: %s: %s" % ( vm, name )
        vms.append( [partition, vm, name] )
        ui_log('<a href="#vm%d" name="#overview_vm%d">(Details)</a> VM: %s: %s' %
               ( num_vms, num_vms, vm, name ), align)
    else:
        print "Overview VM: %s" % vm
        ui_warn("CORE: Name not found for VM " + vm_path)
        print "CORE: Name not found for VM", vm_path
        vms.append( [partition, vm] )
        ui_log('<a href="#vm%d" name="#overview_vm%d">(Details)</a> VM: %s' %
               ( num_vms, num_vms, vm ), align)

    diskpart, scsi_parts = determine_vm_partitions(stat_idx, vm_path)

    if scsi_parts != None:
        for scsi_part in scsi_parts:
            vmdk_path = vm_path + "/" + scsi_part
            vmdk_overview(stat_idx, vmdk_path, partition, vm, scsi_part,
                          align + 1)

#------------------------------------------------------------------------------
vmfs_stores = []
num_stores = 0
def vmfs_stores_overview(stat_idx, store_path, partition, vmfs_store,
                         align, log_it):
    global _debug                       # In
    if (_debug & 2048) != 0:
        print ">>> vmfs_stores_overview:", "store_path", store_path,\
              "partition", partition, "vmfs_store", vmfs_store, "align", align
    global num_stores                   # In/Out
    global vmfs_stores                  # Out
    vmfs_stores.append( [partition, vmfs_store] )
    print "Overview VMFS store: %s: %s" % ( partition, vmfs_store )
    if log_it:
        num_stores += 1
        ui_log('<a href="#store%d" name="#overview_store%d">(Details)</a> Store: %s' %
               ( num_stores, num_stores, vmfs_store), align)

#------------------------------------------------------------------------------
file_systems = []
ntfs_file_systems = []
vmfs_file_systems = []
num_file_systems = 0
def file_system_overview(stat_idx, lun_path, diskpart_path, file_system,
                         align):
    global _debug                       # In
    if (_debug & 2048) != 0:
        print ">>> file_system_overview:", "lun_path", lun_path, \
              "diskpart_path", diskpart_path,\
              "file_system", file_system, "align", align
    global file_systems                 # Out
    global ntfs_file_systems            # Out
    global vmfs_file_systems            # Out
    global num_file_systems             # In/Out
    # Determine fs_type, append, and log
    fs_path = diskpart_path + "/" + file_system
    fs_state = get_core_stat(fs_path + "/fslayer/fs_state_", STR, stat_idx)
    fs_type = "UNKNOWN";
    if fs_state == "NTFS-OK":
        fs_type = "NTFS"
        stores = None
        crawl_state = get_core_stat(fs_path + "/fslayer/ntfscrawl/crawl_state_",
                                   STR, stat_idx)
        ntfs_file_systems.append(list(file_system))

    elif fs_state  == "VMFS-OK":
        fs_type = "VMFS"
        stores = get_core_stat(fs_path + "/fslayer/vmfscrawl/*/status",
                              KEY_ENUM, stat_idx, True)
        crawl_state = get_core_stat(fs_path + "/fslayer/vmfscrawl/crawl_state_",
                                   STR, stat_idx)
        vmfs_file_systems.append(list(file_system))

    file_systems.append(list(file_system))

    if crawl_state == None:
        crawl_state = ""
    else:
        crawl_state = " " + crawl_state

    print "Overview %s: %s" % ( fs_type, file_system )
    num_file_systems += 1
    if stores and (len(stores) == 1):
        ui_log(('<a href="#fs%d" name="#overview_fs%d">(Details)</a> ' +
                'Partition %s: %s%s Store: %s' ) %
               (num_file_systems, num_file_systems,
                fs_type, file_system, crawl_state, stores[0]), align)
        store_path = fs_path + "/fslayer/vmfscrawl/" + stores[0]
        vmfs_stores_overview(stat_idx,
                             store_path, file_system, stores[0], align, False)
    else:
        ui_log('<a href="#fs%d" name="#overview_fs%d">(Details)</a> Partition %s: %s%s' %
               (num_file_systems, num_file_systems,
                fs_type, file_system, crawl_state), align)

    if fs_type == "VMFS":
        # stores
        stores = get_core_stat(fs_path + "/fslayer/vmfscrawl/*/status",
                                   KEY_ENUM, stat_idx, True)
        if (not stores) or (len(stores) == 0):
            ui_warn("CORE: Stores not found for " + fs_path)
            print "CORE: Stores not found for", fs_path
        elif len(stores) > 1:
            for store in stores:
                store_path = fs_path + "/fslayer/vmfscrawl/" + store
                vmfs_stores_overview(stat_idx,
                                     store_path, file_system, store, align + 1,
                                     True)

        # VMs
        vms_path = lun_path + "/" + file_system
        vms = get_core_stat(vms_path + "/*/name", KEY_ENUM, stat_idx, True)
        if (not vms) or (len(vms) == 0):
            ui_warn("CORE: VMs not found for " + fs_path)
            print "CORE: VMs not found for", fs_path
        else:
            for vm in vms:
                vm_path = vms_path + "/" + vm
                vm_overview(stat_idx, vm_path, file_system, vm, align + 1)

#------------------------------------------------------------------------------
num_luns = 0
def lun_overview(stat_idx, lun_path, serial, align):
    global _debug                       # In
    global stats_diskpart_descriptors   # In
    global num_luns                     # In/Out
    if (_debug & 2048) != 0:
        print ">>> lun_overview:", "lun_path", lun_path, "serial", serial,\
              "align", align
    print "Overview LUN: %s" % serial
    num_luns += 1
    ui_log('<a href="#lun%d" name="#overview_lun%d">(Details)</a> LUN: %s' %
           ( num_luns, num_luns, serial), align)

    # DiskPartLayer
    diskpart_path = determine_diskpart_path(stat_idx, lun_path)
    if diskpart_path == None:
        return

    # Partitions
    lun_partitions = get_core_stat(diskpart_path +
                                  "/*/fslayer/fs_state_", KEY_ENUM,
                                  stat_idx, True)
    if (not lun_partitions) or (len(lun_partitions) == 0):
        ui_warn("CORE: Partitions not found for " + lun_path)
        print "CORE: Partitions not found for", lun_path
        return
    for partition in lun_partitions:
        file_system_overview(stat_idx, lun_path, diskpart_path, partition,
                             align + 1)

#------------------------------------------------------------------------------
serials = []
def prefetch_one_edge_debug(stat_idx):
    global _debug                       # In
    global _edgestats                   # In
    global STATS_VALUE                  # In
    global STATS_TIMESTAMP              # In
    global serials                      # Out
    serials = []
    #
    if _edgestats[stat_idx][STATS_TIMESTAMP] != None:
        edge = "%s %s" % ( _edgestats[stat_idx][STATS_VALUE], _edgestats[stat_idx][STATS_TIMESTAMP] )
    else:
        edge = _edgestats[stat_idx][STATS_VALUE]
    ui_subsection("EDGE")
    # LUNs
    ui_title("LUNs %s" % edge)
    edge_serials = get_edge_stat("/iscsi/lun/*/bytes_read", KEY_ENUM, stat_idx)
    if (_debug & 2048) != 0:
        print ">>> prefetch_edge_debug:", "stat_idx", stat_idx, \
              "edge_serials", edge_serials
    #XXX How do I add edge_serials to serials?
    if (not edge_serials) or (len(edge_serials) == 0):
        ui_warn("EDGE: No iSCSI LUNs found")
        print "EDGE: No iSCSI LUNs found"
        return
    for serial in edge_serials:
        ui_log("<b>%s</b>" % serial)
        serials.append(serial)
    #meta
    ui_meta("%d LUNs" % len(edge_serials))
        
#------------------------------------------------------------------------------
def prefetch_one_core_debug(stat_idx=-1):
    global _debug                       # In
    global _verbosity                   # In
    global _cmd_options_set             # In
    global CMD_OPTION_SAVE              # In
    global STATS_VALUE                  # In
    global STATS_TIMESTAMP              # In
    global _corestats                   # In
    global file_systems                 # In
    global message_count                # In
    global ntfs_file_systems            # In
    global vmfs_file_systems            # In
    global vmfs_stores                  # In
    global vms                          # In
    global vmdks                        # In
    global num_file_systems             # Out
    global num_stores                   # Out
    global num_vms                      # Out
    global num_vmdks                    # Out
    global num_luns                     # Out
    file_systems = []
    ntfs_file_systems = []
    vmfs_file_systems = []
    vmfs_stores = []
    vms = []
    vmdks = []
    #
    if _corestats[stat_idx][STATS_TIMESTAMP] != None:
        core = "%s %s" % ( _corestats[stat_idx][STATS_VALUE], _corestats[stat_idx][STATS_TIMESTAMP] )
    else:
        core = _corestats[stat_idx][STATS_VALUE]
    ui_subsection("CORE")
    # Save for LUNs and meta
    saved_num_file_systems = num_file_systems
    saved_num_stores = num_stores
    saved_num_vms = num_vms
    saved_num_vmdks = num_vmdks
    saved_num_luns = num_luns
    saved_message_count = message_count.copy()
    # Overview
    ui_title("Overview %s" % core)
    core_serials = get_core_stat("/rdiskdc/*/lba_sz", KEY_ENUM, stat_idx, True)
    if (not core_serials) or (len(core_serials) == 0):
        ui_warn("CORE: No iSCSI LUNs found")
        print "CORE: No iSCSI LUNs found"
        return
    for serial in core_serials:         # LUN
        lun_path = "/prefetch/" + serial
        lun_overview(stat_idx, lun_path, serial, 0)
    # Reset for LUNs
    num_file_systems = saved_num_file_systems
    num_stores = saved_num_stores
    num_vms = saved_num_vms
    num_vmdks = saved_num_vmdks
    num_luns = saved_num_luns
    # LUNs
    ui_title("LUNs %s" % core)
    if (_debug & 2048) != 0:
        print ">>> prefetch_one_core_debug:", "stat_idx", stat_idx, \
              "core_serials", core_serials
    for serial in core_serials:         # LUN
        lun_path = "/prefetch/" + serial
        lun_debug(stat_idx, lun_path, serial, True, 2, 0)  # Was level=3
    #meta
    options = "Options: -O %d -v %d" % (_debug, _verbosity )
    if _outfile != "result":
        options += " -o %s" % _outfile
    if (_cmd_options_set & CMD_OPTION_SAVE) != 0:
        options += " -s %s" % _save_prefix
    ui_meta(options)
    ui_meta("%d LUNs" % len(core_serials))
    ui_meta("%d File systems" % len(file_systems))
    ui_meta("%d NTFS File systems" % len(ntfs_file_systems))
    ui_meta("%d VMFS File systems" % len(vmfs_file_systems))
    ui_meta("%d VMFS Stores" % len(vmfs_stores))
    ui_meta("%d VMs" % len(vms))
    ui_meta("%d VMDKs" % len(vmdks))
    if (message_count['err_warn_info'] -
        saved_message_count['err_warn_info']) != 0:
        message_count['err_warn_info'] += 1
        ui_meta('%d Errors <a href="#msg%d" name="msg%d">(First)</a>' %
                (message_count['err'] - saved_message_count['err'],
                 saved_message_count['err_warn_info'] + 1,
                 message_count['err_warn_info']))
        ui_meta('%d Warnings' %
                (message_count['warn'] - saved_message_count['warn']))
        ui_meta('%d Infos' %
                (message_count['info'] - saved_message_count['info']))
        
#------------------------------------------------------------------------------
def prefetch_edge_debug():
    global _debug                       # In
    global _edges                       # In
    global _edgestats                   # In
    global STATS_VALUE                  # In
    if (_edges == None) or (_edgestats == None):
        return
    len_edges = len(_edges)
    len_edgestats = len(_edgestats)
    if (len_edges == 0) or (len_edgestats == 0):
        return
    if (_debug & 4) != 0:
        for stat_idx in range(0, len(_edgestats)):
            prefetch_one_edge_debug(stat_idx)
    else:
        if len_edges > 1:
            ui_subsection("EDGEs not logged")
            for idx in range(0, len_edges - 1):
                ui_title("EDGE %s" % _edges[idx][STATS_VALUE])
        prefetch_one_edge_debug(-1)
        
#------------------------------------------------------------------------------
def prefetch_core_debug():
    global _debug                       # In
    global _cores                       # In
    global _corestats                   # In
    if (_cores == None) or (_corestats == None):
        return
    len_cores = len(_cores)
    len_corestats = len(_corestats)
    if (len_cores == 0) or (len_corestats == 0):
        return
    if (_debug & 4) != 0:
        for stat_idx in range(0, len_corestats):
            prefetch_one_core_debug(stat_idx)
    else:
        if len_cores > 1:
            ui_subsection("COREs not logged")
            for idx in range(0, len_cores - 1):
                ui_title("CORE %s" % _cores[idx][1])
        prefetch_one_core_debug(-1)

#------------------------------------------------------------------------------
def prefetch_debug():
    global _cmd_options_set
    global CMD_OPTION_CORE
    global CMD_OPTION_EDGE
    if (_cmd_options_set & CMD_OPTION_EDGE) != 0:
        prefetch_edge_debug() 
    if (_cmd_options_set & CMD_OPTION_CORE) != 0:
        prefetch_core_debug()
# -*- python -*-
#
# (C) Copyright 2003-2009 Riverbed Technology, Inc.  
# All rights reserved. Confidential.
#
# ------------- Prefetch debugging ---------------------------
#------------------------------------------------------------------------------
# A descriptor contains: [0] verbosity, [1] stat_path, [2] description,
# [3] units, [4] type, [5] min, [6] max, [7] min_message, [8] max_message,
# [9] test_func, [10] print_func
#
# If len() == 2: Verbosity [0], ui_title([1])
# If len() == 3: Verbosity [0], ui_log([2], alias + [1])
# If len() >= 5: Get the stat and optionally ui_log() it.  See below.
#
# If type < 0, log the statistic difference.  Use abs(type) for the type.
# This is usually used for unresetable stats.
#
# If type > 0, log the statistic value.
# This is usually used for resetable stats.
#
# If test_func is present, log if test_func resturns a true value.  Log as
# error, warning, or info if the test_func returns 'err', 'warn', or 'info',
# respectively.  Otherwise, just log.
#
# Otherwise, log if min, and max are both either not present or None, or value
# < min, or value > max.
#
# If the max or min values in the descriptor are a list, they are the ui_err(),
# ui_warn(), ui_info(), and ui_log() limits.  Use None to skip a limit if a
# lower severity limit is wanted without a higer severity limit.
#
# If the max or min values in the descriptor are not a list, they are the
# ui_log() limits.
#
# If the state is type BKT, compare min and max to the BucketStat's average in
# the same way a non-bucket stat's value is compared to min and max.
#
# Note, min and max are not used if test_func is present.  Thus they can be
# used as parameters for test_func.  For example, the function
# test_func_bkt_avg_and_max() compares both the 'avg' and the 'max' of a
# BucketStat to separate maximum limits.  min, descriptor[5], is the maximum
# limits for stat['avg'], and max, descriptor[6], is the maximum limits for
# stat['max'].
#
# If your test_func and/or print_func need more than two parameters, you can
# add more parameters after descriptor[10].
#
# There are other pre-written test functions besides the one mentioned above.
# See all functions named test_func_*.
#
# Examples:
# [ "Text" ], - ui_title("Text")
# [ 1, "Text" ], - ui_log("Text", align + 1)
# [ 0, "/fslayer/fs_state_", "", "", STR ], - Always log - len() == 5
# [ 0, "/fslayer/n_notif_fb_", "", "", INT, 0, 0 ], - Log if < 0 or > 0
# [ 0, "/fslayer/n_notif_bpclr_", "", "", INT, 0, ], - Log if < 0
# [ 0, "/fslayer/n_notif_bpclr_", "", "", INT, None, 0, ], - Log if > 0
# [ 0, "/fslayer/n_notif_fb_", "", "", INT, None, None, "", "", test_func ],
#  - Log if test_func returns True
# [ 1, "/fslayer/fs_state_", "", "", STR ], - Do not log unless -v 1

#------------------------------------------------------------------------------
# Petfood differences

# * Not renamed: stats_lun_descriptors[]: FSLayerStats:
#   "/fslayer/crawler_read_times_" to "/fslayer/read_times_"

# * Not deleted: stats_connector_descriptors[]: RdiskPFS_connector:
#   "/n_inq_notifs_rd_", "/n_inq_notifs_wr_", "/n_inq_notifs_fb_",
#   "/n_inq_notifs_bpclr_"

# * Not split up: stats_ntfs_descriptors[]: ClusterMapStats:
#   "/fslayer/ntfscrawl/cg_map/insert_time_" to
#   "/fslayer/ntfscrawl/primary,collapsed,lcn_cache/cg_map/insert_time_",
#   "/fslayer/ntfscrawl/cg_map/lookup_time_" to
#   "/fslayer/ntfscrawl/primary,collapsed,lcn_cache/cg_map/lookup_time_",
#   "/fslayer/ntfscrawl/cg_map/remove_time_" to
#   "/fslayer/ntfscrawl/primary,collapsed,lcn_cache/cg_map/remove_time_"

# * Not path corrected and split up: stats_vmdk_snapshot_descriptors[]:
#   ClusterMapStats:
#   "/cg_map/insert_time_" to "/disk2snap,snap2disk/cg_map/insert_time_",
#   "/cg_map/lookup_time_" to "/disk2snap,snap2disk/cg_map/lookup_time_",
#   "/cg_map/remove_time_" to "/disk2snap,snap2disk/cg_map/remove_time_"

# * Not deleted: stats_ntfs_descriptors[]: NtfsCrawlStats:
#   "/fslayer/ntfscrawl/n_unaligned_writes_"

# * Not added: stats_ntfs_descriptors[]: NtfsIssStats:
#   "/fslayer/ntfscrawl/n_compressed_file_reads_",
#   "/fslayer/ntfscrawl/iss/n_unaligned_lookups_",
#   "/fslayer/ntfscrawl/iss/n_unaligned_updates_".

# * Not added: stats_vmfs_store_descriptors[]: VmfsStats: "/read_sizes",
# * "/read_times"

# * Not added: stats_vmdk_descriptors[]: VmdkStats: "/descriptor_reads"

#------------------------------------------------------------------------------
# For a LUN connector
# Prefixes /rdiskPFS_connector/<lun>
# Used in lun_debug()
stats_connector_descriptors = [
    #/rdiskPFS_connector/<lun>/notif_read_bytes
    # Connector --rdisk/connector.h
    [ 1, -1, "<i>Connector statistics</i>" ],
    [ 1, "/notif_read_bytes",
      "Queued read notification bytes: Connector", "bytes",
      INT, 0, 0 ],
    [ 1, "/notif_write_bytes",
      "Queued write notification bytes: Connector", "bytes",
      INT, 0, 0 ],
    [ 1, "/notif_feedback_bytes",
      "Queued feedback notification bytes: Connector", "bytes",
      INT, 0, 0 ],
    [ 1, "/notif_prepop_bytes",
      "Queued prepop notification bytes: Connector", "bytes",
      INT, 0, 0 ],
    [ 2, "/total bp priority0",
      "# times entered push back-pressure priority 0: Connector", "",
      -INT, 0, 0 ],
    [ 2, "/total bp priority1",
      "# times entered push back-pressure priority 1: Connector", "",
      -INT, 0, 0 ],
    [ 2, "/total bp priority2",
      "# times entered push back-pressure priority 2: Connector", "",
      -INT, 0, 0 ],
    [ 2, "/total bp read",
      "# times entered read back-pressure: Connector", "", -INT, 0, 0 ],
    [ 2, "/notif total bytes",
      "Total queued bytes: Connector", "bytes", -INT, 0, 0 ],
    [ 1, "/notif queue len",
      "# queued notifications: Connector", "", -INT, 0, 0 ],
    [ 1, "/push ignored bp",
      "# Pushes to EDGE durring push back-pressure: Connector", "",
      -INT, 0, 0 ],
    [ 1, "/read ignored bp",
      "# Reads by preferch durring read back-pressure: Connector", "",
      -INT, 0, 0 ],
    ];

_all_core_stat_descriptors.extend(stats_connector_descriptors);

#------------------------------------------------------------------------------
# test_func testing "/is_blocked_" in PFStacks
# WARNING: Must come after "/is_blocked_" in stats_lun_descriptors.
# Group A
def test_func_is_blocked(path_prefix, descriptor,
                         stat_description, stat_value, align,
                         first_set, last_set):
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> test_is_blocked:", \
              "first_set", first_set, "last_set", last_set, \
              "path_prefix", path_prefix, \
              "stat_path", descriptor[1], "stat_value", stat_value, \
              "align", align

    return (fs_stats["/is_blocked_"] != 0)

#------------------------------------------------------------------------------
# For a LUN
# Prefixes /prefetch/<lun>
# Used in lun_debug()
stats_lun_descriptors = [               # XXX Done
    #/prefetch/<lun>/n_notifs_rd_
    # PFStackStats --prefetch/pfstack/pf_stack.h
    [ 0, -1, "<i>LUN statistics</i>" ],
    [ 2, "/n_pushed_[0]",
      "# Block pushes to EDGE: 0 - High: LUN level", "", -INT, 0, 0 ],
    [ 2, "/n_blks_pushed_[0]",          # Paired with n_pushed_[0]
      "# Blocks pushed to EDGE: 0 - High: LUN level", "blocks", -INT, 0, 0 ],
    [ 2, "/n_pushed_[1]",
      "# Block pushes to EDGE: 1 - Medium: LUN level", "", -INT, 0, 0 ],
    [ 2, "/n_blks_pushed_[1]",          # Paired with n_pushed_[1]
      "# Blocks pushed to EDGE: 1 - Medium: LUN level", "blocks", -INT, 0, 0 ],
    [ 2, "/n_pushed_[2]",
      "# Block pushes to EDGE: 2 - Low: LUN level", "", -INT, 0, 0 ],
    [ 2, "/n_blks_pushed_[2]",          # Paired with n_pushed_[2]
      "# Blocks pushed to EDGE: 2 - Low: LUN level", "blocks", -INT, 0, 0 ],
    [ 2, "/n_notifs_rd_",
      "# Reads from EDGE: Processed: LUN level", "", -INT, 0, 0 ],
    [ 2, "/n_notif_rd_blks_",           # Paired with n_notifs_rd_
      "# Blocks in reads from EDGE: LUN level", "blocks", -INT, 0, 0 ],
    [ 2, "/n_notifs_wr_",
      "# Writes from EDGE: Processed: LUN level", "", -INT, 0, 0 ],
    [ 2, "/n_notif_wr_blks_",           # Paired with n_notifs_wr_
      "# Blocks in writes: LUN level", "blocks", -INT, 0, 0 ],
    [ 2, "/n_notifs_fb_",
      "# Feedbacks (Read in EDGE): Processed: LUN level", "", -INT, 0, 0 ],
    [ 2, "/n_notif_fb_blks_",           # Paired with n_notifs_fb_
      "# Blocks in feedbacks (Read in EDGE): Processed: LUN level", "blocks",
      -INT, 0, 0 ],
    [ 2, "/n_notifs_bpclr_",
      "# Clear push back-pressure: Processed: LUN level", "", -INT, 0, 0 ],
    [ 2, "/n_notifs_block_prepop_",
      "# Block prepops: Processed: LUN level", "", -INT, 0, 0 ],
    [ 2, "/n_notifs_clear_state_",
      "# Restart clean", "", -INT, 0, 0 ],
    [ 0, "/push_time_", "Time to push blocks: LUN level", "", -BKT,
      [ 1 ], [ 2, 1 ],
      None, "Network CORE to EDGE slow:", test_func_bkt_avg_and_max ],
    [ 2, "/n_reads_",
      "# Reads by prefetch: LUN level", "", -INT, 0, 0 ],
    [ 2, "/n_blks_read_",               # Paired with n_reads_
      "# Blocks read by prefetch: LUN level", "blocks", -INT, 0, 0 ],
    [ 0, "/read_time_", "Time to read blocks: LUN level", "", -BKT,
      [ 10, 8 ], [ 20, 8 ], None, "Storage back end slow:",
      test_func_bkt_avg_and_max ],
    [ 2, "/n_reads_during_disk_pressure_",
      "# Reads by prefetch during disk pressure", "", -INT, 0, 0 ],
    [ 2, "/n_blks_read_during_disk_pressure_",
      # Paired with n_reads_during_disk_pressure_
      "# Blocks read by prefetch during disk pressure", "blocks", -INT, 0, 0 ],
    [ 0, "/pending_notif_bytes_",
      "Total number queued notification bytes: LUN level",
      "bytes", -INT, 0, [ (16 * 1024 * 1024) ],
      None, "Notifications slow or paused:" ],
    [ 0, "/is_blocked_",
      "Commit back-pressure", "", -INT,
      0, [ None, 0 ], None, "Prefetch blocked:" ],
    [ 0, "/n_backpressure_entered_",                  # Group A
      "# commit back-pressure entered",
      "", -INT, None, None, None, None,
      test_func_is_blocked, ], # Must be after /is_blocked_
    [ 0, "/n_backpressure_cleared_",                  # Group A
      "# commit back-pressure cleared",
      "", -INT, None, None, None, None,
      test_func_is_blocked, ], # Must be after /is_blocked_
    [ 2, "/in_bp_times_",
      "Time in commit back-pressure", "", -BKT, 0, 0 ],
    ];

_all_core_stat_descriptors.extend(stats_lun_descriptors);

#------------------------------------------------------------------------------
# For a disk partition table
# Prefix /prefetch/<lun>/diskpart
#     or /prefetch/<lun>/diskpart/data
# Used in lun_debug()
stats_diskpart_descriptors = [
    #/prefetch/<lun>/diskpart/n_parts_per_type_[0]_
    #or /prefetch/<lun>/diskpart/data/n_parts_per_type_[0]_
    # DiskPartLayerStats --prefetch/pfstack/disk_part_layer.h
    [ 1, -1, "<i>Disk partition statistics</i>" ],
    # See FSLayer::is_fs_partition_supported().  Do not display if supported.
    [ 1, "/n_parts_per_type_[0]",
      "# Partitions  0: Unused", "", -INT, 0, 0 ],
    [ 1, "/n_parts_per_type_[1]",
      "# Partitions  1: MBR", "", -INT, 0, 0 ],
    [ 1, "/n_parts_per_type_[2]",
      "# Partitions  2: GPT header", "", -INT, 0, 0 ],
    [ 1, "/n_parts_per_type_[3]",
      "# Partitions  3: GPT", "", -INT, 0, 0 ],
    [ 2, "/n_parts_per_type_[4]",
      "# Partitions  4: IFS", "", -INT, 0, 0 ],
    [ 1, "/n_parts_per_type_[5]",
      "# Partitions  5: Linux", "", -INT, 0, 0 ],
    [ 2, "/n_parts_per_type_[6]",
      "# Partitions  6: Data", "", -INT, 0, 0 ],
    [ 2, "/n_parts_per_type_[7]",
      "# Partitions  7: VMFS", "", -INT, 0, 0 ],
    [ 1, "/n_parts_per_type_[8]",
      "# Partitions  8: Shadow", "", -INT, 0, 0 ],
    [ 1, "/n_parts_per_type_[9]",
      "# Partitions  9: LDM meta", "", -INT, 0, 0 ],
    [ 1, "/n_parts_per_type_[10]",
      "# Partitions 10: LDM data", "", -INT, 0, 0 ],
    [ 1, "/n_parts_per_type_[11]",
      "# Partitions 11: Logical Drive", "", -INT, 0, 0 ],
    [ 1, "/n_parts_per_type_[12]",
      "# Partitions 12: Unsupported", "", -INT, 0, 0 ],
    [ 2, "/n_ptabmeta_reads_",
      "# Partition table reads", "", -INT, 0, 0 ],
    [ 2, "/n_ptabmeta_writes_",
      "# Partition table writes", "", -INT, 0, 0 ],
    [ 1, "/n_ptab_rah_blks_",
      "# Blocks pushed: Part table RAH", "blocks", -INT, 0, 0 ],
    [ 1, "/n_gen_rah_blks_",
      "# Blocks pushed: Generic RAH", "blocks", -INT, 0, 0 ],
    [ 2, "/n_part_created_", "# Paritions created", "", -INT, 0, 0 ],
    [ 2, "/n_part_deleted_", "# Paritions deleted", "", -INT, 0, 0 ],
    [ 2, "/n_part_formatted_", "# Paritions formatted", "", -INT, 0, 0 ],
    [ 2, "/n_part_modified_", "# Partitions modified", "", -INT, 0, 0 ],
    [ 2, "/n_ptab_updated_", "# Partition regions updated", "", -INT, 0, 0 ],
    [ 1, "/n_nofs_", "# Partitions created without a file system", "",
      -INT, 0, 0 ],
    [ 2, "/n_notif_nofs_", "# Reads/Writes from EDGE: No file system", "",
      -INT, 0, 0 ],
    [ 2, "/n_notif_unsupp_", "# Reads/Writes from EDGE: 12 Unsupported", "",
      -INT, 0, 0 ],
    [ 2, "/n_notif_unused_", "# Reads/Writes from EDGE:0 Unused", "",
      -INT, 0, 0 ],
    [ 2, "/n_crawls_ok_", "# Successful crawls", "", -INT, 0, 0 ],
    [ 1, "/n_crawls_err_", "# Failed crawls", "", -INT, 0, [ 0 ] ],
    [ 2, "/n_critical_region_writes_", "# Writes to critical regions", "",
      -INT, 0, 0 ],
    [ 2, "/n_paused_by_fs_",
      "# times paused for critical region update", "", -INT, 0, 0 ],
    [ 2, "/n_resumed_by_fs_",
      "# times resumed after critial region update", "", -INT, 0, 0 ],
    [ 2, "/n_notifs_deferred_",
      "# notifs deferred for critical region update", "",
      -INT, 0, 0 ],
    [ 2, "/n_notifs_deferred_bytes_",   # Paired with n_notifs_deferred_
      "# bytes in deferred notifications", "bytes", -INT, 0, 0 ],
    [ 2, "/n_notifs_resumed_", "# notifs resumed", "", -INT, 0, 0 ],
    [ 2, "/n_notifs_resumed_bytes_", # Paired with n_notifs_resumed_
      "# bytes in resumed notifications", "bytes", -INT, 0, 0 ],
    [ 2, "/n_notifs_replayed_",
      "# notifs replayed when file system re-created", "", -INT, 0, 0 ],
    [ 2, "/n_notifs_replayed_bytes_", # Paired with n_notifs_replayed_
      "# bytes in replayed notifications", "bytes", -INT, 0, 0 ],
    ];

_all_core_stat_descriptors.extend(stats_diskpart_descriptors);

#------------------------------------------------------------------------------
# For NTFS file systems
# Prefix /prefetch/<lun>/diskpart/<partition>
#     or /prefetch/<lun>/diskpart/data/<partition>
# Used in file_system_debug()
stats_child_descriptors = [
    [ 0, -1, "<i>Threads for NTFS file systems statistics</i>" ],
    #/prefetch/<lun>/diskpart/<partition>/threaded_child/n_inq_notifs_[0]_total
    # ThreadedChild --prefetch/pfstack/pf_layer.h
    [ 1, "/threaded_child/n_inq_notifs_[0]",
      "# Write notifs in queue[0]", "", -INT, 0, 0 ],
    [ 1, "/threaded_child/n_inq_notifs_[1]",
      "# Other notifs in queue[1]", "", -INT, 0, 0 ],
    [ 2, "/threaded_child/n_total_notifs_[0]",
      "# Write notifs received[0]", "", -INT, 0, 0 ],
    [ 2, "/threaded_child/n_total_notifs_[1]",
      "# Other notifs received[1]", "", -INT, 0, 0 ],
    [ 2, "/threaded_child/n_times_notifq_empty_[0]",
      "# times write notif queue[0] empty", "", -INT, 0, 0 ],
    [ 2, "/threaded_child/n_times_notifq_empty_[1]",
      "# times other notif queue[1] empty", "", -INT, 0, 0 ],
    [ 2, "/threaded_child/n_notifs_dispatched_",
      "# notifs dispatched", "", -INT, 0, 0 ],
    [ 0, "/threaded_child/total_notification_bytes_",
      "Queued notification bytes: File system level",
      "bytes", -INT, 0, [ (2 * 1024 * 1024) ],
      None, "Prefetch slow:"],
    ];

_all_core_stat_descriptors.extend(stats_child_descriptors);

#------------------------------------------------------------------------------
OK_regexp = re.compile("-OK$")          # For /fslayer/fs_state_

#------------------------------------------------------------------------------
# Demonstrate the first method for printing a group of statistics.
# test_func testing "/fslayer/pftech/*/n_bytes_prefetched_bef_bp_",
def test_bytes_prefetched_bef_bp(path_prefix, descriptor,
                                 stat_description,
                                 bytes_prefetched, bytes_prefetched_bef_bp,
                                 align, first_set, last_set):
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> test_bytes_prefetched_bef_bp:", \
              "first_set", first_set, "last_set", last_set, \
              "path_prefix", path_prefix, "stat_path", descriptor[1], \
              "bytes_prefetched", bytes_prefetched, \
              "bytes_prefetched_bef_bp", bytes_prefetched_bef_bp, \
              "align", align
    # Test unconditional
    minimums = list_get_or_default(descriptor, 5)
    maximums = list_get_or_default(descriptor, 6)

    if (minimums == None) and (maximums == None):
        if (_debug & 4096) != 0:
            print ">>> test_bytes_prefetched_bef_bp: (At start) returns", True
        return True

    # Test if total < minimum(s)
    total_min_result = test_value_vs_limits(bytes_prefetched['aggregate'],
                                            minimums, test_minimum)
    if not total_min_result:
        # Test 'avg' bef_bp < minimum(s)
        min_result = test_bucket_stat_one_key_vs_minimums(
            path_prefix, descriptor, stat_description, 'avg',
            bytes_prefetched_bef_bp, align, minimums)
        if min_result and (min_result[0] != True):
            if (_debug & 4096) != 0:
                print ">>> test_func_bytes_prefetched_bef_bp:" \
                      " (After min) returns", min_result
            return min_result
    else:
        min_result = False

    # Test %0s > maximum(s)
    data = bytes_prefetched_bef_bp['data']
    num_samples = sum(data[:])
    num_zeroes = data[0]
    if num_samples != 0:
        percent_zeroes = (100 * num_zeroes) / num_samples
    else:
        percent_zeroes = 0.0

    stat_description = "%0s in " + stat_description
    zeroes_result = test_value_vs_maximums(path_prefix, descriptor,
                                           stat_description,
                                           percent_zeroes, align,
                                           maximums)
    if zeroes_result and zeroes_result != True:
        if (_debug & 4096) != 0:
            print ">>> test_bytes_prefetched_bef_bp:" \
                  " (After zeroes) returns", zeroes_result
        return zeroes_result

    # Combine results
    if min_result:
        result = min_result
    else:
        result = zeroes_result

    if (_debug & 4096) != 0:
        print ">>> test_bytes_prefetched_bef_bp: (At end) returns", \
              result
    return result

# Group 9
def test_func_file_rah_bytes_prefetched_bef_bp(path_prefix, descriptor,
                                               stat_description, stat_value,
                                               align, first_set, last_set):
    global _debug                       # In
    global fs_stats                     # In
    if (_debug & 4096) != 0:
        print ">>> test_func_file_rah_bytes_prefetched_bef_bp:", \
              "first_set", first_set, "last_set", last_set, \
              "path_prefix", path_prefix, "stat_path", descriptor[1], \
              "stat_value", stat_value, "align", align
    bytes_prefetched = fs_stats["/fslayer/pftech/file_rah/n_bytes_prefetched_"]
    return test_bytes_prefetched_bef_bp(path_prefix, descriptor,
                                        stat_description,
                                        bytes_prefetched, stat_value,
                                        align, first_set, last_set)

def print_func_file_rah_bytes_prefetched_bef_bp(path_prefix, descriptor,
                                                stat_path, stat_description,
                                                level, align, stat, lvl):
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> print_func_file_rah_bytes_prefetched_bef_bp:", \
              "path_prefix", path_prefix, \
              "stat_path", descriptor[1], "stat_value", stat
    descriptors = descriptor[11]
    if (type(lvl) == type((1, 2)) ) and  (lvl[0] != True):
        use_level = ( lvl[0], 'aggregate' )
    else:
        use_level = lvl
    for stat_path in [ 
        "/fslayer/pftech/file_rah/n_bytes_prefetched_",
        "/fslayer/pftech/file_rah/n_bytes_prefetched_bef_bp_" ]:
        print_func_normal(path_prefix,
                          find_descriptor(descriptors, stat_path),
                          stat_path, None, level, align, fs_stats[stat_path],
                          use_level)
        use_level = lvl

# Group 10
def test_func_dir_rah_bytes_prefetched_bef_bp(path_prefix, descriptor,
                                              stat_description, stat_value,
                                              align, first_set, last_set):
    global _debug                       # In
    global fs_stats                     # In
    if (_debug & 4096) != 0:
        print ">>> test_func_dir_rah_bytes_prefetched_bef_bp:", \
              "first_set", first_set, "last_set", last_set, \
              "path_prefix", path_prefix, "stat_path", descriptor[1], \
              "stat_value", stat_value, "align", align
    bytes_prefetched = fs_stats["/fslayer/pftech/dir_rah/n_bytes_prefetched_"]
    return test_bytes_prefetched_bef_bp(path_prefix, descriptor,
                                        stat_description,
                                        bytes_prefetched, stat_value,
                                        align, first_set, last_set)

def print_func_dir_rah_bytes_prefetched_bef_bp(path_prefix, descriptor,
                                               stat_path, stat_description,
                                               level, align, stat, lvl):
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> print_func_dir_rah_bytes_prefetched_bef_bp:", \
              "path_prefix", path_prefix, \
              "stat_path", descriptor[1], "stat_value", stat
    descriptors = descriptor[11]
    if (type(lvl) == type((1, 2)) ) and  (lvl[0] != True):
        use_level = ( lvl[0], 'aggregate' )
    else:
        use_level = lvl
    for stat_path in [ 
        "/fslayer/pftech/dir_rah/n_bytes_prefetched_",
        "/fslayer/pftech/dir_rah/n_bytes_prefetched_bef_bp_" ]:
        print_func_normal(path_prefix,
                          find_descriptor(descriptors, stat_path),
                          stat_path, None, level, align, fs_stats[stat_path],
                          use_level)
        use_level = lvl

# Group 11
def test_func_win_pf_bytes_prefetched_bef_bp(path_prefix, descriptor,
                                             stat_description, stat_value,
                                             align, first_set, last_set):
    global _debug                       # In
    global fs_stats                     # In
    if (_debug & 4096) != 0:
        print ">>> test_func_win_pf_bytes_prefetched_bef_bp:", \
              "first_set", first_set, "last_set", last_set, \
              "path_prefix", path_prefix, "stat_path", descriptor[1], \
              "stat_value", stat_value, "align", align
    bytes_prefetched = fs_stats["/fslayer/pftech/win_pf/n_bytes_prefetched_"]
    return test_bytes_prefetched_bef_bp(path_prefix, descriptor,
                                        stat_description,
                                        bytes_prefetched, stat_value,
                                        align, first_set, last_set)

def print_func_win_pf_bytes_prefetched_bef_bp(path_prefix, descriptor,
                                              stat_path, stat_description,
                                              level, align, stat, lvl):
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> print_func_win_pf_bytes_prefetched_bef_bp:", \
              "path_prefix", path_prefix, \
              "stat_path", descriptor[1], "stat_value", stat
    descriptors = descriptor[11]
    if (type(lvl) == type((1, 2)) ) and  (lvl[0] != True):
        use_level = ( lvl[0], 'aggregate' )
    else:
        use_level = lvl
    for stat_path in [ 
        "/fslayer/pftech/win_pf/n_bytes_prefetched_",
        "/fslayer/pftech/win_pf/n_bytes_prefetched_bef_bp_" ]:
        print_func_normal(path_prefix,
                          find_descriptor(descriptors, stat_path),
                          stat_path, None, level, align, fs_stats[stat_path],
                          use_level)
        use_level = lvl

# Group 12
def test_func_exe_dll_bytes_prefetched_bef_bp(path_prefix, descriptor,
                                              stat_description, stat_value,
                                              align, first_set, last_set):
    global _debug                       # In
    global fs_stats                     # In
    if (_debug & 4096) != 0:
        print ">>> test_func_exe_dll_bytes_prefetched_bef_bp:", \
              "first_set", first_set, "last_set", last_set, \
              "path_prefix", path_prefix, "stat_path", descriptor[1], \
              "stat_value", stat_value, "align", align
    bytes_prefetched = fs_stats["/fslayer/pftech/exe_dll/n_bytes_prefetched_"]
    return test_bytes_prefetched_bef_bp(path_prefix, descriptor,
                                        stat_description,
                                        bytes_prefetched, stat_value,
                                        align, first_set, last_set)

def print_func_exe_dll_bytes_prefetched_bef_bp(path_prefix, descriptor,
                                               stat_path, stat_description,
                                               level, align, stat, lvl):
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> print_func_exe_dll_bytes_prefetched_bef_bp:", \
              "path_prefix", path_prefix, \
              "stat_path", descriptor[1], "stat_value", stat
    descriptors = descriptor[11]
    if (type(lvl) == type((1, 2)) ) and  (lvl[0] != True):
        use_level = ( lvl[0], 'aggregate' )
    else:
        use_level = lvl
    for stat_path in [ 
        "/fslayer/pftech/exe_dll/n_bytes_prefetched_",
        "/fslayer/pftech/exe_dll/n_bytes_prefetched_bef_bp_" ]:
        print_func_normal(path_prefix,
                          find_descriptor(descriptors, stat_path),
                          stat_path, None, level, align, fs_stats[stat_path],
                          use_level)
        use_level = lvl

#------------------------------------------------------------------------------
# Demonstrate the first method for printing a group of statistics.
# test_func testing file % non-sequential reads
# Group 1
def test_func_file_non_sequential(path_prefix, descriptor,
                                  stat_description, stat_value, align,
                                  first_set, last_set):
    global _debug                       # In
    global fs_stats                     # In
    if (_debug & 4096) != 0:
        print ">>> test_func_file_non_sequential:", \
              "first_set", first_set, "last_set", last_set, \
              "path_prefix", path_prefix, "stat_path", descriptor[1], \
              "stat_value", stat_value, "align", align
    total_file_reads = (fs_stats["/fslayer/pftech/mgr/n_file_reads_"] +
                        fs_stats["/fslayer/pftech/mgr/n_file_fb_"])
    if total_file_reads != 0:
        total_file_non_seq_reads = (
            fs_stats["/fslayer/pftech/mgr/n_file_non_seq_reads_"] +
            fs_stats["/fslayer/pftech/mgr/n_file_non_seq_fb_"])
        percent = (100 * total_file_non_seq_reads) / total_file_reads
        result = test_value_vs_maximums(path_prefix, descriptor,
                                        "% non-sequential file reads", percent,
                                        align)
    else:
        result = False

    if (_debug & 4096) != 0:
        print ">>> test_func_file_non_sequential: returns", result
    return result

#------------------------------------------------------------------------------
# Demonstrate the first method for printing a group of statistics.
# print_func printing all releveant stats for file % non-sequential reads
# They were not printed earlier since the test_func had to run first.
# Group 1
def print_func_file_non_sequential(path_prefix, descriptor, stat_path,
                                   stat_description, level, align, stat, lvl):
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> print_func_file_non_sequential:", \
              "path_prefix", path_prefix, \
              "stat_path", descriptor[1], "stat_value", stat
    descriptors = descriptor[11]
    for stat_path in [ 
        "/fslayer/pftech/mgr/n_file_reads_",
        "/fslayer/pftech/mgr/n_file_fb_",
        "/fslayer/pftech/mgr/n_file_non_seq_reads_",
        "/fslayer/pftech/mgr/n_file_non_seq_fb_" ]:
        print_func_normal(path_prefix,
                          find_descriptor(descriptors, stat_path),
                          stat_path, None, level, align, fs_stats[stat_path],
                          lvl)

#------------------------------------------------------------------------------
# Demonstrate the first method for printing a group of statistics.
# test_func testing dir % non-sequential reads
# Group 4
def test_func_dir_non_sequential(path_prefix, descriptor,
                                 stat_description, stat_value, align,
                                 first_set, last_set):
    global _debug                       # In
    global fs_stats                     # In
    if (_debug & 4096) != 0:
        print ">>> test_func_dir_non_sequential:", \
              "first_set", first_set, "last_set", last_set, \
              "path_prefix", path_prefix, "stat_path", descriptor[1], \
              "stat_value", stat_value, "align", align
    total_dir_reads = (fs_stats["/fslayer/pftech/mgr/n_dir_reads_"] +
                   fs_stats["/fslayer/pftech/mgr/n_dir_fb_"])
    if total_dir_reads != 0:
        total_dir_non_seq_reads = (
            fs_stats["/fslayer/pftech/mgr/n_dir_non_seq_reads_"] +
            fs_stats["/fslayer/pftech/mgr/n_dir_non_seq_fb_"])
        percent = (100 * total_dir_non_seq_reads) / total_dir_reads
        result = test_value_vs_maximums(path_prefix, descriptor,
                                        "% non-sequential dir reads", percent,
                                        align)
    else:
        result = False

    if (_debug & 4096) != 0:
        print ">>> test_func_dir_non_sequential: returns", result
    return result

#------------------------------------------------------------------------------
# Demonstrate the first method for printing a group of statistics.
# print_func printing all releveant stats for dir % non-sequential reads
# They were not printed earlier since the test_func had to run first.
# Group 4
def print_func_dir_non_sequential(path_prefix, descriptor, stat_path,
                                  stat_description, level, align, stat, lvl):
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> print_func_dir_non_sequential:", \
              "path_prefix", path_prefix, \
              "stat_path", descriptor[1], "stat_value", stat
    descriptors = descriptor[11]
    for stat_path in [ 
        "/fslayer/pftech/mgr/n_dir_reads_",
        "/fslayer/pftech/mgr/n_dir_fb_",
        "/fslayer/pftech/mgr/n_dir_non_seq_reads_",
        "/fslayer/pftech/mgr/n_dir_non_seq_fb_" ]:
        print_func_normal(path_prefix,
                          find_descriptor(descriptors, stat_path),
                          stat_path, None, level, align, fs_stats[stat_path],
                          lvl)

#------------------------------------------------------------------------------
# Demonstrate the first method for printing a group of statistics.
# test_func testing file % first reads
# Group 2
def test_func_file_first_reads(path_prefix, descriptor,
                               stat_description, stat_value, align,
                               first_set, last_set):
    global _debug                       # In
    global fs_stats                     # In
    if (_debug & 4096) != 0:
        print ">>> test_func_file_first_reads:", \
              "first_set", first_set, "last_set", last_set, \
              "path_prefix", path_prefix, "stat_path", descriptor[1], \
              "stat_value", stat_value, "align", align
    total_file_reads = (fs_stats["/fslayer/pftech/mgr/n_file_reads_"] +
                        fs_stats["/fslayer/pftech/mgr/n_file_fb_"])
    if total_file_reads != 0:
        file_first_reads = (
            fs_stats["/fslayer/pftech/mgr/n_file_reads_"] -
            (fs_stats["/fslayer/pftech/mgr/n_file_non_seq_reads_"] +
             fs_stats["/fslayer/pftech/mgr/n_file_seq_reads_"]))
        percent = (100 * file_first_reads) / total_file_reads
        result = test_value_vs_maximums(path_prefix, descriptor,
                                        "% first file reads", percent, align)
    else:
        result = False

    if (_debug & 4096) != 0:
        print ">>> test_func_file_first_reads: returns", result
    return result

#------------------------------------------------------------------------------
# Demonstrate the first method for printing a group of statistics.
# print_func printing all releveant stats for file % first reads
# They were not printed earlier since the test_func had to run first.
# Group 2
def print_func_file_first_reads(path_prefix, descriptor, stat_path,
                                stat_description, level, align, stat,
                                lvl):
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> print_func_file_first_reads:", "path_prefix", path_prefix, \
              "stat_path", descriptor[1], "stat_value", stat
    descriptors = descriptor[11]
    for stat_path in [ 
        "/fslayer/pftech/mgr/n_file_reads_",
        "/fslayer/pftech/mgr/n_file_fb_",
        "/fslayer/pftech/mgr/n_file_non_seq_reads_",
        "/fslayer/pftech/mgr/n_file_seq_reads_" ]:
        print_func_normal(path_prefix,
                          find_descriptor(descriptors, stat_path),
                          stat_path, None, level, align, fs_stats[stat_path],
                          lvl)

#------------------------------------------------------------------------------
# Demonstrate the first method for printing a group of statistics.
# test_func testing dir % first reads
# Group 5
def test_func_dir_first_reads(path_prefix, descriptor,
                              stat_description, stat_value, align,
                              first_set, last_set):
    global _debug                       # In
    global fs_stats                     # In
    if (_debug & 4096) != 0:
        print ">>> test_func_dir_first_reads:", \
              "first_set", first_set, "last_set", last_set, \
              "path_prefix", path_prefix, "stat_path", descriptor[1], \
              "stat_value", stat_value, "align", align
    total_dir_reads = (fs_stats["/fslayer/pftech/mgr/n_dir_reads_"] +
                        fs_stats["/fslayer/pftech/mgr/n_dir_fb_"])
    if total_dir_reads != 0:
        dir_first_reads = (
            fs_stats["/fslayer/pftech/mgr/n_dir_reads_"] -
            (fs_stats["/fslayer/pftech/mgr/n_dir_non_seq_reads_"] +
             fs_stats["/fslayer/pftech/mgr/n_dir_seq_reads_"]))
        percent = (100 * dir_first_reads) / total_dir_reads
        result = test_value_vs_maximums(path_prefix, descriptor,
                                        "% first dir reads", percent, align)
    else:
        result = False

    if (_debug & 4096) != 0:
        print ">>> test_func_dir_first_reads: returns", result
    return result

#------------------------------------------------------------------------------
# Demonstrate the first method for printing a group of statistics.
# print_func printing all releveant stats for dir % first reads
# They were not printed earlier since the test_func had to run first.
# Group 5
def print_func_dir_first_reads(path_prefix, descriptor, stat_path,
                               stat_description, level, align, stat,
                               lvl):
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> print_func_dir_first_reads:", "path_prefix", path_prefix, \
              "stat_path", descriptor[1], "stat_value", stat
    descriptors = descriptor[11]
    for stat_path in [ 
        "/fslayer/pftech/mgr/n_dir_reads_",
        "/fslayer/pftech/mgr/n_dir_fb_",
        "/fslayer/pftech/mgr/n_dir_non_seq_reads_",
        "/fslayer/pftech/mgr/n_dir_seq_reads_" ]:
        print_func_normal(path_prefix,
                          find_descriptor(descriptors, stat_path),
                          stat_path, None, level, align, fs_stats[stat_path],
                          lvl)

#------------------------------------------------------------------------------
# Demonstrate the first method for printing a group of statistics.
# test_func testing file % crossovers
# Group 3
def test_func_file_crossover(path_prefix, descriptor,
                             stat_description, stat_value, align,
                             first_set, last_set):
    global _debug                       # In
    global fs_stats                     # In
    if (_debug & 4096) != 0:
        print ">>> test_func_file_crossover:", \
              "first_set", first_set, "last_set", last_set, \
              "path_prefix", path_prefix, "stat_path", descriptor[1], \
              "stat_value", stat_value, "align", align
    total_file_reads = (fs_stats["/fslayer/pftech/mgr/n_file_reads_"] +
                        fs_stats["/fslayer/pftech/mgr/n_file_fb_"])
    if total_file_reads != 0:
        total_crossovers = (
            fs_stats["/fslayer/pftech/mgr/n_file_dup_reads_"] +
            fs_stats["/fslayer/pftech/mgr/n_file_dup_fb_"])
        percent = (100 * total_crossovers) / total_file_reads
        result = test_value_vs_maximums(path_prefix, descriptor,
                                        "% crossovers of file reads", percent,
                                        align)
    else:
        result = False

    if (_debug & 4096) != 0:
        print ">>> test_func_file_crossover: returns", result
    return result

#------------------------------------------------------------------------------
# Demonstrate the first method for printing a group of statistics.
# print_func printing all releveant stats for file % non-sequential reads
# They were not printed earlier since the test_func had to run first.
# Group 3
def print_func_file_crossover(path_prefix, descriptor, stat_path,
                              stat_description, level, align, stat, lvl):
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> print_func_file_crossover:", "path_prefix", path_prefix, \
              "stat_path", descriptor[1], "stat_value", stat
    descriptors = descriptor[11]
    for stat_path in [ 
        "/fslayer/pftech/mgr/n_file_reads_",
        "/fslayer/pftech/mgr/n_file_fb_",
        "/fslayer/pftech/mgr/n_file_dup_reads_",
        "/fslayer/pftech/mgr/n_file_dup_fb_" ]:
        print_func_normal(path_prefix,
                          find_descriptor(descriptors, stat_path),
                          stat_path, None, level, align, fs_stats[stat_path],
                          lvl)

#------------------------------------------------------------------------------
# Demonstrate the first method for printing a group of statistics.
# test_func testing dir % crossovers
# Group 6
def test_func_dir_crossover(path_prefix, descriptor,
                            stat_description, stat_value, align,
                            first_set, last_set):
    global _debug                       # In
    global fs_stats                     # In
    if (_debug & 4096) != 0:
        print ">>> test_func_dir_crossover:", \
              "first_set", first_set, "last_set", last_set, \
              "path_prefix", path_prefix, "stat_path", descriptor[1], \
              "stat_value", stat_value, "align", align
    total_dir_reads = (fs_stats["/fslayer/pftech/mgr/n_dir_reads_"] +
                        fs_stats["/fslayer/pftech/mgr/n_dir_fb_"])
    if total_dir_reads != 0:
        total_crossovers = (
            fs_stats["/fslayer/pftech/mgr/n_dir_dup_reads_"] +
            fs_stats["/fslayer/pftech/mgr/n_dir_dup_fb_"])
        percent = (100 * total_crossovers) / total_dir_reads
        result = test_value_vs_maximums(path_prefix, descriptor,
                                        "% crossovers of dir reads", percent,
                                        align)
    else:
        result = False

    if (_debug & 4096) != 0:
        print ">>> test_func_dir_crossover: returns", result
    return result

#------------------------------------------------------------------------------
# Demonstrate the first method for printing a group of statistics.
# print_func printing all releveant stats for dir % non-sequential reads
# They were not printed earlier since the test_func had to run first.
# Group 6
def print_func_dir_crossover(path_prefix, descriptor, stat_path,
                             stat_description, level, align, stat, lvl):
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> print_func_dir_crossover:", "path_prefix", path_prefix, \
              "stat_path", descriptor[1], "stat_value", stat
    descriptors = descriptor[11]
    for stat_path in [ 
        "/fslayer/pftech/mgr/n_dir_reads_",
        "/fslayer/pftech/mgr/n_dir_fb_",
        "/fslayer/pftech/mgr/n_dir_dup_reads_",
        "/fslayer/pftech/mgr/n_dir_dup_fb_" ]:
        print_func_normal(path_prefix,
                          find_descriptor(descriptors, stat_path),
                          stat_path, None, level, align, fs_stats[stat_path],
                          lvl)
    
#------------------------------------------------------------------------------
# For all file systems
# Prefix /prefetch/<lun>/diskpart/<partition>
#     or /prefetch/<lun>/diskpart/data/<partition>
# Used in file_system_debug()
stats_fs_descriptors = [                # XXX Done
    [ 0, -1, "<i>File system statistics</i>" ],
    #/prefetch/<lun>/diskpart/<partition>/fslayer/fs_state_
    # FSLayerStats --prefetch/pfstack/fs_layer.h
    [ 0, "/fslayer/fs_state_", "File system state", "", STR,
      OK_regexp, 'err', None, "Not OK:", test_func_not_search_regexp ],
    [ 2, "/fslayer/n_notif_rd_",
      "# Reads from EDGE: Processed: File system level", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_notif_wr_",
      "# Writes from EDGE: Processed: File system level", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_notif_wr_blks_",   # Paired with n_notif_wr_
      "# Blocks in writes: File system level", "blocks", -INT, 0, 0 ],
    [ 2, "/fslayer/n_notif_fb_",
      "# Feedbacks (Read in EDGE): Processed: File system level",
      "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_notif_bpclr_",
      "# Clear push back-pressure: Processed: File system level",
      "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_notif_wr_merged_with_saved_", # Second
      "# Saved unaligned writes merged with a later write", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_notif_wr_postponed_", # First
      "# Unaligned writes saved for later", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_notif_wr_saved_",  # Second
      "# Saved unaligned writes queued", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_notif_wr_processed_", # Third
      "# Writes processed", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_notif_wr_processed_blks_",
      # Paired with n_notif_wr_processed_
      "# Blocks in writes processed", "blocks", -INT, 0, 0 ],
    [ 2, "/fslayer/n_inode_dump_time_",
      "Inode dump time", "msec", -INT, 0, 0 ],
    [ 2, "/fslayer/n_push_",
      "# Block pushes to EDGE: File system level", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_blks_pushed_",     # Paired with n_push_
      "# Blocks pushed to EDGE: File system level", "blocks", -INT, 0, 0 ],
    [ 2, "/fslayer/n_crawler_reads_",
      "# Reads by prefetch: File system level", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_crawler_blks_read_", # Paired with n_crawler_reads_
      "# Blocks read by prefetch: File system level", "blocks", -INT, 0, 0 ],
    [ 2, "/fslayer/n_files_pushed_",
      "# Files pushed to EDGE: File system level", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_file_push_bytes_", # Paired with n_files_pushed_
      "# File bytes pushed to EDGE: File system level", "bytes", -INT, 0, 0 ],
    [ 2, "/fslayer/n_files_read_",
      "# Files read by prefetch: File system level", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_file_read_bytes_", # Paired with n_files_read
      "# File bytes read by prefetch: File system level", "bytes", -INT, 0, 0],
    [ 0, "/fslayer/n_blkoff_xlate_errs_", "# Block translation failures",
      "", -INT, 0, [ 0 ], None,
      "Meta writes not processed before needed: File system level:" ],
    [ 1, "/fslayer/n_unaligned_writes_",
      "# Unaligned writes: File system level", "", -INT, 0, 0 ],
    [ 1, "/fslayer/n_unaligned_reads_",
      "# Unaligned reads from EDGE: File system level", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_inoderec_pushed_",
      "# inode records pushed: File system level", "", -INT, 0, 0 ],
    [ 0, "/fslayer/push_times_", "Time to push blocks: File system level",
      "", -BKT, [ 1 ], [ 2, 1 ],
      None, "Network CORE to EDGE slow:", test_func_bkt_avg_and_max ],
    [ 0, "/fslayer/read_times_", "Time to read blocks: File system level",
      "", -BKT, [ 10, 8 ], [ 20, 8 ],
      None, "Storage back end slow:", test_func_bkt_avg_and_max ],
    [ 1, "/fslayer/notif_rd_times_",
      "Response time: Read from EDGE", "", -BKT, 0, 0 ],
    [ 1, "/fslayer/notif_wr_times_",
      "Response time: Write from EDGE", "", -BKT, 0, 0 ],
    [ 1, "/fslayer/notif_fb_times_",
      "Response time: Feedback (Read in EDGE)", "", -BKT, 0, 0 ],
    [ 1, "/fslayer/notif_bp_clear_times_",
      "Response time: Clear push back-pressure", "", -BKT, 0, 0 ],
    [ 2, "/fslayer/n_no_prefetch_op-FILE_READ",
      "Op: No prefetch: FILE_READ", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_no_prefetch_fb-FILE_READ",
      "Feedback: No prefetch: FILE_READ", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_no_prefetch_op-FILE_CREATE",
      "Op: No prefetch: FILE_CREATE", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_no_prefetch_fb-FILE_CREATE",
      "Feedback: No prefetch: FILE_CREATE", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_no_prefetch_op-FILE_DELETE",
      "Op: No prefetch: FILE_DELETE", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_no_prefetch_fb-FILE_DELETE",
      "Feedback: No prefetch: FILE_DELETE", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_no_prefetch_op-FILE_WRITE",
      "Op: No prefetch: FILE_WRITE", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_no_prefetch_fb-FILE_WRITE",
      "Feedback: No prefetch: FILE_WRITE", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_no_prefetch_op-FILE_META_READ",
      "Op: No prefetch: FILE_META_READ", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_no_prefetch_fb-FILE_META_READ",
      "Feedback: No prefetch: FILE_META_READ", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_no_prefetch_op-FILE_META_WRITE",
      "Op: No prefetch: FILE_META_WRITE", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_no_prefetch_fb-FILE_META_WRITE",
      "Feedback: No prefetch: FILE_META_WRITE", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_no_prefetch_op-DIR_READ",
      "Op: No prefetch: DIR_READ", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_no_prefetch_fb-DIR_READ",
      "Feedback: No prefetch: DIR_READ", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_no_prefetch_op-DIR_META_READ",
      "Op: No prefetch: DIR_META_READ", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_no_prefetch_fb-DIR_META_READ",
      "Feedback: No prefetch: DIR_META_READ", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_no_prefetch_op-UNKNOWN",
      "Op: No prefetch: UNKNOWN", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_no_prefetch_fb-UNKNOWN",
      "Feedback: No prefetch: UNKNOWN", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_no_prefetch_op-DIR_WRITE",
      "Op: No prefetch: DIR_WRITE", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_no_prefetch_fb-DIR_WRITE",
      "Feedback: No prefetch: DIR_WRITE", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_no_prefetch_op-FILE_INDIRECT_META_WRITE",
      "Op: No prefetch: FILE_INDIRECT_META_WRITE", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_no_prefetch_fb-FILE_INDIRECT_META_WRITE",
      "Feedback: No prefetch: FILE_INDIRECT_META_WRITE", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_ingress_notifs_rd_",
      "# Reads received", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_ingress_notifs_wr_",
      "# Writes received", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_ingress_notifs_fb_",
      "# Feedbacks (Read in EDGE) received", "", -INT, 0, 0 ],
    [ 2, "/fslayer/n_ingress_notifs_bpclr_",
      "# Clear push back-pressure received", "", -INT, 0, 0 ],
    #/prefetch/<lun>/diskpart/<partition>/fslayer/pftech/mgr/n_mft_reads_
    # mgr - TechMgrStats --prefetch/pfstack/tech/pf_tech_mgr.h
    [ 0, -1, "<i>Prefetch technique: Access statistics</i>" ],
    [ 1, "/fslayer/pftech/mgr/n_mft_reads_",
      "# Reads for MFT (Metadata) not in EDGE", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/mgr/n_mft_fb_",
      "# Feedbacks (Read in EDGE) for MFT (Metadata) in EDGE", "", -INT, 0, 0 ],
    # Files
    [ 0, "/fslayer/pftech/mgr/n_file_reads_",         # Groups 1, 2, 3
      "# Reads for file data not in EDGE", "", -INT, 0, 0,
      None, None, test_func_never_log ],
    [ 0, "/fslayer/pftech/mgr/n_file_fb_",            # Groups 1, 2, 3
      "# Feedbacks (Read in EDGE) for file data in EDGE", "", -INT, 0, 0, 
      None, None, test_func_never_log ],
    [ 0, "/fslayer/pftech/mgr/n_file_non_seq_reads_", # Groups 1, 2
      "# Non-sequential reads for file data not in EDGE", "", -INT, 0, 0, 
      None, None, test_func_never_log ],
    [ 0, "/fslayer/pftech/mgr/n_file_non_seq_fb_",    # Print Group 1
      "# Non-sequential feedbacks (Read in EDGE) for file data in EDGE", "",
      -INT, 0, [ 10 ],
      None, "File prefetch ineffective (Too many non-sequential reads):",
      test_func_file_non_sequential, print_func_file_non_sequential ],
    [ 0, "/fslayer/pftech/mgr/n_file_seq_reads_",     # Print Group 2
      "# Sequential reads for file data not in EDGE", "", -INT, 0, [ 10 ],
      None, "File prefetch ineffective (Too many files read):",
      test_func_file_first_reads, print_func_file_first_reads ],
    [ 1, "/fslayer/pftech/mgr/n_file_seq_fb_",
      "# Sequential feedbacks (Read in EDGE) for file data in EDGE", "",
      -INT, 0, 0 ],
    [ 0, "/fslayer/pftech/mgr/n_file_dup_reads_",     # Group 3
      "# Read received after feedback: File RAH", "", -INT, 0, 0,
      None, None, test_func_never_log ],
    [ 0, "/fslayer/pftech/mgr/n_file_dup_fb_",        # Print Group 3
      "# Feedback received after read: File RAH", "", -INT, 0, [ 10 ],
      None, "Network CORE to EDGE slow (Too many crossovers):",
      test_func_file_crossover, print_func_file_crossover ],
    # Directories
    [ 0, "/fslayer/pftech/mgr/n_dir_reads_",          # Groups 4, 5, 6
      "# Reads for directories not in EDGE", "", -INT, 0, 0,
      None, None, test_func_never_log ],
    [ 0, "/fslayer/pftech/mgr/n_dir_fb_",             # Groups 4, 5, 6
      "# Feedbacks (Read in EDGE) for directories in EDGE", "",
      -INT, 0, 0,
      None, None, test_func_never_log ],
    [ 0, "/fslayer/pftech/mgr/n_dir_non_seq_reads_",  # Groups 4, 5
      "# Non-sequential reads for directories not in EDGE", "", -INT, 0, 0,
      None, None, test_func_never_log ],
    [ 0, "/fslayer/pftech/mgr/n_dir_non_seq_fb_",     # Print Group 4
      "# Non-sequential feedbacks (Read in EDGE) for directories in EDGE", "",
      -INT, 0, [ 10 ],
      None, "Dir prefetch ineffective (Too many non-sequential reads):",
      test_func_dir_non_sequential, print_func_dir_non_sequential ],
    [ 0, "/fslayer/pftech/mgr/n_dir_seq_reads_",      # Print Group 5
      "# Sequential reads for directories not in EDGE", "", -INT, 0, [ 10 ],
      None, "Dir prefetch ineffective (Too many dirs read):",
      test_func_dir_first_reads, print_func_dir_first_reads ],
    [ 1, "/fslayer/pftech/mgr/n_dir_seq_fb_",
      "# Sequential feedbacks (Read in EDGE) for directories in EDGE",
      "", -INT, 0, 0 ],
    [ 0, "/fslayer/pftech/mgr/n_dir_dup_reads_",      # Group 6
      "# Read received after feedback: Dir RAH", "", -INT, 0, 0,
      None, None, test_func_never_log ],
    [ 0, "/fslayer/pftech/mgr/n_dir_dup_fb_",         # Print Group 6
      "# Feedback received after read: Dir RAH", "", -INT, 0, [ 10 ],
      None, "Network CORE to EDGE slow (Too many crossovers):",
      test_func_dir_crossover, print_func_dir_crossover ],
    ];

_all_core_stat_descriptors.extend(stats_fs_descriptors);

(find_descriptor(stats_fs_descriptors,  # For print_func_file_non_sequential
                "/fslayer/pftech/mgr/n_file_non_seq_fb_").
 append(stats_fs_descriptors))

(find_descriptor(stats_fs_descriptors,  # For print_func_dir_non_sequential
                "/fslayer/pftech/mgr/n_dir_non_seq_fb_").
 append(stats_fs_descriptors))

(find_descriptor(stats_fs_descriptors,  # For print_func_file_first_reads
                "/fslayer/pftech/mgr/n_file_seq_reads_").
 append(stats_fs_descriptors))

(find_descriptor(stats_fs_descriptors,  # For print_func_dir_first_reads
                "/fslayer/pftech/mgr/n_dir_seq_reads_").
 append(stats_fs_descriptors))

(find_descriptor(stats_fs_descriptors,  # For print_func_file_crossover
                "/fslayer/pftech/mgr/n_file_dup_fb_").
 append(stats_fs_descriptors))

(find_descriptor(stats_fs_descriptors,  # For print_func_dir_crossover
                "/fslayer/pftech/mgr/n_dir_dup_fb_").
 append(stats_fs_descriptors))
    
#------------------------------------------------------------------------------
# For all file systems if File read ahead (file_rah) is enabled
# Prefix /prefetch/<lun>/diskpart/<partition>
#     or /prefetch/<lun>/diskpart/data/<partition>
# Used in file_system_debug()
stats_file_rah_descriptors = [
    # file_rah - FileRAHStats:TechStats --prefetch/pfstack/tech/pf_tech_mgr.h
    [ 0, -1, "<i>Prefetch technique: File read-ahead statistics</i>" ],
    [ 1, "/fslayer/pftech/file_rah/n_read_notifs_",
      "# Reads from EDGE: Processed: File RAH", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/file_rah/n_fb_notifs_",
      "# Feedbacks (Read in EDGE): Processed: File RAH", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/file_rah/n_backpressure_clear_",
      "# Clear push back-pressure: Processed: File RAH", "", -INT, 0, 0 ],
    # FileRAHStats --prefetch/pfstack/tech/file_rah.cc
    [ 1, "/fslayer/pftech/file_rah/n_bp_clear_bytes_prefetched_",
      "Fetched on back-pressure cleared: File RAH", "bytes",
      -INT, 0, 0 ],                      # Paired with n_backpressure_clear_
    [ 1, "/fslayer/pftech/file_rah/n_bytes_prefetched_", # Group 9
      "Fetched in each push: File RAH", "bytes", -BKT, 0, 0,
      None, None, test_func_never_log ],
    [ 0, "/fslayer/pftech/file_rah/n_bytes_prefetched_bef_bp_", # Group 9
      "Fetched before back-pressure: File RAH", "", -BKT,
      [ None, ( 128 * 1024 ) ], [ None, 5 ],
      "Prehaps network is slow:", "Prehaps network is slow:",
      test_func_file_rah_bytes_prefetched_bef_bp,
      print_func_file_rah_bytes_prefetched_bef_bp ],
    [ 1, "/fslayer/pftech/file_rah/n_new_reads_",
      "# files with file RAH operating", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/file_rah/n_reads_on_pf_range_",
      "# reads on already prefetched range: File RAH", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/file_rah/n_small_file_rah_",
      "# Reads from EDGE of small files: File RAH", "", -INT, 0, 0 ],
    [ 0, "/fslayer/pftech/file_rah/n_rand_read_limit_",
      "# times prefetch disabled (Too many non-sequential reads): File RAH",
      "", -INT, 0, [ 0 ], None, "File prefetch ineffective:" ],
    [ 1, "/fslayer/pftech/file_rah/n_small_fb_no_pf_",
      "# Reads in EDGE too small to trigger prefetch: File RAH", "",
      -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/file_rah/n_whole_file_rahs_",
      "# RAH whole files: File RAH", "", -INT, 0, 0 ],
    ];

_all_core_stat_descriptors.extend(stats_file_rah_descriptors);

# For print_func_file_rah_bytes_prefetched_bef_bp
(find_descriptor(stats_file_rah_descriptors,
                 "/fslayer/pftech/file_rah/n_bytes_prefetched_bef_bp_").
 append(stats_file_rah_descriptors))
    
#------------------------------------------------------------------------------
# For all file systems if Directory Copy (next_file) is enabled
# Prefix /prefetch/<lun>/diskpart/<partition>
#     or /prefetch/<lun>/diskpart/data/<partition>
# Used in file_system_debug()
stats_next_file_descriptors = [
    # next_file - NextFileRAHStats:TechStats --prefetch/pfstack/tech/pf_tech_mgr.h
    [ 0, -1,
      "<i>Prefetch technique: Directory copy (Next file) statistics</i>" ],
    [ 1, "/fslayer/pftech/next_file/n_read_notifs_",
      "# Reads from EDGE: Processed: Next file", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/next_file/n_fb_notifs_",
      "# Feedbacks (Read in EDGE): Processed: Next file", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/next_file/n_backpressure_clear_",
      "# Clear push back-pressure: Processed: Next file", "", -INT, 0, 0 ],
    # NextFileRAHStats --prefetch/pfstack/tech/next_file_rah.cc
    [ 1, "/fslayer/pftech/next_file/n_initiated_rah_bytes_",
      "# bytes of file RAH initiated", "bytes", -INT,
      0, 0 ],
    [ 1, "/fslayer/pftech/next_file/n_file_rah_initiated_",
      "# files on which file rah was initiated", "", -INT,
      0, 0 ],
    [ 1, "/fslayer/pftech/next_file/n_seq_",
      "# sequential accesses to file", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/next_file/n_non_seq_",
      "# non-sequential access to file", "", -INT, 0, 0 ],
    [ 0, "/fslayer/pftech/next_file/n_non_seq_limit_",
      "# times prefetch disabled (Too many non-sequential reads):"
      " Directory copy (Next file)", "", -INT,
      0, [ None, 0 ],
      None, "Directory copy (Next file) prefetch ineffective:" ],
    [ 1, "/fslayer/pftech/next_file/n_pushed_dir_complete_",
      "# times push dir completed, i.e. all files under dir were pushed", "",
      -INT, 0, 0 ],
    ];

_all_core_stat_descriptors.extend(stats_next_file_descriptors);

#------------------------------------------------------------------------------
# For NTFS file systems if Directory read ahead (dir_rah) is enabled
# Prefix /prefetch/<lun>/diskpart/<partition>
#     or /prefetch/<lun>/diskpart/data/<partition>
# Used in file_system_debug()
stats_ntfs_dir_rah_descriptors = [
    #/prefetch/<lun>/diskpart/<partition>/fslayer/pftech/dir_rah/n_read_notifs_
    # dir_rah - DirectoryRAHStats:TechStats --prefetch/pfstack/tech/pf_tech_mgr.h
    [ 0, -1,
      "<i>Prefetch technique: Directory list (Dir read-ahead) statistics</i>"
      ],
    [ 1, "/fslayer/pftech/dir_rah/n_read_notifs_",
      "# Reads from EDGE: Processed: Dir RAH", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/dir_rah/n_fb_notifs_",
      "# Feedbacks (Read in EDGE): Processed: Dir RAH", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/dir_rah/n_backpressure_clear_",
      "# Clear push back-pressure: Processed: Dir RAH", "", -INT, 0, 0 ],
    # DirectoryRAHStats --prefetch/pfstack/tech/dir_rah.cc
    [ 0, "/fslayer/pftech/dir_rah/n_bp_clear_bytes_prefetched_",
      "Fetched on back-pressure cleared: Dir RAH", "bytes",
       -INT, 0, 0 ],                     # Paired with n_backpressure_clear_
    [ 1, "/fslayer/pftech/dir_rah/n_bytes_prefetched_", # Group 10
      "Fetched in each push: Dir RAH", "bytes", -BKT, 0, 0,
      None, None, test_func_never_log ],
    [ 0, "/fslayer/pftech/dir_rah/n_bytes_prefetched_bef_bp_", # Group 10
      "Fetched before back-pressure: Directory list (Dir RAH)", "", -BKT,
      [ None, ( 128 * 1024 ) ], [ None, 5 ],
      "Prehaps network is slow:", "Prehaps network is slow:",
      test_func_dir_rah_bytes_prefetched_bef_bp,
      print_func_dir_rah_bytes_prefetched_bef_bp ],
    [ 1, "/fslayer/pftech/dir_rah/n_new_reads_",
      "# dirs with dir RAH operating", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/dir_rah/n_reads_on_pf_range_",
      "# reads on already prefetched range: Dir RAH", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/dir_rah/n_dir_subnodes_pushed_",
      "# Directory records pushed: Dir RAH", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/dir_rah/n_inode_records_pushed_",
      "# inode records pushed: Dir RAH", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/dir_rah/n_rand_read_limit_",
      "# times prefetch disabled (Too many non-sequential reads): Dir RAH",
      "", -INT, 0, [ 0 ], None, "Dir list (Dir RAH) prefetch ineffective:" ],
    [ 1, "/fslayer/pftech/dir_rah/n_whole_dir_rah_",
      "# RAH whole directories: Dir RAH", "", -INT, 0, 0 ],
    ];

_all_core_stat_descriptors.extend(stats_ntfs_dir_rah_descriptors);

# For print_func_dir_rah_bytes_prefetched_bef_bp
(find_descriptor(stats_ntfs_dir_rah_descriptors,
                 "/fslayer/pftech/dir_rah/n_bytes_prefetched_bef_bp_").
 append(stats_ntfs_dir_rah_descriptors))

#------------------------------------------------------------------------------
# For NTFS file systems if Windows prefetch (win_pf) is enabled
# Prefix /prefetch/<lun>/diskpart/<partition>
#     or /prefetch/<lun>/diskpart/data/<partition>
# Used in file_system_debug()
stats_ntfs_win_pf_descriptors = [
    # win_pf - WinPrefStats:TechStats --prefetch/pfstack/tech/pf_tech_mgr.h
    [ 0, -1, "<i>Prefetch technique: Windows .pf files statistics</i>" ],
    [ 1, "/fslayer/pftech/win_pf/n_read_notifs_",
      "# Reads from EDGE: Processed: Win pf", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/win_pf/n_fb_notifs_",
      "# Feedbacks (Read in EDGE): Processed: Win pf", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/win_pf/n_backpressure_clear_",
      "# Clear push back-pressure: Processed: Win pf", "", -INT, 0, 0 ],
    # WinPrefStats --prefetch/pfstack/tech/win_pref.cc
    [ 1, "/fslayer/pftech/win_pf/n_bp_clear_bytes_prefetched_",
      "Fetched on back-pressure cleared: Win pf", "bytes",
      -INT, 0, 0 ],              # Paired with n_backpressure_clear_
    [ 1, "/fslayer/pftech/win_pf/n_bytes_prefetched_", # Group 11
      "Fetched in each push: Win pf", "", -BKT, 0, 0,
      None, None, test_func_never_log ],
    [ 0, "/fslayer/pftech/win_pf/n_bytes_prefetched_bef_bp_", # Group 11
      "Fetched before back-pressure: .pf", "", -BKT,
      [ None, ( 128 * 1024 ) ], [ None, 5 ],
      "Prehaps network is slow:", "Prehaps network is slow:",
      test_func_win_pf_bytes_prefetched_bef_bp,
      print_func_win_pf_bytes_prefetched_bef_bp ],
    [ 1, "/fslayer/pftech/win_pf/n_files_pushed_",
      "# files in .pf file that were pushed: Win pf", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/win_pf/n_whole_range_push_",
      "# whole files pushed: Win pr", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/win_pf/n_ref_state_created_bef_push_",
      "# files which had lost the ref state", "", -INT, 0, 0 ],
    ];

_all_core_stat_descriptors.extend(stats_ntfs_win_pf_descriptors);

# For print_func_win_pf_bytes_prefetched_bef_bp
(find_descriptor(stats_ntfs_win_pf_descriptors,
                 "/fslayer/pftech/win_pf/n_bytes_prefetched_bef_bp_").
 append(stats_ntfs_win_pf_descriptors))

#------------------------------------------------------------------------------
# For NTFS file systems if Exe/dll (exe_dll) is enabled
# Prefix /prefetch/<lun>/diskpart/<partition>
#     or /prefetch/<lun>/diskpart/data/<partition>
# Used in file_system_debug()
stats_ntfs_exe_dll_descriptors = [
    # exe_dll - WinExeStats:TechStats --prefetch/pfstack/tech/pf_tech_mgr.h
    [ 0, -1, "<i>Prefetch technique: Windows .exe/.dll files statistics</i>" ],
    [ 1, "/fslayer/pftech/exe_dll/n_read_notifs_",
      "# Reads from EDGE: Processed: Exe/Dll", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/exe_dll/n_fb_notifs_",
      "# Feedbacks (Read in EDGE): Processed: Exe/Dll", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/exe_dll/n_backpressure_clear_",
      "# Clear push back-pressure: Processed: Exe/Dll", "", -INT, 0, 0 ],
    # WinExeStats --prefetch/pfstack/tech/win_exe.cc
    [ 1, "/fslayer/pftech/exe_dll/n_bp_clear_bytes_prefetched_",
      "Fetched on back-pressure cleared: Exe/Dll", "bytes",
      -INT, 0, 0 ],              # Paired with n_backpressure_clear_
    [ 1, "/fslayer/pftech/exe_dll/n_bytes_prefetched_", # Group 12
      "Fetched in each push: Exe/Dll", "", -BKT, 0, 0,
      None, None, test_func_never_log ],
    [ 0, "/fslayer/pftech/exe_dll/n_bytes_prefetched_bef_bp_", # Group 12
      "Fetched before back-pressure: Exe/Dll", "", -BKT,
      [ None, ( 128 * 1024 ) ], [ None, 5 ],
      "Prehaps network is slow:", "Prehaps network is slow:",
      test_func_exe_dll_bytes_prefetched_bef_bp,
      print_func_exe_dll_bytes_prefetched_bef_bp ],
    [ 1, "/fslayer/pftech/exe_dll/n_exe_files_optimized_",
      "# .exe files optimized: Exe/Dll", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/exe_dll/n_dlls_pushed_",
      "# .dll files pushed: Exe/Dll", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/exe_dll/n_linked_lib_bytes_prefetched_",
      "# bytes pushed for linked files: Exe/Dll", "bytes", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/exe_dll/n_dlls_w_state_",
      "# .dll files already pushed", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/exe_dll/n_exe_load_errors_",
      "# .exe files with parse errors", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/exe_dll/n_no_regions_",
      "# .exe files without any regions", "", -INT, 0, 0 ],
    ];

_all_core_stat_descriptors.extend(stats_ntfs_exe_dll_descriptors);

# For print_func_exe_dll_bytes_prefetched_bef_bp
(find_descriptor(stats_ntfs_exe_dll_descriptors,
                 "/fslayer/pftech/exe_dll/n_bytes_prefetched_bef_bp_").
 append(stats_ntfs_exe_dll_descriptors))

#------------------------------------------------------------------------------
# For NTFS file systems if Recursive Dir read ahead (next_dir) is enabled
# Prefix /prefetch/<lun>/diskpart/<partition>
#     or /prefetch/<lun>/diskpart/data/<partition>
# Used in file_system_debug()
stats_ntfs_next_dir_descriptors = [
    # next_dir - NextDirRAHStats:TechStats --prefetch/pfstack/tech/pf_tech_mgr.h
    [ 1, -1, "<i>Prefetch technique" \
      ": Recursive directory list (Next dir) statistics</i>"
      ],
    [ 1, "/fslayer/pftech/next_dir/n_read_notifs_",
      "# Reads from EDGE: Processed: Next dir", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/next_dir/n_fb_notifs_",
      "# Feedbacks (Read in EDGE): Processed: Next dir", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/next_dir/n_backpressure_clear_",
      "# Clear push back-pressure: Processed: Next dir", "", -INT, 0, 0 ],
    # NextDirRAHStats --prefetch/pfstack/tech/next_dir_rah.cc
    [ 1, "/fslayer/pftech/next_dir/n_initiated_rah_bytes_",
      "# bytes prefetch initiated: Next dir", "bytes", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/next_dir/n_dir_rah_initiated_",
      "# directories prefetch initiated: Next dir", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/next_dir/n_empty_dirs_",
      "# empty directories: Next dir", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/next_dir/n_bytes_siblings_",
      "# bytes of sibling prefetch: next dir", "bytes", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/next_dir/n_bytes_children_",
      "# bytes of child prefetch: Next dir", "bytes", -INT, 0, 0 ],
    ];

_all_core_stat_descriptors.extend(stats_ntfs_next_dir_descriptors);

#------------------------------------------------------------------------------
# For NTFS file systems if Windows boot (win_boot) is enabled
# Prefix /prefetch/<lun>/diskpart/<partition>
#     or /prefetch/<lun>/diskpart/data/<partition>
# Used in file_system_debug()
stats_ntfs_win_boot_descriptors = [
    # win_boot - WinBootStats:TechStats --prefetch/pfstack/tech/pf_tech_mgr.h
    [ 1, -1, "<i>Prefetch technique: Windows boot statistics</i>" ],
    [ 1, "/fslayer/pftech/win_boot/n_read_notifs_",
      "# Reads from EDGE: Processed: Win boot", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/win_boot/n_fb_notifs_",
      "# Feedbacks (Read in EDGE): Processed: Win boot", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/win_boot/n_backpressure_clear_",
      "# Clear push back-pressure: Processed: Win boot", "", -INT, 0, 0 ],
    # WinBootStats --prefetch/pfstack/tech/win_boot.cc
    [ 1, "/fslayer/pftech/win_boot/n_known_files_pushed_",
      "# files initated push from known file list", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/win_boot/n_known_dirs_pushed_",
      "# directories initiated push from known file list", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/win_boot/n_known_initiated_push_bytes_",
      "# bytes initiated push from known file list", "bytes", #
      -INT, 0, 0 ],  # Paired with n_known_dirs_pushed_ + n_known_files_pushed_
    [ 1, "/fslayer/pftech/win_boot/n_winreg_files_pushed_",
      "# files initiated push from services/drivers in registry", "",
      -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/win_boot/n_winreg_initiated_push_bytes_",
      "# bytes initiated push from services/drivers in registry",
      "bytes", -INT, 0, 0 ],             # Paired with n_winreg_files_pushed_
    [ 1, "/fslayer/pftech/win_boot/n_winreg_key_files_pushed_",
      "# files initiated push from known registry key/value list", "",
      -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/win_boot/n_winreg_key_initiated_push_bytes_",
      "# bytes initiated push from known registry key/value list",
      "bytes", -INT, 0, 0 ],           # Paired with n_winreg_key_files_pushed_
    [ 1, "/fslayer/pftech/win_boot/n_triggered_",
      "# times win_boot prefetch started", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/win_boot/registry/all_hives_file_size_",
      "Total size of all registry hive files open", "bytes", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/win_boot/registry/max_all_hives_file_size_",
      "Maximum of total size of all registry hive files open", "bytes",
      -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/win_boot/registry/hive_file_size_",
      "File size of each registry hive file open", "", -BKT, 0, 0 ],
    [ 1, "/fslayer/pftech/win_boot/registry/hive_read_time_",
      "Time to read each registry hive file", "", -BKT, 0, 0 ],
    [ 1, "/fslayer/pftech/win_boot/registry/hive_parse_time_",
      "Time to parse each registry hive file", "", -BKT, 0, 0 ],
    [ 1, "/fslayer/pftech/win_boot/registry/hive_life_time_",
      "Open time of each registry hive not including read_time", "",
      -BKT, 0, 0 ],
    # Turbo boot
    [ 1, "/fslayer/pftech/win_boot/n_turbo_boot_initiated_",
            "# times turbo boot prefetch started", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/win_boot/n_turbo_bytes_pushed_",
      "# bytes pushed by turbo boot technique",
      "bytes", -INT, 0, 0 ],
    ];

_all_core_stat_descriptors.extend(stats_ntfs_win_boot_descriptors);

#------------------------------------------------------------------------------
# Demonstrate the second method for printing a group of statistics.
# test_func testing % clusters in primary cgmap
# Group 7
succ_pri_cgmap_lookups_min = [ 80, 90 ]
succ_pri_cgmap_lookups_printed = None
def test_func_succ_pri_cgmap_lookups(path_prefix, descriptor,
                                     stat_description, stat_value, align,
                                     first_set, last_set):
    global _debug                       # In
    global succ_pri_cgmap_lookups_min   # In
    global succ_pri_cgmap_lookups_printed # In
    global fs_stats                     # In
    if (_debug & 4096) != 0:
        print ">>> test_func_succ_pri_cgmap_lookups:", \
              "first_set", first_set, "last_set", last_set, \
              "path_prefix", path_prefix, "stat_path", descriptor[1], \
              "stat_value", stat_value, "align", align
    lcn_lookups = get_core_stat_or_diff(
        path_prefix + "/fslayer/ntfscrawl/iss/n_lcn_lookups_",
        INT, first_set, last_set)
    if lcn_lookups != 0:
        succ_pri_cgmap_lookups = get_core_stat_or_diff(
            path_prefix +
            "/fslayer/ntfscrawl/iss/n_succ_pri_cgmap_lookups_",
            INT, first_set, last_set)
        percent = (100 * succ_pri_cgmap_lookups) / lcn_lookups
        min_message = "Too few cluster accesses in the active set:"
        if ((succ_pri_cgmap_lookups_printed == None) or
            (succ_pri_cgmap_lookups_printed[0] != first_set) or
            (succ_pri_cgmap_lookups_printed[1] != last_set)):
            result = test_value_vs_minimums(path_prefix, descriptor,
                                            "% clusters in primary cgmap",
                                            percent, align,
                                            succ_pri_cgmap_lookups_min,
                                            min_message)
            if result:
                succ_pri_cgmap_lookups_printed = ( first_set, last_set )
        else:
            result = test_value_vs_limits(percent, succ_pri_cgmap_lookups_min,
                                          test_minimum)
            if result:
                result = result[0]
    else:
        result = False

    if (_debug & 4096) != 0:
        print ">>> test_func_succ_pri_cgmap_lookups: returns", result
    return result

#------------------------------------------------------------------------------
# Demonstrate the second method for printing a group of statistics.
# test_func testing % lookups in primary cgmap
# Group 8
mft_lookups_min = [ 80, 90 ]
mft_lookups_printed = None
def test_func_mft_lookups(path_prefix, descriptor,
                          stat_description, stat_value, align,
                          first_set, last_set):
    global _debug                       # In
    global mft_lookups_min              # In
    global mft_lookups_printed          # In
    if (_debug & 4096) != 0:
        print ">>> test_func_mft_lookups:", \
              "first_set", first_set, "last_set", last_set, \
              "path_prefix", path_prefix, "stat_path", descriptor[1], \
              "stat_value", stat_value, "align", align
    lookups = get_core_stat_or_diff(path_prefix +
                                "/fslayer/ntfscrawl/iss/n_lookups_",
                                INT, first_set, last_set)
    if lookups != 0:
        pri_lookups = get_core_stat_or_diff(
            path_prefix + "/fslayer/ntfscrawl/iss/n_pri_lookups_",
            INT, first_set, last_set)
        mft_lookups = get_core_stat_or_diff(
            path_prefix + "/fslayer/ntfscrawl/iss/n_mft_lookups_",
            INT, first_set, last_set)
        percent = (100 * (pri_lookups + mft_lookups)) / lookups
        min_message = "Too few accesses in the active set:"
        if ((mft_lookups_printed == None) or
            (mft_lookups_printed[0] != first_set) or
            (mft_lookups_printed[1] != last_set)):
            result = test_value_vs_minimums(path_prefix, descriptor,
                                            "% lookups in primary cgmap",
                                            percent, align,
                                            mft_lookups_min, min_message)
            if result:
                mft_lookups_printed = ( first_set, last_set )
        else:
            result = test_value_vs_limits(percent, mft_lookups_min,
                                          test_minimum)
            if result:
                result = result[0]
    else:
        result = False

    if (_debug & 4096) != 0:
        print ">>> test_func_mft_lookups: returns", result
    return result

#------------------------------------------------------------------------------
# For NTFS file systems
# Prefix /prefetch/<lun>/diskpart/<partition>
#     or /prefetch/<lun>/diskpart/data/<partition>
# Used in file_system_debug()
stats_ntfs_descriptors = [
    #/prefetch/<lun>/diskpart/<partition>/fslayer/ntfscrawl/crawl_state_
    # NtfsCrawlStats:FsCrawlStats --prefetch/fslibs/fs_crawl.h
    [ 0, -1, "<i>NTFS file system statistics</i>" ],
    [ 1, "/fslayer/ntfscrawl/crawl_state_", "", "", STR ], # In NTFS title
    # NtfsCrawlStats --prefetch/fslibs/ntfs/ntfs_crawl.h
    [ 1, "/fslayer/ntfscrawl/n_inodes_crawled_", "# inodes crawled", "",
      -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/n_files_",
      "# files crawled/updated", "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/n_dirs_",
      "# directories crawled/updated", "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/n_files_res_data_",
      "# files with resident data crawled/updated", "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/n_files_nonres_data_",
      "# files with non-resident data crawled/updated", "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/n_dirs_index_root_",
      "# directories with $INDEX_ROOT crawled/updated", "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/n_dirs_indx_alloc_",
      "# directories with $INDEX_ALLOC crawled/updated", "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/n_files_alt_streams_",
      "# files with alternate streams crawled/updated", "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/n_dirs_alt_streams_",
      "# directories with alternate streams crawled/updated", "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/file_sizes_", "File sizes: File system level", "",
      -BKT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/n_boot_sector_writes_",
      "# writes to boot sector", "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/n_mft_inode_updates_",
      "# writes to $MFT inode record", "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/n_inode_updates_",
      "# writes to inode records other than $MFT other than delete or create",
      "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/n_deletes_",
      "# inodes deleted", "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/n_attr_list_",
      "# files/directories with $ATTRIBUTE_LISTS crawled/updated", "",
      -INT, 0, 0 ],
    [ 1, "/fslayer/ntfscrawl/crawl_time_ms_",
      "Total crawl time of latest crawl", "ms", -INT, 0, 0 ],
    [ 1, "/fslayer/ntfscrawl/crawl_io_time_ms_",
      "Crawl I/O time of latest crawl", "ms", -INT, 0, 0],
    [ 1, "/fslayer/ntfscrawl/crawl_sched_time_ms_",
      "Crawl queuing time between stages of latest crawl", "ms", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/n_invalid_inode_records_",
      "# invalid inode records parsed", "", -INT, 0, 0 ],
    [ 1, "/fslayer/ntfscrawl/n_child_records_pushed_",
      "# child inode records pushed", "", -INT, 0, 0 ],
    [ 1, "/fslayer/ntfscrawl/n_attrlist_blks_pushed_",
      "# $ATTRIBUTE_LIST blocks pushed", "blocks", -INT, 0, 0 ],
    [ 1, "/fslayer/ntfscrawl/n_bitmap_blks_pushed_",
      "# $bitmap blocks pushed", "blocks", -INT, 0, 0 ],
    [ 1, "/fslayer/ntfscrawl/populate_mft_time_",
      "Parse $MFT inode record(s) time", "", -BKT, 0, 0 ],
    [ 1, "/fslayer/ntfscrawl/scan_inode_group_time_",
      "Inode group scan time", "", -BKT, 0, 0 ],
    [ 1, "/fslayer/ntfscrawl/scan_inode_group_io_time_",
      "Inode group I/O time", "", -BKT, 0, 0 ],
    [ 1, "/fslayer/ntfscrawl/inode_lookup_time_", "inode_lookup time", "",
      -BKT, 0, 0 ],
    [ 1, "/fslayer/ntfscrawl/pending_inodes_crawled_", "pending_inodes_crawled", "",
      -BKT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/n_parse_errors_",
      "# inode record parse errors", "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/n_mst_fix_errors_",
      "# mst fix errors", "", -INT, 0, 0 ],
    [ 1, "/fslayer/ntfscrawl/n_resolve_failed_",
      "# times failed to resolve lcn range after inode groups scanned", "",
      -INT, 0, 0 ],
    [ 1, "/fslayer/ntfscrawl/n_resolve_partial_",
      "# times failed to resolve part of lcn range after inode groups scanned",
      "", -INT, 0, 0 ],
    [ 1, "/fslayer/ntfscrawl/n_updates_on_active_ino_",
      "# data updates on active inodes", "", -INT, 0, 0 ],
    [ 1, "/fslayer/ntfscrawl/n_meta_updates_on_active_ino_",
      "# inode record updates of active inodes", "", -INT, 0, 0 ],
    [ 1, "/fslayer/ntfscrawl/n_nr_attr_not_tracked_",
      "# attributes that are not tracked", "", -INT, 0, 0 ],
    [ 1, "/fslayer/ntfscrawl/n_clusters_not_tracked_",
      "# clusters in attributes that are not tracked", "clusters",
      -INT, 0, 0 ],                      # Paired with n_nr_attr_not_tracked_
    [ 2, "/fslayer/ntfscrawl/n_reuse_seq_num_unchanged_",
      "# times inode base re-used as child with the same seq num", "",
      -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/num_total_sectors_",
      "# sectors: File system level", "sectors", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/num_used_sectors_",
      "# sectors in-use: File-system level", "", -INT, 0, 0 ],
    [ 1, "/fslayer/ntfscrawl/n_collapsed_lookups_",
      "# successful lookups in collapsed cgmap", "", -INT, 0, 0 ],
    [ 1, "/fslayer/ntfscrawl/n_compressed_file_reads_",
      "# reads by prefetch to compressed files", "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/n_predicted_inode_in_primary_",
      "# inodes not inserted into the inode cache" \
      " since found in the primary cgmap",
      "", -INT, 0, 0 ],
    # ClusterMapStats --prefetch/common/cluster_group_map.h
    [ 1, "/fslayer/ntfscrawl/primary/cg_map/insert_time_",
      "Primary cgmap insert time", "", -BKT,
      0, [ 4, 2 ], None, "Data structure slow:" ],
    [ 1, "/fslayer/ntfscrawl/primary/cg_map/lookup_time_",
      "Primary cgmap lookup time", "", -BKT,
      0, [ 4, 2 ], None, "Data structure slow:" ],
    [ 1, "/fslayer/ntfscrawl/primary/cg_map/remove_time_",
      "Primary cgmap remove time", "", -BKT,
      0, [ 4, 2 ], None, "Data structure slow:" ],
    #
    [ 1, "/fslayer/ntfscrawl/collapsed/cg_map/insert_time_",
      "Collapsed cgmap insert time", "", -BKT,
      0, [ 4, 2 ], None, "Data structure slow:" ],
    [ 1, "/fslayer/ntfscrawl/collapsed/cg_map/lookup_time_",
      "Collapsed cgmap lookup time", "", -BKT,
      0, [ 4, 2 ], None, "Data structure slow:" ],
    [ 1, "/fslayer/ntfscrawl/collapsed/cg_map/remove_time_",
      "Collapsed cgmap remove time", "", -BKT,
      0, [ 4, 2 ], None, "Data structure slow:" ],
    #
    [ 1, "/fslayer/ntfscrawl/lcn_cache/cg_map/insert_time_",
      "Cache cgmap insert time", "", -BKT,
      0, [ 4, 2 ], None, "Data structure slow:" ],
    [ 1, "/fslayer/ntfscrawl/lcn_cache/cg_map/lookup_time_",
      "Cache cgmap lookup time", "", -BKT,
      0, [ 4, 2 ], None, "Data structure slow:" ],
    [ 1, "/fslayer/ntfscrawl/lcn_cache/cg_map/remove_time_",
      "Cache cgmap remove time", "", -BKT,
      0, [ 4, 2 ], None, "Data structure slow:" ],
    #
    # InodeMapStats --prefetch/fslibs/fs_inode_map.h
    [ 1, "/fslayer/ntfscrawl/inode_map/insert_time_",
      "Inode map insert time", "", -BKT,
      0, [ 4, 2 ], None, "Data structure slow:" ],
    [ 1, "/fslayer/ntfscrawl/inode_map/lookup_time_",
      "Inode map lookup time", "", -BKT,
      0, [ 4, 2 ], None, "Data structure slow:" ],
    [ 1, "/fslayer/ntfscrawl/inode_map/remove_time_",
      "Inode map remove time", "", -BKT,
      0, [ 4, 2 ], None, "Data structure slow:" ],
    # InodeLruList --prefetch/fslibs/fs_inode_map.h
    [ 1, "/fslayer/ntfscrawl/inode_lru/num_active_inodes_", "# active inodes",
      "", -INT, 0, 0 ],
    [ 1, "/fslayer/ntfscrawl/inode_lru/active_list_remove_time_",
      "Inode active list remove time", "", -BKT,
      0, [ 4, 2 ], None, "Data structure slow:" ],
    # NtfsIssStats --prefetch/fslibs/ntfs/ntfs_iss.h
    [ 1, "/fslayer/ntfscrawl/iss/n_ccg_unaccounted_",
      "# times lcn not in the collapsed cgmap", "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/iss/n_conflicts_pri_cgmap_",
      "# primary cgmap entries for wrong file, probably updates out of order",
      "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/iss/n_pri_invalid_conflicts_",
      "# duplicate primary cgmap entries, probably same attribute twice",
      "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/iss/n_inodes_downgraded_",
      "# Sucessful inode down grades", "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/iss/n_inodes_downgrade_failed_",
      "# Failed inode down grades", "", -INT, 0, 0 ],
    [ 0, "/fslayer/ntfscrawl/iss/n_pri_lookups_",     # Group 8
      "# successful lookups in primary cgmap", "", -INT, 0, 0,
      None, None, test_func_mft_lookups ],
    [ 0, "/fslayer/ntfscrawl/iss/n_mft_lookups_",     # Group 8
      "# successful lookups in MFT", "", -INT, 0, 0,
      None, None, test_func_mft_lookups ],
    [ 0, "/fslayer/ntfscrawl/iss/n_lookups_",         # Group 8
      "# lookups (Successful or unsuccessful)", "", -INT, 0, 0,
      None, None, test_func_mft_lookups ],
    [ 2, "/fslayer/ntfscrawl/iss/n_succ_mft_lookups_",
      # Paired with n_mft_lookups_
      "# clusters successfully looked up in MFT", "clusters", -INT, 0, 0 ],
    [ 0, "/fslayer/ntfscrawl/iss/n_succ_pri_cgmap_lookups_", # Group 7
      # Paired with n_pri_lookups_
      "# clusters successfully looked up in primary cgmap", "clusters",
      -INT, 0, 0, None, None, test_func_succ_pri_cgmap_lookups ],
    [ 0, "/fslayer/ntfscrawl/iss/n_lcn_lookups_", # Paired with n_lookups_
      # Group 7
      "# clusters looked up (Successful or unsuccessful)", "clusters",
      -INT, 0, 0, None, None, test_func_succ_pri_cgmap_lookups ],
    [ 2, "/fslayer/ntfscrawl/iss/n_cache_lookups_",
      "# successful lookups in lcn cach", "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/iss/n_succ_cache_lookups_",
      # Paired with n_cache_lookups
      "# clusters successfully looked up in lcn cache", "clusters",
      -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/iss/n_cache_evicted_",
      "total # inode records evicted from the inode cache", "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/iss/n_cache_updates_",
      "total # inode records updated in the inode cache", "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/iss/n_cache_updates_active_in_pri_",
      "# inode records updated in the inode cache"
      " that are active in the primary cgmap",
      "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/iss/n_cache_conflicts_",
      "# inode cache entries for wrong file", "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/iss/n_cache_conflicts_self_",
      "# duplicate inode cache entries", "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/iss/n_cache_evicted_lru_",
      "# inode records evicted from lcn cache to make space", "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/iss/n_cache_inserted_",
      "# inode records inserted into the inode cache", "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/iss/n_cache_insert_failures_",
      "# lcn insert failures in lcn cache", "", -INT, 0, 0 ],
    [ 2, "/fslayer/ntfscrawl/iss/n_cache_insert_conflicts_",
      "# lcn insert failures into lcn cache due to inode conflict", "", -INT,
      0, 0 ],
    [ 2, "/fslayer/ntfscrawl/iss/n_predicted_inode_in_cache_",
      "# inodes not inserted into the inode cache" \
      " since already in the inode cache",
      "", -INT, 0, 0 ],
    [ 1, "/fslayer/ntfscrawl/iss/n_unaligned_lookups_",
      "# unaligned lookups vcn to inum", "", -INT, 0, 0 ],
    [ 1, "/fslayer/ntfscrawl/iss/n_unaligned_updates_",
      "# unaligned updates vcn to inum", "", -INT, 0, 0 ],
    [ 1, "/fslayer/ntfscrawl/iss/n_pending_unaligned_inums_",
      "# inums to crawl again due to unaligned updates", "", -INT, 0, 0 ],
    [ 1, "/fslayer/ntfscrawl/iss/n_used_sectors_tracked_",
      "# used sectors tracked", "", -INT, 0, 0 ],
   ];

_all_core_stat_descriptors.extend(stats_ntfs_descriptors);

#------------------------------------------------------------------------------
# For VMFS file systems if vmdk_notifier is enabled
# Prefix /prefetch/<lun>/diskpart/<partition>
#     or /prefetch/<lun>/diskpart/data/<partition>
# Used in file_system_debug()
stats_vmfs_vmdk_notifier_descriptors = [
    #/prefetch/<lun>/diskpart/<partition>/fslayer/...
    # vmdk_notifier - VmdkNotifierStats:TechStats --prefetch/pfstack/tech/pf_tech_mgr.h
    [ 1, -1, "<i>Prefetch technique: VMDK notifier statistics</i>" ],
    [ 1, "/fslayer/pftech/vmdk_notifier/n_read_notifs_",
      "# Reads from EDGE: Processed: VMDK", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/vmdk_notifier/n_fb_notifs_",
      "# Feedbacks (Read in EDGE): Processed: VMDK", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/vmdk_notifier/n_backpressure_clear_",
      "# Clear push back-pressure: Processed: VMDK", "", -INT,
      0, 0 ],
    # VmdkNotifierStats --prefetch/pfstack/tech/vmdk_notifier.cc
    [ 1, "/fslayer/pftech/vmdk_notifier/n_meta_reads_",
      "# FILE_META_READs", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/vmdk_notifier/n_file_reads_",
      "# FILE_READs", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/vmdk_notifier/file_read_bytes_",
      # Paired with n_file_reads_
      "# bytes in FILE_READs", "bytes", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/vmdk_notifier/n_desc_file_meta_reads_",
      "# Descriptor file FILE_META_READs", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/vmdk_notifier/n_desc_file_reads_",
      "# Descriptor file FILE_READs", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/vmdk_notifier/desc_file_read_bytes_",
      # Paired with n_desc_file_reads_
      "", "bytes", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/vmdk_notifier/n_processed_by_fslayer_",
      "# notifications processed by the fslayer", "", -INT, 0, 0 ],
    [ 1, "/fslayer/pftech/vmdk_notifier/n_processed_by_childlayer_",
      "# notifications passed to the child layer", "", -INT, 0, 0 ],
    ];

_all_core_stat_descriptors.extend(stats_vmfs_vmdk_notifier_descriptors);

#------------------------------------------------------------------------------
# For VMFS file systems
# Prefix /prefetch/<lun>/diskpart/<partition>
#     or /prefetch/<lun>/diskpart/data/<partition>
# Used in file_system_debug()
stats_vmfs_descriptors = [
    #/prefetch/<lun>/diskpart/<partition>/fslayer/vmfscrawl/crawl_state_
    # FsCrawlStats --prefetch/fslibs/fs_crawl.h
    [ 1, -1, "<i>VMFS file system statistics</i>" ],
    [ 1, "/fslayer/vmfscrawl/crawl_state_", "", "", STR ], # In VMFS title
    ];

_all_core_stat_descriptors.extend(stats_vmfs_descriptors);

#------------------------------------------------------------------------------
# Demonstrate the first method for printing a group of statistics.
# print_func printing all releveant stats for read_times
# They were not printed earlier since the test_func had to run first.
# Group 9
def print_func_read_times(path_prefix, descriptor, stat_path,
                          qstat_description, level, align, stat, lvl):
    global _debug                       # In
    if (_debug & 4096) != 0:
        print ">>> print_func_read_times:", "path_prefix", path_prefix, \
              "stat_path", descriptor[1], "stat_value", stat
    descriptors = descriptor[11]
    for stat_path in [ "/read_times", "/read_sizes" ]:
        print_func_normal(path_prefix,
                          find_descriptor(descriptors, stat_path),
                          stat_path, None, level, align, fs_stats[stat_path],
                          lvl)

#------------------------------------------------------------------------------
vmfs_status_regexp = re.compile("OK$") # For /status

#------------------------------------------------------------------------------
# For VMFS stores
# Prefix /prefetch/<lun>/diskpart/<partition>/vmfscrawl/<vm>
#     or /prefetch/<lun>/diskpart/data/<partition>/vmfscrawl/<vm>
# Used in vmfs_store_descriptors()
stats_vmfs_store_descriptors = [
    #/prefetch/<lun>/diskpart/<partition>/fslayer/vmfscrawl/<vm>/status
    # VmfsStats --prefetch/fslibs/vmfs/vmfs_crawler.h
    # Added by VmfsCrawler::init_stats().
    [ 0, -1, "<i>VMFS store statistics</i>" ],
    [ 0, "/status", "VMFS status", "", STR,
      vmfs_status_regexp, 'err', None, "Not OK:", test_func_not_search_regexp],
    [ 1, "/label", "label", "", STR ],       # In VMFS title
    [ 0, "/uuid", "uuid", "", STR ],
    [ 0, "/mtime", "", "", STR ],
    [ 0, "/ctime", "", "", STR ],
    [ 0, "/capacity", "VMFS capacity", "bytes", -INT, 0, 0 ],
    [ 1, "/crawl_time", "", "ms", -INT, 0, 0 ],
    [ 1, "/ctx", "ctx", "", STR ],
    [ 0, "/read_sizes", "# blocks per read: File system level", # Group 9
      "", -BKT, 0, 0,
      None, "Storage back end slow:", test_func_never_log ],
    [ 0, "/read_times", "Time to read blocks: File system level", # Group 9
      "", -BKT, [ 10, 8 ], [ 20, 8 ],
      None, "Storage back end slow:",
      test_func_bkt_avg_and_max, print_func_read_times ],
    #/prefetch/<lun>/diskpart/<partition>/fslayer/vmfscrawl/<vm>/fr_get_runlist
    # FileRecordStats --prefetch/fslibs/vmfs/file_record.h
    # Added by VmfsCrawler::init_stats().
    [ 1, "/fr_get_runlist", "Time to get run list", "", -BKT, 0, 0 ],
    [ 1, "/fr_get_sub_runlist", "Time to get sub run list", "", -BKT, 0, 0 ],
    [ 1, "/fr_get_pbc_runlist", "Time to get pbc run list", "", -BKT, 0, 0 ],
    [ 1, "/fr_update", "Time to update meta data", "", -BKT, 0, 0 ],
    [ 1, "/fr_update_blocks", "Time to update file blocks", "", -BKT, 0, 0 ],
    [ 1, "/fr_meta_read", "Time to get meta data", "", -BKT, 0, 0 ],
    #/prefetch/<lun>/diskpart/<partition>/fslayer/vmfscrawl/<vm>/bl_add
    # BlockLayoutStats --prefetch/fslibs/vmfs/block_layout.h
    # Added by VmfsCrawler::init_stats().
    [ 1, "/bl_add", "Time to add file record to layout", "", -BKT, 0, 0 ],
    [ 1, "/bl_lookup", "Time to lookup block(s)", "", -BKT, 0, 0 ],
    [ 1, "/bl_update", "Time to update layout", "", -BKT, 0, 0 ],
    [ 1, "/bl_remove", "Time to remove file record from layout", "",
      -BKT, 0, 0 ],
    [ 1, "/bl_intersect", "Time to intersect two run lists", "", -BKT, 0, 0 ],
    [ 1, "/bl_remove_run", "Time to remove runs", "", -BKT, 0, 0 ],
    [ 1, "/bl_add_run", "", "Time to add runs", -BKT, 0, 0 ],
    [ 1, "/files", "# files", "", -INT, 0, 0 ],
    [ 1, "/dirs", "# directories", "", -INT, 0, 0 ],
    [ 1, "/symlinks", "# symbolic links", "", -INT, 0, 0 ],
    [ 1, "/metafiles", "# meta files", "", -INT, 0, 0 ],
    [ 1, "/rdmfiles", "# rdm fils", "", -INT, 0, 0 ],
    [ 1, "/overhead", "Memory overhead", "bytes", -INT, 0, 0 ],
    [ 1, "/creates", "# file record creates", "", -INT, 0, 0 ],
    [ 1, "/deletes", "# file record deletes", "", -INT, 0, 0 ],
    ];

_all_core_stat_descriptors.extend(stats_vmfs_store_descriptors);

(find_descriptor(stats_vmfs_store_descriptors,  # For print_func_read_times
                "/read_times").
 append(stats_vmfs_store_descriptors))

#------------------------------------------------------------------------------
# For VMs
# Prefix /prefetch/<lun>/diskpart/<partition>/<vm>
#     or /prefetch/<lun>/diskpart/data/<partition>/<vm>
# Used in vm_debug()
stats_vm_descriptors = [
    #/prefetch/<lun>/<partition>/<vm>
    # VMStats --prefetch/vmdk/vm.h
    # Added by VM::init_stats().
    [ 0, -1, "<i>VM statistics</i>" ],
    [ 0, "/filename", "file name", "", STR ],
    [ 1, "/name", "name", "", STR ],    # In VM title
    [ 0, "/guestOS", "guest OS", "", STR ],
    [ 1, "/disk_count", "disk count", "", -INT, 0, 0 ],
    ];

_all_core_stat_descriptors.extend(stats_vm_descriptors);

#------------------------------------------------------------------------------
vmdk_status_regexp = re.compile("(ok|dormant)$") # For /status

#------------------------------------------------------------------------------
# For VMDKs
# Prefix /prefetch/<lun>/diskpart/<partition>/<vm>/<scsi_part>
#     or /prefetch/<lun>/diskpart/data/<partition>/<vm>/<scsi_part>
# Used in vmdk_debug()
stats_vmdk_descriptors = [
    #/prefetch/<lun>/<partition>/<vm>/<scsi_part>
    # VmdkStats --prefetch/vmdk/vmdk.h
    # Added by Vmdk::init_stats().
    [ 0, -1, "<i>VMDK statistics</i>" ],
    [ 0, "/status", "Vmdk status", "", STR,
      vmdk_status_regexp, 'err', None, "Not ok or dormant:",
      test_func_not_search_regexp],
    [ 0, "/type", "type", "", STR ],    # base, snapshot
    [ 0, "/capacity", "capacity", "", STR ],
    [ 1, "/inodes", "# inodes", "", STR ],
    [ 0, "/cid", "cid", "", STR ],
    [ 1, "/ios_read", "# Reads from EDGE: Vmdk level", "", -INT, 0, 0 ],
    [ 1, "/bytes_read",                 # Paired with ios_read
      "# Bytes in reads from EDGE: Vmdk level", "bytes", -INT, 0, 0 ],
    [ 1, "/ios_write", "# Writes from EDGE: Vmdk level", "", -INT, 0, 0 ],
    [ 1, "/bytes_write",                # Paired with ios_write
      "# bytes in writes from EDGE: Vmdk level", "bytes", -INT, 0, 0 ],
    [ 1, "/push_ios", "# Block ranges pushed to EDGE: Vmdk level", "",
      -INT, 0, 0 ],
    [ 1, "/push_bytes",                 # Paired with push_ios
      "# Bytes pushed to EDGE: Vmdk level", "bytes", -INT, 0, 0 ],
    [ 1, "/n_fb", "# Feedbacks (Read in EDGE): Vmdk level", "", -INT, 0, 0 ],
    [ 1, "/bytes_fb",                   # Paired with n_fb
      "# Bytes in feedbacks (Read in EDGE): Vmdk level", "bytes", -INT, 0, 0 ],
    [ 1, "/ios_local_read", "# Reads by prefetch: Vmdk level", "", -INT, 0, 0],
    [ 1, "/bytes_local_read",           # Paired with ios_local_read
      "# Bytes read by prefetch: Vmdk level", "bytes", -INT, 0, 0 ],
    [ 0, "/snap_count", "# snapshots", "", -INT, 0, 0 ],
    [ 1, "/unresolved_writes", "# unresolved writes", "", -INT, 0, 0 ],
    [ 1, "/descriptor_reads", "# descriptor reads", "", -INT, 0, 0 ],
    ];

_all_core_stat_descriptors.extend(stats_vmdk_descriptors);

#------------------------------------------------------------------------------
# For VMDK snapshots
# Prefix /prefetch/<lun>/diskpart/<partition>/<vm>/<scsi_part>
#     or /prefetch/<lun>/diskpart/data/<partition>/<vm>/<scsi_part>
# Used in vmdk_debug()
stats_vmdk_snapshot_descriptors = [
    #/prefetch/<lun>/<partition>/<vm>/<scsi_part>
    # ClusterMapStats within RLEBiMap --prefetch/fslibs/fs_cluster_group_map.h
    [ 1, -1, "<i>VMDK snapshot statistics</i>" ],
    [ 1, "/disk2snap/cg_map/insert_time_", "Disk to snap insert time", "",
      -BKT, 0, [ 4, 2 ], None, "Data structure slow:" ],
    [ 1, "/disk2snap/cg_map/lookup_time_", "Disk to snap lookup time", "",
      -BKT, 0, [ 4, 2 ], None, "Data structure slow:" ],
    [ 1, "/disk2snap/cg_map/remove_time_", "Disk to snap remove time", "",
      -BKT, 0, [ 4, 2 ], None, "Data structure slow:" ],
    #
    [ 1, "/snap2disk/cg_map/insert_time_", "Snap to disk insert time", "",
      -BKT, 0, [ 4, 2 ], None, "Data structure slow:" ],
    [ 1, "/snap2disk/cg_map/lookup_time_", "Snap to disk lookup time", "",
      -BKT, 0, [ 4, 2 ], None, "Data structure slow:" ],
    [ 1, "/snap2disk/cg_map/remove_time_", "Snap to disk remove time", "",
      -BKT, 0, [ 4, 2 ], None, "Data structure slow:" ],
    ];

_all_core_stat_descriptors.extend(stats_vmdk_snapshot_descriptors);
# -*- python -*-
#
# (C) Copyright 2003-2009 Riverbed Technology, Inc.  
# All rights reserved. Confidential.
#
# ------------- VMFS debugging ---------------------------
def vmfs_debug():
    ''' Debug state of the VMFS crawler'''
    ui_subsection("CORE")
    
    datastores = get_core_stat("/vmfscrawl/*/status", KEY_ENUM)

    if datastores == None:
        ui_info("No VMFS LUN.")
        return

    if 0 == len(datastores):
        ui_info("No datastores found.")
        return

    for datastore in datastores:
        tmp = False
        ui_title("Datastore: <b>%s</b>" % datastore, 3)
        ui_start_ul();
        # first print information of datastore
        val = get_core_stat("/vmfscrawl/%s/ctx" % datastore, STR)
        ui_li("Ctx: %s" % val)
        val = get_core_stat("/vmfscrawl/%s/uuid" % datastore, STR)
        ui_li("UUID: %s" % val)
        val = get_core_stat("/vmfscrawl/%s/capacity" % datastore, INT)
        ui_li("Capacity: %d" % val)
        val = get_core_stat("/vmfscrawl/%s/files" % datastore, INT)
        if val < 1:
            ui_li("No files have been found on the datastore.", "warn")
        val = get_core_stat("/vmfscrawl/%s/dirs" % datastore, INT)
        if val < 1:
            ui_li("Number of dirs is less than 1. There is always root directory present.", "err")
        val = get_core_stat("/vmfscrawl/%s/metafiles" % datastore, INT)
        if val < 5:
            ui_li("Number of metafiles is less than 5. There should always be at least 5 of them", "err")
        val = get_core_stat("/vmfscrawl/%s/overhead" % datastore, INT)
        ui_li("Overhead: %d" % val)
                
        # analyze the stats
        val = get_core_stat("/vmfscrawl/%s/status" % datastore, STR)
        if "OK" != val:
            ui_li("Crawler is not in a valid state. status: %s" % val, "warn")
            tmp = True
        val = get_core_stat("/vmfscrawl/%s/status" % datastore, STR)
        if "OK" != val:
            ui_li("Crawler is not in a valid state. status: %s" % val, "warn")
            tmp = True
        
        if tmp == False:
            ui_li("All seems good")
        ui_end_ul();
            
    ui_meta("%d datastores" % len(datastores))    
	
# -*- python -*-
#
# (C) Copyright 2003-2009 Riverbed Technology, Inc.  
# All rights reserved. Confidential.
#
# ------------- Hinter debugging ---------------------------
def hinter_debug():
    ''' Debug state of the hinter '''
    global _debug
    ui_subsection("CORE")
    
    serials = get_core_stat("/hinter_bucket/*/0/num_false_pos_", KEY_ENUM)
    if (_debug & 512) != 0:
        print "serials", serials
    if (not serials) or (0 == len(serials)):
        ui_warn("No LUNs being processed by hinter. Is hinter disabled?")
        return

    totalbkts = 0
    for serial in serials:
        if (_debug & 512) != 0:
            print "serial", serial
        tmp = False
        ui_title("LUN: <b>%s</b>" % serial, 3)
        value = get_core_stat("/hinter_bucket/%s/0/num_false_pos_" % serial,
                             INT)
        if value > 10:
            ui_warn("Large false positives detected. num_false_pos: %d" %
                    value)
            tmp = True
        value = get_core_stat("/HinterTable/%s/total_recycle" % serial, INT)
        if value > 10:
            ui_warn("Large bucket recycling detected. total_recycle: %d" %
                    value)
            tmp = True
        # validate bucket count
        value = get_core_stat("/HinterTable/%s/bucket_count" % serial, INT)
        bkts = get_core_stat("/hinter_bucket/%s/*/total_req" % serial, KEY_ENUM)
        totalbkts += len(bkts)
        if len(bkts) != value:
            ui_warn("Bucket count invalid. bucket_count: %d, #buckets: %d" %
                    (value, len(bkts)))
            tmp = True
        for bkt in bkts:
            value = get_core_stat("/hinter_bucket/%s/%s/num_false_pos_" %
                                 (serial, bkt), INT)
            if value > 100:
                start = get_core_stat("/hinter_bucket/%s/%s/start_addr_" %
                                     (serial, bkt), INT)
                ui_warn("Large false positives in bucket %s."
                        " start_addr: %d, num_false_pos: %d" %
                        (bkt, start, value))
                tmp = True
            # TODO: account for hits and misses
            
        if tmp == False:
            ui_msg("All good", 0, "")
            
    ui_meta("%d LUNs" % len(serials))
    ui_meta("%d buckets" % totalbkts)
# -*- python -*-
#
# (C) Copyright 2003-2009 Riverbed Technology, Inc.  
# All rights reserved. Confidential.
#
# ------------- RAW debugging ---------------------------
import shlex

def raw_debug():
    global _debug                       # In
    global _cmd_options_set             # In
    global CMD_OPTION_CORE              # In
    global CMD_OPTION_EDGE              # In
    global STATS_LINES                  # In
    global _edges                       # In
    global _cores                       # In
    global _edgestats                   # In
    global _corestats                   # In
    if (_debug & 4) != 0:
        if (_cmd_options_set & CMD_OPTION_EDGE) != 0:
            len_edges = len(_edges)
            for stat_idx in range(0, len_edges):
                ui_subsection("edge %s" % _edges[stat_idx][1])
                dump_raw(_edgestats[stat_idx][STATS_LINES], (4 * stat_idx) + 1)
        if (_cmd_options_set & CMD_OPTION_CORE) != 0:
            len_cores = len(_cores)
            for stat_idx in range(0, len_cores):
                ui_subsection("core %s" % _cores[stat_idx][1])
                dump_raw(_corestats[stat_idx][STATS_LINES], (4 * stat_idx) + 2)
    else:
        if (_cmd_options_set & CMD_OPTION_EDGE) != 0:
            if len(_edgestats) > 0:
                ui_subsection("edge")
                dump_raw(_edgestats[-1][STATS_LINES], 1)
        if (_cmd_options_set & CMD_OPTION_CORE) != 0:
            if len(_corestats) > 0:
                ui_subsection("core")
                dump_raw(_corestats[-1][STATS_LINES], 2)

raw_pattern = "^([^\s]+)\s+(.*)"
raw_regex = re.compile(raw_pattern)
raw_bucket_pattern = "^([ 0-9]|max:|Aggregate :)"
raw_bucket_regex = re.compile(bucket_pattern)
def dump_raw(stats, index):
    ''' This just saves the raw stats in the outout'''
#    print "dump_raw:", "index", index, "len(stats)", len(stats), "type(stats)", type(stats), "stats", stats
    global raw_regex                    # In
    global raw_bucket_regex             # In
    global STATS_LINES                  # In
    str =  "<div id=\"rawstats%d-nav\" class=\"listNav\"></div>" % index
    str += "<ul id=\"rawstats%d\">" % index
    for i in xrange(0, len(stats)):
#        print "dump_raw: stats[%d]:" % i, stats[i]
        stat = stats[i][STATS_LINES]
        m = raw_regex.match(stat)
        if m != None:
            # this could be a bucket stat
            if (i < (len(stats) - 1)) and raw_bucket_regex.match(stats[i+1][STATS_LINES]):
                # neglect bucket stat
                while raw_bucket_regex.match(stats[i+1][STATS_LINES]):
                    i += 1
            else:
                str += ( "<li><b>%s:</b> %s</li>" %
                         (m.group(1).strip()[1:], m.group(2).strip()) )
        else:
            str += "<li>Could not match stat %s</li>" % stat
    str += '</ul>'
    
    str += ( "<script>$('#rawstats%d').listnav({initLetter: 'a'});</script>" %
             index )
    
    ui_output(str)
    
# -*- python -*-
#
# (C) Copyright 2003-2009 Riverbed Technology, Inc.  
# All rights reserved. Confidential.
#
# ------------- Global debugging ---------------------------
def global_debug():
	''' Global information and state of the VE setup '''
	ui_subsection("Overall System Info")
	

#--------------- TEMPLATE ---------------
_template = """
PCFET0NUWVBFIGh0bWwgUFVCTElDICItLy9XM0MvL0RURCBYSFRNTCAxLjAgU3RyaWN0Ly9FTiIN
CgkiaHR0cDovL3d3dy53My5vcmcvVFIveGh0bWwxL0RURC94aHRtbDEtc3RyaWN0LmR0ZCI+IA0K
PGh0bWwgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIGRpcj0ibHRyIiBsYW5n
PSJlbi1VUyI+IA0KIA0KPGhlYWQgcHJvZmlsZT0iaHR0cDovL2dtcGcub3JnL3hmbi8xMSI+IA0K
CTx0aXRsZT5AQFBBR0VUSVRMRUBAPC90aXRsZT4gDQoJPG1ldGEgaHR0cC1lcXVpdj0iQ29udGVu
dC1UeXBlIiBjb250ZW50PSJ0ZXh0L2h0bWw7IGNoYXJzZXQ9VVRGLTgiIC8+IA0KICAgIDxzY3Jp
cHQgbGFuZ3VhZ2U9ImphdmFzY3JpcHQiIHR5cGU9InRleHQvamF2YXNjcmlwdCI+DQoJLyogalF1
ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2MS42LjEgKGh0dHA6Ly9qcXVlcnkuY29tKSAqLw0KICAg
IChmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGN5KGEpe3JldHVybiBmLmlzV2luZG93KGEpP2E6YS5u
b2RlVHlwZT09PTk/YS5kZWZhdWx0Vmlld3x8YS5wYXJlbnRXaW5kb3c6ITF9ZnVuY3Rpb24gY3Yo
YSl7aWYoIWNqW2FdKXt2YXIgYj1mKCI8IithKyI+IikuYXBwZW5kVG8oImJvZHkiKSxkPWIuY3Nz
KCJkaXNwbGF5Iik7Yi5yZW1vdmUoKTtpZihkPT09Im5vbmUifHxkPT09IiIpe2NrfHwoY2s9Yy5j
cmVhdGVFbGVtZW50KCJpZnJhbWUiKSxjay5mcmFtZUJvcmRlcj1jay53aWR0aD1jay5oZWlnaHQ9
MCksYy5ib2R5LmFwcGVuZENoaWxkKGNrKTtpZighY2x8fCFjay5jcmVhdGVFbGVtZW50KWNsPShj
ay5jb250ZW50V2luZG93fHxjay5jb250ZW50RG9jdW1lbnQpLmRvY3VtZW50LGNsLndyaXRlKCI8
IWRvY3R5cGU+PGh0bWw+PGJvZHk+PC9ib2R5PjwvaHRtbD4iKTtiPWNsLmNyZWF0ZUVsZW1lbnQo
YSksY2wuYm9keS5hcHBlbmRDaGlsZChiKSxkPWYuY3NzKGIsImRpc3BsYXkiKSxjLmJvZHkucmVt
b3ZlQ2hpbGQoY2spfWNqW2FdPWR9cmV0dXJuIGNqW2FdfWZ1bmN0aW9uIGN1KGEsYil7dmFyIGM9
e307Zi5lYWNoKGNwLmNvbmNhdC5hcHBseShbXSxjcC5zbGljZSgwLGIpKSxmdW5jdGlvbigpe2Nb
dGhpc109YX0pO3JldHVybiBjfWZ1bmN0aW9uIGN0KCl7Y3E9Yn1mdW5jdGlvbiBjcygpe3NldFRp
bWVvdXQoY3QsMCk7cmV0dXJuIGNxPWYubm93KCl9ZnVuY3Rpb24gY2koKXt0cnl7cmV0dXJuIG5l
dyBhLkFjdGl2ZVhPYmplY3QoIk1pY3Jvc29mdC5YTUxIVFRQIil9Y2F0Y2goYil7fX1mdW5jdGlv
biBjaCgpe3RyeXtyZXR1cm4gbmV3IGEuWE1MSHR0cFJlcXVlc3R9Y2F0Y2goYil7fX1mdW5jdGlv
biBjYihhLGMpe2EuZGF0YUZpbHRlciYmKGM9YS5kYXRhRmlsdGVyKGMsYS5kYXRhVHlwZSkpO3Zh
ciBkPWEuZGF0YVR5cGVzLGU9e30sZyxoLGk9ZC5sZW5ndGgsaixrPWRbMF0sbCxtLG4sbyxwO2Zv
cihnPTE7ZzxpO2crKyl7aWYoZz09PTEpZm9yKGggaW4gYS5jb252ZXJ0ZXJzKXR5cGVvZiBoPT0i
c3RyaW5nIiYmKGVbaC50b0xvd2VyQ2FzZSgpXT1hLmNvbnZlcnRlcnNbaF0pO2w9ayxrPWRbZ107
aWYoaz09PSIqIilrPWw7ZWxzZSBpZihsIT09IioiJiZsIT09ayl7bT1sKyIgIitrLG49ZVttXXx8
ZVsiKiAiK2tdO2lmKCFuKXtwPWI7Zm9yKG8gaW4gZSl7aj1vLnNwbGl0KCIgIik7aWYoalswXT09
PWx8fGpbMF09PT0iKiIpe3A9ZVtqWzFdKyIgIitrXTtpZihwKXtvPWVbb10sbz09PSEwP249cDpw
PT09ITAmJihuPW8pO2JyZWFrfX19fSFuJiYhcCYmZi5lcnJvcigiTm8gY29udmVyc2lvbiBmcm9t
ICIrbS5yZXBsYWNlKCIgIiwiIHRvICIpKSxuIT09ITAmJihjPW4/bihjKTpwKG8oYykpKX19cmV0
dXJuIGN9ZnVuY3Rpb24gY2EoYSxjLGQpe3ZhciBlPWEuY29udGVudHMsZj1hLmRhdGFUeXBlcyxn
PWEucmVzcG9uc2VGaWVsZHMsaCxpLGosaztmb3IoaSBpbiBnKWkgaW4gZCYmKGNbZ1tpXV09ZFtp
XSk7d2hpbGUoZlswXT09PSIqIilmLnNoaWZ0KCksaD09PWImJihoPWEubWltZVR5cGV8fGMuZ2V0
UmVzcG9uc2VIZWFkZXIoImNvbnRlbnQtdHlwZSIpKTtpZihoKWZvcihpIGluIGUpaWYoZVtpXSYm
ZVtpXS50ZXN0KGgpKXtmLnVuc2hpZnQoaSk7YnJlYWt9aWYoZlswXWluIGQpaj1mWzBdO2Vsc2V7
Zm9yKGkgaW4gZCl7aWYoIWZbMF18fGEuY29udmVydGVyc1tpKyIgIitmWzBdXSl7aj1pO2JyZWFr
fWt8fChrPWkpfWo9anx8a31pZihqKXtqIT09ZlswXSYmZi51bnNoaWZ0KGopO3JldHVybiBkW2pd
fX1mdW5jdGlvbiBiXyhhLGIsYyxkKXtpZihmLmlzQXJyYXkoYikpZi5lYWNoKGIsZnVuY3Rpb24o
YixlKXtjfHxiRi50ZXN0KGEpP2QoYSxlKTpiXyhhKyJbIisodHlwZW9mIGU9PSJvYmplY3QifHxm
LmlzQXJyYXkoZSk/YjoiIikrIl0iLGUsYyxkKX0pO2Vsc2UgaWYoIWMmJmIhPW51bGwmJnR5cGVv
ZiBiPT0ib2JqZWN0Iilmb3IodmFyIGUgaW4gYiliXyhhKyJbIitlKyJdIixiW2VdLGMsZCk7ZWxz
ZSBkKGEsYil9ZnVuY3Rpb24gYiQoYSxjLGQsZSxmLGcpe2Y9Znx8Yy5kYXRhVHlwZXNbMF0sZz1n
fHx7fSxnW2ZdPSEwO3ZhciBoPWFbZl0saT0wLGo9aD9oLmxlbmd0aDowLGs9YT09PWJVLGw7Zm9y
KDtpPGomJihrfHwhbCk7aSsrKWw9aFtpXShjLGQsZSksdHlwZW9mIGw9PSJzdHJpbmciJiYoIWt8
fGdbbF0/bD1iOihjLmRhdGFUeXBlcy51bnNoaWZ0KGwpLGw9YiQoYSxjLGQsZSxsLGcpKSk7KGt8
fCFsKSYmIWdbIioiXSYmKGw9YiQoYSxjLGQsZSwiKiIsZykpO3JldHVybiBsfWZ1bmN0aW9uIGJa
KGEpe3JldHVybiBmdW5jdGlvbihiLGMpe3R5cGVvZiBiIT0ic3RyaW5nIiYmKGM9YixiPSIqIik7
aWYoZi5pc0Z1bmN0aW9uKGMpKXt2YXIgZD1iLnRvTG93ZXJDYXNlKCkuc3BsaXQoYlEpLGU9MCxn
PWQubGVuZ3RoLGgsaSxqO2Zvcig7ZTxnO2UrKyloPWRbZV0saj0vXlwrLy50ZXN0KGgpLGomJiho
PWguc3Vic3RyKDEpfHwiKiIpLGk9YVtoXT1hW2hdfHxbXSxpW2o/InVuc2hpZnQiOiJwdXNoIl0o
Yyl9fX1mdW5jdGlvbiBiRChhLGIsYyl7dmFyIGQ9Yj09PSJ3aWR0aCI/Yng6YnksZT1iPT09Indp
ZHRoIj9hLm9mZnNldFdpZHRoOmEub2Zmc2V0SGVpZ2h0O2lmKGM9PT0iYm9yZGVyIilyZXR1cm4g
ZTtmLmVhY2goZCxmdW5jdGlvbigpe2N8fChlLT1wYXJzZUZsb2F0KGYuY3NzKGEsInBhZGRpbmci
K3RoaXMpKXx8MCksYz09PSJtYXJnaW4iP2UrPXBhcnNlRmxvYXQoZi5jc3MoYSwibWFyZ2luIit0
aGlzKSl8fDA6ZS09cGFyc2VGbG9hdChmLmNzcyhhLCJib3JkZXIiK3RoaXMrIldpZHRoIikpfHww
fSk7cmV0dXJuIGV9ZnVuY3Rpb24gYm4oYSxiKXtiLnNyYz9mLmFqYXgoe3VybDpiLnNyYyxhc3lu
YzohMSxkYXRhVHlwZToic2NyaXB0In0pOmYuZ2xvYmFsRXZhbCgoYi50ZXh0fHxiLnRleHRDb250
ZW50fHxiLmlubmVySFRNTHx8IiIpLnJlcGxhY2UoYmYsIi8qJDAqLyIpKSxiLnBhcmVudE5vZGUm
JmIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKX1mdW5jdGlvbiBibShhKXtmLm5vZGVOYW1lKGEs
ImlucHV0Iik/YmwoYSk6YS5nZXRFbGVtZW50c0J5VGFnTmFtZSYmZi5ncmVwKGEuZ2V0RWxlbWVu
dHNCeVRhZ05hbWUoImlucHV0IiksYmwpfWZ1bmN0aW9uIGJsKGEpe2lmKGEudHlwZT09PSJjaGVj
a2JveCJ8fGEudHlwZT09PSJyYWRpbyIpYS5kZWZhdWx0Q2hlY2tlZD1hLmNoZWNrZWR9ZnVuY3Rp
b24gYmsoYSl7cmV0dXJuImdldEVsZW1lbnRzQnlUYWdOYW1lImluIGE/YS5nZXRFbGVtZW50c0J5
VGFnTmFtZSgiKiIpOiJxdWVyeVNlbGVjdG9yQWxsImluIGE/YS5xdWVyeVNlbGVjdG9yQWxsKCIq
Iik6W119ZnVuY3Rpb24gYmooYSxiKXt2YXIgYztpZihiLm5vZGVUeXBlPT09MSl7Yi5jbGVhckF0
dHJpYnV0ZXMmJmIuY2xlYXJBdHRyaWJ1dGVzKCksYi5tZXJnZUF0dHJpYnV0ZXMmJmIubWVyZ2VB
dHRyaWJ1dGVzKGEpLGM9Yi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO2lmKGM9PT0ib2JqZWN0Iili
Lm91dGVySFRNTD1hLm91dGVySFRNTDtlbHNlIGlmKGMhPT0iaW5wdXQifHxhLnR5cGUhPT0iY2hl
Y2tib3giJiZhLnR5cGUhPT0icmFkaW8iKXtpZihjPT09Im9wdGlvbiIpYi5zZWxlY3RlZD1hLmRl
ZmF1bHRTZWxlY3RlZDtlbHNlIGlmKGM9PT0iaW5wdXQifHxjPT09InRleHRhcmVhIiliLmRlZmF1
bHRWYWx1ZT1hLmRlZmF1bHRWYWx1ZX1lbHNlIGEuY2hlY2tlZCYmKGIuZGVmYXVsdENoZWNrZWQ9
Yi5jaGVja2VkPWEuY2hlY2tlZCksYi52YWx1ZSE9PWEudmFsdWUmJihiLnZhbHVlPWEudmFsdWUp
O2IucmVtb3ZlQXR0cmlidXRlKGYuZXhwYW5kbyl9fWZ1bmN0aW9uIGJpKGEsYil7aWYoYi5ub2Rl
VHlwZT09PTEmJiEhZi5oYXNEYXRhKGEpKXt2YXIgYz1mLmV4cGFuZG8sZD1mLmRhdGEoYSksZT1m
LmRhdGEoYixkKTtpZihkPWRbY10pe3ZhciBnPWQuZXZlbnRzO2U9ZVtjXT1mLmV4dGVuZCh7fSxk
KTtpZihnKXtkZWxldGUgZS5oYW5kbGUsZS5ldmVudHM9e307Zm9yKHZhciBoIGluIGcpZm9yKHZh
ciBpPTAsaj1nW2hdLmxlbmd0aDtpPGo7aSsrKWYuZXZlbnQuYWRkKGIsaCsoZ1toXVtpXS5uYW1l
c3BhY2U/Ii4iOiIiKStnW2hdW2ldLm5hbWVzcGFjZSxnW2hdW2ldLGdbaF1baV0uZGF0YSl9fX19
ZnVuY3Rpb24gYmgoYSxiKXtyZXR1cm4gZi5ub2RlTmFtZShhLCJ0YWJsZSIpP2EuZ2V0RWxlbWVu
dHNCeVRhZ05hbWUoInRib2R5IilbMF18fGEuYXBwZW5kQ2hpbGQoYS5vd25lckRvY3VtZW50LmNy
ZWF0ZUVsZW1lbnQoInRib2R5IikpOmF9ZnVuY3Rpb24gWChhLGIsYyl7Yj1ifHwwO2lmKGYuaXNG
dW5jdGlvbihiKSlyZXR1cm4gZi5ncmVwKGEsZnVuY3Rpb24oYSxkKXt2YXIgZT0hIWIuY2FsbChh
LGQsYSk7cmV0dXJuIGU9PT1jfSk7aWYoYi5ub2RlVHlwZSlyZXR1cm4gZi5ncmVwKGEsZnVuY3Rp
b24oYSxkKXtyZXR1cm4gYT09PWI9PT1jfSk7aWYodHlwZW9mIGI9PSJzdHJpbmciKXt2YXIgZD1m
LmdyZXAoYSxmdW5jdGlvbihhKXtyZXR1cm4gYS5ub2RlVHlwZT09PTF9KTtpZihTLnRlc3QoYikp
cmV0dXJuIGYuZmlsdGVyKGIsZCwhYyk7Yj1mLmZpbHRlcihiLGQpfXJldHVybiBmLmdyZXAoYSxm
dW5jdGlvbihhLGQpe3JldHVybiBmLmluQXJyYXkoYSxiKT49MD09PWN9KX1mdW5jdGlvbiBXKGEp
e3JldHVybiFhfHwhYS5wYXJlbnROb2RlfHxhLnBhcmVudE5vZGUubm9kZVR5cGU9PT0xMX1mdW5j
dGlvbiBPKGEsYil7cmV0dXJuKGEmJmEhPT0iKiI/YSsiLiI6IiIpK2IucmVwbGFjZShBLCJgIiku
cmVwbGFjZShCLCImIil9ZnVuY3Rpb24gTihhKXt2YXIgYixjLGQsZSxnLGgsaSxqLGssbCxtLG4s
byxwPVtdLHE9W10scj1mLl9kYXRhKHRoaXMsImV2ZW50cyIpO2lmKCEoYS5saXZlRmlyZWQ9PT10
aGlzfHwhcnx8IXIubGl2ZXx8YS50YXJnZXQuZGlzYWJsZWR8fGEuYnV0dG9uJiZhLnR5cGU9PT0i
Y2xpY2siKSl7YS5uYW1lc3BhY2UmJihuPW5ldyBSZWdFeHAoIihefFxcLikiK2EubmFtZXNwYWNl
LnNwbGl0KCIuIikuam9pbigiXFwuKD86LipcXC4pPyIpKyIoXFwufCQpIikpLGEubGl2ZUZpcmVk
PXRoaXM7dmFyIHM9ci5saXZlLnNsaWNlKDApO2ZvcihpPTA7aTxzLmxlbmd0aDtpKyspZz1zW2ld
LGcub3JpZ1R5cGUucmVwbGFjZSh5LCIiKT09PWEudHlwZT9xLnB1c2goZy5zZWxlY3Rvcik6cy5z
cGxpY2UoaS0tLDEpO2U9ZihhLnRhcmdldCkuY2xvc2VzdChxLGEuY3VycmVudFRhcmdldCk7Zm9y
KGo9MCxrPWUubGVuZ3RoO2o8aztqKyspe209ZVtqXTtmb3IoaT0wO2k8cy5sZW5ndGg7aSsrKXtn
PXNbaV07aWYobS5zZWxlY3Rvcj09PWcuc2VsZWN0b3ImJighbnx8bi50ZXN0KGcubmFtZXNwYWNl
KSkmJiFtLmVsZW0uZGlzYWJsZWQpe2g9bS5lbGVtLGQ9bnVsbDtpZihnLnByZVR5cGU9PT0ibW91
c2VlbnRlciJ8fGcucHJlVHlwZT09PSJtb3VzZWxlYXZlIilhLnR5cGU9Zy5wcmVUeXBlLGQ9Zihh
LnJlbGF0ZWRUYXJnZXQpLmNsb3Nlc3QoZy5zZWxlY3RvcilbMF0sZCYmZi5jb250YWlucyhoLGQp
JiYoZD1oKTsoIWR8fGQhPT1oKSYmcC5wdXNoKHtlbGVtOmgsaGFuZGxlT2JqOmcsbGV2ZWw6bS5s
ZXZlbH0pfX19Zm9yKGo9MCxrPXAubGVuZ3RoO2o8aztqKyspe2U9cFtqXTtpZihjJiZlLmxldmVs
PmMpYnJlYWs7YS5jdXJyZW50VGFyZ2V0PWUuZWxlbSxhLmRhdGE9ZS5oYW5kbGVPYmouZGF0YSxh
LmhhbmRsZU9iaj1lLmhhbmRsZU9iaixvPWUuaGFuZGxlT2JqLm9yaWdIYW5kbGVyLmFwcGx5KGUu
ZWxlbSxhcmd1bWVudHMpO2lmKG89PT0hMXx8YS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKXtjPWUu
bGV2ZWwsbz09PSExJiYoYj0hMSk7aWYoYS5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgp
KWJyZWFrfX1yZXR1cm4gYn19ZnVuY3Rpb24gTChhLGMsZCl7dmFyIGU9Zi5leHRlbmQoe30sZFsw
XSk7ZS50eXBlPWEsZS5vcmlnaW5hbEV2ZW50PXt9LGUubGl2ZUZpcmVkPWIsZi5ldmVudC5oYW5k
bGUuY2FsbChjLGUpLGUuaXNEZWZhdWx0UHJldmVudGVkKCkmJmRbMF0ucHJldmVudERlZmF1bHQo
KX1mdW5jdGlvbiBGKCl7cmV0dXJuITB9ZnVuY3Rpb24gRSgpe3JldHVybiExfWZ1bmN0aW9uIG0o
YSxjLGQpe3ZhciBlPWMrImRlZmVyIixnPWMrInF1ZXVlIixoPWMrIm1hcmsiLGk9Zi5kYXRhKGEs
ZSxiLCEwKTtpJiYoZD09PSJxdWV1ZSJ8fCFmLmRhdGEoYSxnLGIsITApKSYmKGQ9PT0ibWFyayJ8
fCFmLmRhdGEoYSxoLGIsITApKSYmc2V0VGltZW91dChmdW5jdGlvbigpeyFmLmRhdGEoYSxnLGIs
ITApJiYhZi5kYXRhKGEsaCxiLCEwKSYmKGYucmVtb3ZlRGF0YShhLGUsITApLGkucmVzb2x2ZSgp
KX0sMCl9ZnVuY3Rpb24gbChhKXtmb3IodmFyIGIgaW4gYSlpZihiIT09InRvSlNPTiIpcmV0dXJu
ITE7cmV0dXJuITB9ZnVuY3Rpb24gayhhLGMsZCl7aWYoZD09PWImJmEubm9kZVR5cGU9PT0xKXt2
YXIgZT0iZGF0YS0iK2MucmVwbGFjZShqLCIkMS0kMiIpLnRvTG93ZXJDYXNlKCk7ZD1hLmdldEF0
dHJpYnV0ZShlKTtpZih0eXBlb2YgZD09InN0cmluZyIpe3RyeXtkPWQ9PT0idHJ1ZSI/ITA6ZD09
PSJmYWxzZSI/ITE6ZD09PSJudWxsIj9udWxsOmYuaXNOYU4oZCk/aS50ZXN0KGQpP2YucGFyc2VK
U09OKGQpOmQ6cGFyc2VGbG9hdChkKX1jYXRjaChnKXt9Zi5kYXRhKGEsYyxkKX1lbHNlIGQ9Yn1y
ZXR1cm4gZH12YXIgYz1hLmRvY3VtZW50LGQ9YS5uYXZpZ2F0b3IsZT1hLmxvY2F0aW9uLGY9ZnVu
Y3Rpb24oKXtmdW5jdGlvbiBIKCl7aWYoIWUuaXNSZWFkeSl7dHJ5e2MuZG9jdW1lbnRFbGVtZW50
LmRvU2Nyb2xsKCJsZWZ0Iil9Y2F0Y2goYSl7c2V0VGltZW91dChILDEpO3JldHVybn1lLnJlYWR5
KCl9fXZhciBlPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBlLmZuLmluaXQoYSxiLGgpfSxmPWEu
alF1ZXJ5LGc9YS4kLGgsaT0vXig/OltePF0qKDxbXHdcV10rPilbXj5dKiR8IyhbXHdcLV0qKSQp
LyxqPS9cUy8saz0vXlxzKy8sbD0vXHMrJC8sbT0vXGQvLG49L148KFx3KylccypcLz8+KD86PFwv
XDE+KT8kLyxvPS9eW1xdLDp7fVxzXSokLyxwPS9cXCg/OlsiXFxcL2JmbnJ0XXx1WzAtOWEtZkEt
Rl17NH0pL2cscT0vIlteIlxcXG5ccl0qInx0cnVlfGZhbHNlfG51bGx8LT9cZCsoPzpcLlxkKik/
KD86W2VFXVsrXC1dP1xkKyk/L2cscj0vKD86Xnw6fCwpKD86XHMqXFspKy9nLHM9Lyh3ZWJraXQp
WyBcL10oW1x3Ll0rKS8sdD0vKG9wZXJhKSg/Oi4qdmVyc2lvbik/WyBcL10oW1x3Ll0rKS8sdT0v
KG1zaWUpIChbXHcuXSspLyx2PS8obW96aWxsYSkoPzouKj8gcnY6KFtcdy5dKykpPy8sdz1kLnVz
ZXJBZ2VudCx4LHkseixBPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsQj1PYmplY3QucHJvdG90
eXBlLmhhc093blByb3BlcnR5LEM9QXJyYXkucHJvdG90eXBlLnB1c2gsRD1BcnJheS5wcm90b3R5
cGUuc2xpY2UsRT1TdHJpbmcucHJvdG90eXBlLnRyaW0sRj1BcnJheS5wcm90b3R5cGUuaW5kZXhP
ZixHPXt9O2UuZm49ZS5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOmUsaW5pdDpmdW5jdGlvbihhLGQs
Zil7dmFyIGcsaCxqLGs7aWYoIWEpcmV0dXJuIHRoaXM7aWYoYS5ub2RlVHlwZSl7dGhpcy5jb250
ZXh0PXRoaXNbMF09YSx0aGlzLmxlbmd0aD0xO3JldHVybiB0aGlzfWlmKGE9PT0iYm9keSImJiFk
JiZjLmJvZHkpe3RoaXMuY29udGV4dD1jLHRoaXNbMF09Yy5ib2R5LHRoaXMuc2VsZWN0b3I9YSx0
aGlzLmxlbmd0aD0xO3JldHVybiB0aGlzfWlmKHR5cGVvZiBhPT0ic3RyaW5nIil7YS5jaGFyQXQo
MCkhPT0iPCJ8fGEuY2hhckF0KGEubGVuZ3RoLTEpIT09Ij4ifHxhLmxlbmd0aDwzP2c9aS5leGVj
KGEpOmc9W251bGwsYSxudWxsXTtpZihnJiYoZ1sxXXx8IWQpKXtpZihnWzFdKXtkPWQgaW5zdGFu
Y2VvZiBlP2RbMF06ZCxrPWQ/ZC5vd25lckRvY3VtZW50fHxkOmMsaj1uLmV4ZWMoYSksaj9lLmlz
UGxhaW5PYmplY3QoZCk/KGE9W2MuY3JlYXRlRWxlbWVudChqWzFdKV0sZS5mbi5hdHRyLmNhbGwo
YSxkLCEwKSk6YT1bay5jcmVhdGVFbGVtZW50KGpbMV0pXTooaj1lLmJ1aWxkRnJhZ21lbnQoW2db
MV1dLFtrXSksYT0oai5jYWNoZWFibGU/ZS5jbG9uZShqLmZyYWdtZW50KTpqLmZyYWdtZW50KS5j
aGlsZE5vZGVzKTtyZXR1cm4gZS5tZXJnZSh0aGlzLGEpfWg9Yy5nZXRFbGVtZW50QnlJZChnWzJd
KTtpZihoJiZoLnBhcmVudE5vZGUpe2lmKGguaWQhPT1nWzJdKXJldHVybiBmLmZpbmQoYSk7dGhp
cy5sZW5ndGg9MSx0aGlzWzBdPWh9dGhpcy5jb250ZXh0PWMsdGhpcy5zZWxlY3Rvcj1hO3JldHVy
biB0aGlzfXJldHVybiFkfHxkLmpxdWVyeT8oZHx8ZikuZmluZChhKTp0aGlzLmNvbnN0cnVjdG9y
KGQpLmZpbmQoYSl9aWYoZS5pc0Z1bmN0aW9uKGEpKXJldHVybiBmLnJlYWR5KGEpO2Euc2VsZWN0
b3IhPT1iJiYodGhpcy5zZWxlY3Rvcj1hLnNlbGVjdG9yLHRoaXMuY29udGV4dD1hLmNvbnRleHQp
O3JldHVybiBlLm1ha2VBcnJheShhLHRoaXMpfSxzZWxlY3RvcjoiIixqcXVlcnk6IjEuNi4xIixs
ZW5ndGg6MCxzaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGVuZ3RofSx0b0FycmF5OmZ1bmN0
aW9uKCl7cmV0dXJuIEQuY2FsbCh0aGlzLDApfSxnZXQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGE9PW51
bGw/dGhpcy50b0FycmF5KCk6YTwwP3RoaXNbdGhpcy5sZW5ndGgrYV06dGhpc1thXX0scHVzaFN0
YWNrOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLmNvbnN0cnVjdG9yKCk7ZS5pc0FycmF5KGEp
P0MuYXBwbHkoZCxhKTplLm1lcmdlKGQsYSksZC5wcmV2T2JqZWN0PXRoaXMsZC5jb250ZXh0PXRo
aXMuY29udGV4dCxiPT09ImZpbmQiP2Quc2VsZWN0b3I9dGhpcy5zZWxlY3RvcisodGhpcy5zZWxl
Y3Rvcj8iICI6IiIpK2M6YiYmKGQuc2VsZWN0b3I9dGhpcy5zZWxlY3RvcisiLiIrYisiKCIrYysi
KSIpO3JldHVybiBkfSxlYWNoOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGUuZWFjaCh0aGlzLGEsYil9
LHJlYWR5OmZ1bmN0aW9uKGEpe2UuYmluZFJlYWR5KCkseS5kb25lKGEpO3JldHVybiB0aGlzfSxl
cTpmdW5jdGlvbihhKXtyZXR1cm4gYT09PS0xP3RoaXMuc2xpY2UoYSk6dGhpcy5zbGljZShhLCth
KzEpfSxmaXJzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVxKDApfSxsYXN0OmZ1bmN0aW9uKCl7
cmV0dXJuIHRoaXMuZXEoLTEpfSxzbGljZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB1c2hTdGFj
ayhELmFwcGx5KHRoaXMsYXJndW1lbnRzKSwic2xpY2UiLEQuY2FsbChhcmd1bWVudHMpLmpvaW4o
IiwiKSl9LG1hcDpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soZS5tYXAodGhpcyxm
dW5jdGlvbihiLGMpe3JldHVybiBhLmNhbGwoYixjLGIpfSkpfSxlbmQ6ZnVuY3Rpb24oKXtyZXR1
cm4gdGhpcy5wcmV2T2JqZWN0fHx0aGlzLmNvbnN0cnVjdG9yKG51bGwpfSxwdXNoOkMsc29ydDpb
XS5zb3J0LHNwbGljZTpbXS5zcGxpY2V9LGUuZm4uaW5pdC5wcm90b3R5cGU9ZS5mbixlLmV4dGVu
ZD1lLmZuLmV4dGVuZD1mdW5jdGlvbigpe3ZhciBhLGMsZCxmLGcsaCxpPWFyZ3VtZW50c1swXXx8
e30saj0xLGs9YXJndW1lbnRzLmxlbmd0aCxsPSExO3R5cGVvZiBpPT0iYm9vbGVhbiImJihsPWks
aT1hcmd1bWVudHNbMV18fHt9LGo9MiksdHlwZW9mIGkhPSJvYmplY3QiJiYhZS5pc0Z1bmN0aW9u
KGkpJiYoaT17fSksaz09PWomJihpPXRoaXMsLS1qKTtmb3IoO2o8aztqKyspaWYoKGE9YXJndW1l
bnRzW2pdKSE9bnVsbClmb3IoYyBpbiBhKXtkPWlbY10sZj1hW2NdO2lmKGk9PT1mKWNvbnRpbnVl
O2wmJmYmJihlLmlzUGxhaW5PYmplY3QoZil8fChnPWUuaXNBcnJheShmKSkpPyhnPyhnPSExLGg9
ZCYmZS5pc0FycmF5KGQpP2Q6W10pOmg9ZCYmZS5pc1BsYWluT2JqZWN0KGQpP2Q6e30saVtjXT1l
LmV4dGVuZChsLGgsZikpOmYhPT1iJiYoaVtjXT1mKX1yZXR1cm4gaX0sZS5leHRlbmQoe25vQ29u
ZmxpY3Q6ZnVuY3Rpb24oYil7YS4kPT09ZSYmKGEuJD1nKSxiJiZhLmpRdWVyeT09PWUmJihhLmpR
dWVyeT1mKTtyZXR1cm4gZX0saXNSZWFkeTohMSxyZWFkeVdhaXQ6MSxob2xkUmVhZHk6ZnVuY3Rp
b24oYSl7YT9lLnJlYWR5V2FpdCsrOmUucmVhZHkoITApfSxyZWFkeTpmdW5jdGlvbihhKXtpZihh
PT09ITAmJiEtLWUucmVhZHlXYWl0fHxhIT09ITAmJiFlLmlzUmVhZHkpe2lmKCFjLmJvZHkpcmV0
dXJuIHNldFRpbWVvdXQoZS5yZWFkeSwxKTtlLmlzUmVhZHk9ITA7aWYoYSE9PSEwJiYtLWUucmVh
ZHlXYWl0PjApcmV0dXJuO3kucmVzb2x2ZVdpdGgoYyxbZV0pLGUuZm4udHJpZ2dlciYmZShjKS50
cmlnZ2VyKCJyZWFkeSIpLnVuYmluZCgicmVhZHkiKX19LGJpbmRSZWFkeTpmdW5jdGlvbigpe2lm
KCF5KXt5PWUuX0RlZmVycmVkKCk7aWYoYy5yZWFkeVN0YXRlPT09ImNvbXBsZXRlIilyZXR1cm4g
c2V0VGltZW91dChlLnJlYWR5LDEpO2lmKGMuYWRkRXZlbnRMaXN0ZW5lciljLmFkZEV2ZW50TGlz
dGVuZXIoIkRPTUNvbnRlbnRMb2FkZWQiLHosITEpLGEuYWRkRXZlbnRMaXN0ZW5lcigibG9hZCIs
ZS5yZWFkeSwhMSk7ZWxzZSBpZihjLmF0dGFjaEV2ZW50KXtjLmF0dGFjaEV2ZW50KCJvbnJlYWR5
c3RhdGVjaGFuZ2UiLHopLGEuYXR0YWNoRXZlbnQoIm9ubG9hZCIsZS5yZWFkeSk7dmFyIGI9ITE7
dHJ5e2I9YS5mcmFtZUVsZW1lbnQ9PW51bGx9Y2F0Y2goZCl7fWMuZG9jdW1lbnRFbGVtZW50LmRv
U2Nyb2xsJiZiJiZIKCl9fX0saXNGdW5jdGlvbjpmdW5jdGlvbihhKXtyZXR1cm4gZS50eXBlKGEp
PT09ImZ1bmN0aW9uIn0saXNBcnJheTpBcnJheS5pc0FycmF5fHxmdW5jdGlvbihhKXtyZXR1cm4g
ZS50eXBlKGEpPT09ImFycmF5In0saXNXaW5kb3c6ZnVuY3Rpb24oYSl7cmV0dXJuIGEmJnR5cGVv
ZiBhPT0ib2JqZWN0IiYmInNldEludGVydmFsImluIGF9LGlzTmFOOmZ1bmN0aW9uKGEpe3JldHVy
biBhPT1udWxsfHwhbS50ZXN0KGEpfHxpc05hTihhKX0sdHlwZTpmdW5jdGlvbihhKXtyZXR1cm4g
YT09bnVsbD9TdHJpbmcoYSk6R1tBLmNhbGwoYSldfHwib2JqZWN0In0saXNQbGFpbk9iamVjdDpm
dW5jdGlvbihhKXtpZighYXx8ZS50eXBlKGEpIT09Im9iamVjdCJ8fGEubm9kZVR5cGV8fGUuaXNX
aW5kb3coYSkpcmV0dXJuITE7aWYoYS5jb25zdHJ1Y3RvciYmIUIuY2FsbChhLCJjb25zdHJ1Y3Rv
ciIpJiYhQi5jYWxsKGEuY29uc3RydWN0b3IucHJvdG90eXBlLCJpc1Byb3RvdHlwZU9mIikpcmV0
dXJuITE7dmFyIGM7Zm9yKGMgaW4gYSk7cmV0dXJuIGM9PT1ifHxCLmNhbGwoYSxjKX0saXNFbXB0
eU9iamVjdDpmdW5jdGlvbihhKXtmb3IodmFyIGIgaW4gYSlyZXR1cm4hMTtyZXR1cm4hMH0sZXJy
b3I6ZnVuY3Rpb24oYSl7dGhyb3cgYX0scGFyc2VKU09OOmZ1bmN0aW9uKGIpe2lmKHR5cGVvZiBi
IT0ic3RyaW5nInx8IWIpcmV0dXJuIG51bGw7Yj1lLnRyaW0oYik7aWYoYS5KU09OJiZhLkpTT04u
cGFyc2UpcmV0dXJuIGEuSlNPTi5wYXJzZShiKTtpZihvLnRlc3QoYi5yZXBsYWNlKHAsIkAiKS5y
ZXBsYWNlKHEsIl0iKS5yZXBsYWNlKHIsIiIpKSlyZXR1cm4obmV3IEZ1bmN0aW9uKCJyZXR1cm4g
IitiKSkoKTtlLmVycm9yKCJJbnZhbGlkIEpTT046ICIrYil9LHBhcnNlWE1MOmZ1bmN0aW9uKGIs
YyxkKXthLkRPTVBhcnNlcj8oZD1uZXcgRE9NUGFyc2VyLGM9ZC5wYXJzZUZyb21TdHJpbmcoYiwi
dGV4dC94bWwiKSk6KGM9bmV3IEFjdGl2ZVhPYmplY3QoIk1pY3Jvc29mdC5YTUxET00iKSxjLmFz
eW5jPSJmYWxzZSIsYy5sb2FkWE1MKGIpKSxkPWMuZG9jdW1lbnRFbGVtZW50LCghZHx8IWQubm9k
ZU5hbWV8fGQubm9kZU5hbWU9PT0icGFyc2VyZXJyb3IiKSYmZS5lcnJvcigiSW52YWxpZCBYTUw6
ICIrYik7cmV0dXJuIGN9LG5vb3A6ZnVuY3Rpb24oKXt9LGdsb2JhbEV2YWw6ZnVuY3Rpb24oYil7
YiYmai50ZXN0KGIpJiYoYS5leGVjU2NyaXB0fHxmdW5jdGlvbihiKXthLmV2YWwuY2FsbChhLGIp
fSkoYil9LG5vZGVOYW1lOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGEubm9kZU5hbWUmJmEubm9kZU5h
bWUudG9VcHBlckNhc2UoKT09PWIudG9VcHBlckNhc2UoKX0sZWFjaDpmdW5jdGlvbihhLGMsZCl7
dmFyIGYsZz0wLGg9YS5sZW5ndGgsaT1oPT09Ynx8ZS5pc0Z1bmN0aW9uKGEpO2lmKGQpe2lmKGkp
e2ZvcihmIGluIGEpaWYoYy5hcHBseShhW2ZdLGQpPT09ITEpYnJlYWt9ZWxzZSBmb3IoO2c8aDsp
aWYoYy5hcHBseShhW2crK10sZCk9PT0hMSlicmVha31lbHNlIGlmKGkpe2ZvcihmIGluIGEpaWYo
Yy5jYWxsKGFbZl0sZixhW2ZdKT09PSExKWJyZWFrfWVsc2UgZm9yKDtnPGg7KWlmKGMuY2FsbChh
W2ddLGcsYVtnKytdKT09PSExKWJyZWFrO3JldHVybiBhfSx0cmltOkU/ZnVuY3Rpb24oYSl7cmV0
dXJuIGE9PW51bGw/IiI6RS5jYWxsKGEpfTpmdW5jdGlvbihhKXtyZXR1cm4gYT09bnVsbD8iIjoo
YSsiIikucmVwbGFjZShrLCIiKS5yZXBsYWNlKGwsIiIpfSxtYWtlQXJyYXk6ZnVuY3Rpb24oYSxi
KXt2YXIgYz1ifHxbXTtpZihhIT1udWxsKXt2YXIgZD1lLnR5cGUoYSk7YS5sZW5ndGg9PW51bGx8
fGQ9PT0ic3RyaW5nInx8ZD09PSJmdW5jdGlvbiJ8fGQ9PT0icmVnZXhwInx8ZS5pc1dpbmRvdyhh
KT9DLmNhbGwoYyxhKTplLm1lcmdlKGMsYSl9cmV0dXJuIGN9LGluQXJyYXk6ZnVuY3Rpb24oYSxi
KXtpZihGKXJldHVybiBGLmNhbGwoYixhKTtmb3IodmFyIGM9MCxkPWIubGVuZ3RoO2M8ZDtjKysp
aWYoYltjXT09PWEpcmV0dXJuIGM7cmV0dXJuLTF9LG1lcmdlOmZ1bmN0aW9uKGEsYyl7dmFyIGQ9
YS5sZW5ndGgsZT0wO2lmKHR5cGVvZiBjLmxlbmd0aD09Im51bWJlciIpZm9yKHZhciBmPWMubGVu
Z3RoO2U8ZjtlKyspYVtkKytdPWNbZV07ZWxzZSB3aGlsZShjW2VdIT09YilhW2QrK109Y1tlKytd
O2EubGVuZ3RoPWQ7cmV0dXJuIGF9LGdyZXA6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPVtdLGU7Yz0h
IWM7Zm9yKHZhciBmPTAsZz1hLmxlbmd0aDtmPGc7ZisrKWU9ISFiKGFbZl0sZiksYyE9PWUmJmQu
cHVzaChhW2ZdKTtyZXR1cm4gZH0sbWFwOmZ1bmN0aW9uKGEsYyxkKXt2YXIgZixnLGg9W10saT0w
LGo9YS5sZW5ndGgsaz1hIGluc3RhbmNlb2YgZXx8aiE9PWImJnR5cGVvZiBqPT0ibnVtYmVyIiYm
KGo+MCYmYVswXSYmYVtqLTFdfHxqPT09MHx8ZS5pc0FycmF5KGEpKTtpZihrKWZvcig7aTxqO2kr
KylmPWMoYVtpXSxpLGQpLGYhPW51bGwmJihoW2gubGVuZ3RoXT1mKTtlbHNlIGZvcihnIGluIGEp
Zj1jKGFbZ10sZyxkKSxmIT1udWxsJiYoaFtoLmxlbmd0aF09Zik7cmV0dXJuIGguY29uY2F0LmFw
cGx5KFtdLGgpfSxndWlkOjEscHJveHk6ZnVuY3Rpb24oYSxjKXtpZih0eXBlb2YgYz09InN0cmlu
ZyIpe3ZhciBkPWFbY107Yz1hLGE9ZH1pZighZS5pc0Z1bmN0aW9uKGEpKXJldHVybiBiO3ZhciBm
PUQuY2FsbChhcmd1bWVudHMsMiksZz1mdW5jdGlvbigpe3JldHVybiBhLmFwcGx5KGMsZi5jb25j
YXQoRC5jYWxsKGFyZ3VtZW50cykpKX07Zy5ndWlkPWEuZ3VpZD1hLmd1aWR8fGcuZ3VpZHx8ZS5n
dWlkKys7cmV0dXJuIGd9LGFjY2VzczpmdW5jdGlvbihhLGMsZCxmLGcsaCl7dmFyIGk9YS5sZW5n
dGg7aWYodHlwZW9mIGM9PSJvYmplY3QiKXtmb3IodmFyIGogaW4gYyllLmFjY2VzcyhhLGosY1tq
XSxmLGcsZCk7cmV0dXJuIGF9aWYoZCE9PWIpe2Y9IWgmJmYmJmUuaXNGdW5jdGlvbihkKTtmb3Io
dmFyIGs9MDtrPGk7aysrKWcoYVtrXSxjLGY/ZC5jYWxsKGFba10sayxnKGFba10sYykpOmQsaCk7
cmV0dXJuIGF9cmV0dXJuIGk/ZyhhWzBdLGMpOmJ9LG5vdzpmdW5jdGlvbigpe3JldHVybihuZXcg
RGF0ZSkuZ2V0VGltZSgpfSx1YU1hdGNoOmZ1bmN0aW9uKGEpe2E9YS50b0xvd2VyQ2FzZSgpO3Zh
ciBiPXMuZXhlYyhhKXx8dC5leGVjKGEpfHx1LmV4ZWMoYSl8fGEuaW5kZXhPZigiY29tcGF0aWJs
ZSIpPDAmJnYuZXhlYyhhKXx8W107cmV0dXJue2Jyb3dzZXI6YlsxXXx8IiIsdmVyc2lvbjpiWzJd
fHwiMCJ9fSxzdWI6ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGIsYyl7cmV0dXJuIG5ldyBhLmZuLmlu
aXQoYixjKX1lLmV4dGVuZCghMCxhLHRoaXMpLGEuc3VwZXJjbGFzcz10aGlzLGEuZm49YS5wcm90
b3R5cGU9dGhpcygpLGEuZm4uY29uc3RydWN0b3I9YSxhLnN1Yj10aGlzLnN1YixhLmZuLmluaXQ9
ZnVuY3Rpb24oZCxmKXtmJiZmIGluc3RhbmNlb2YgZSYmIShmIGluc3RhbmNlb2YgYSkmJihmPWEo
ZikpO3JldHVybiBlLmZuLmluaXQuY2FsbCh0aGlzLGQsZixiKX0sYS5mbi5pbml0LnByb3RvdHlw
ZT1hLmZuO3ZhciBiPWEoYyk7cmV0dXJuIGF9LGJyb3dzZXI6e319KSxlLmVhY2goIkJvb2xlYW4g
TnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QiLnNwbGl0KCIg
IiksZnVuY3Rpb24oYSxiKXtHWyJbb2JqZWN0ICIrYisiXSJdPWIudG9Mb3dlckNhc2UoKX0pLHg9
ZS51YU1hdGNoKHcpLHguYnJvd3NlciYmKGUuYnJvd3Nlclt4LmJyb3dzZXJdPSEwLGUuYnJvd3Nl
ci52ZXJzaW9uPXgudmVyc2lvbiksZS5icm93c2VyLndlYmtpdCYmKGUuYnJvd3Nlci5zYWZhcmk9
ITApLGoudGVzdCgioCIpJiYoaz0vXltcc1x4QTBdKy8sbD0vW1xzXHhBMF0rJC8pLGg9ZShjKSxj
LmFkZEV2ZW50TGlzdGVuZXI/ej1mdW5jdGlvbigpe2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigiRE9N
Q29udGVudExvYWRlZCIseiwhMSksZS5yZWFkeSgpfTpjLmF0dGFjaEV2ZW50JiYoej1mdW5jdGlv
bigpe2MucmVhZHlTdGF0ZT09PSJjb21wbGV0ZSImJihjLmRldGFjaEV2ZW50KCJvbnJlYWR5c3Rh
dGVjaGFuZ2UiLHopLGUucmVhZHkoKSl9KTtyZXR1cm4gZX0oKSxnPSJkb25lIGZhaWwgaXNSZXNv
bHZlZCBpc1JlamVjdGVkIHByb21pc2UgdGhlbiBhbHdheXMgcGlwZSIuc3BsaXQoIiAiKSxoPVtd
LnNsaWNlO2YuZXh0ZW5kKHtfRGVmZXJyZWQ6ZnVuY3Rpb24oKXt2YXIgYT1bXSxiLGMsZCxlPXtk
b25lOmZ1bmN0aW9uKCl7aWYoIWQpe3ZhciBjPWFyZ3VtZW50cyxnLGgsaSxqLGs7YiYmKGs9Yixi
PTApO2ZvcihnPTAsaD1jLmxlbmd0aDtnPGg7ZysrKWk9Y1tnXSxqPWYudHlwZShpKSxqPT09ImFy
cmF5Ij9lLmRvbmUuYXBwbHkoZSxpKTpqPT09ImZ1bmN0aW9uIiYmYS5wdXNoKGkpO2smJmUucmVz
b2x2ZVdpdGgoa1swXSxrWzFdKX1yZXR1cm4gdGhpc30scmVzb2x2ZVdpdGg6ZnVuY3Rpb24oZSxm
KXtpZighZCYmIWImJiFjKXtmPWZ8fFtdLGM9MTt0cnl7d2hpbGUoYVswXSlhLnNoaWZ0KCkuYXBw
bHkoZSxmKX1maW5hbGx5e2I9W2UsZl0sYz0wfX1yZXR1cm4gdGhpc30scmVzb2x2ZTpmdW5jdGlv
bigpe2UucmVzb2x2ZVdpdGgodGhpcyxhcmd1bWVudHMpO3JldHVybiB0aGlzfSxpc1Jlc29sdmVk
OmZ1bmN0aW9uKCl7cmV0dXJuISFjfHwhIWJ9LGNhbmNlbDpmdW5jdGlvbigpe2Q9MSxhPVtdO3Jl
dHVybiB0aGlzfX07cmV0dXJuIGV9LERlZmVycmVkOmZ1bmN0aW9uKGEpe3ZhciBiPWYuX0RlZmVy
cmVkKCksYz1mLl9EZWZlcnJlZCgpLGQ7Zi5leHRlbmQoYix7dGhlbjpmdW5jdGlvbihhLGMpe2Iu
ZG9uZShhKS5mYWlsKGMpO3JldHVybiB0aGlzfSxhbHdheXM6ZnVuY3Rpb24oKXtyZXR1cm4gYi5k
b25lLmFwcGx5KGIsYXJndW1lbnRzKS5mYWlsLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sZmFpbDpj
LmRvbmUscmVqZWN0V2l0aDpjLnJlc29sdmVXaXRoLHJlamVjdDpjLnJlc29sdmUsaXNSZWplY3Rl
ZDpjLmlzUmVzb2x2ZWQscGlwZTpmdW5jdGlvbihhLGMpe3JldHVybiBmLkRlZmVycmVkKGZ1bmN0
aW9uKGQpe2YuZWFjaCh7ZG9uZTpbYSwicmVzb2x2ZSJdLGZhaWw6W2MsInJlamVjdCJdfSxmdW5j
dGlvbihhLGMpe3ZhciBlPWNbMF0sZz1jWzFdLGg7Zi5pc0Z1bmN0aW9uKGUpP2JbYV0oZnVuY3Rp
b24oKXtoPWUuYXBwbHkodGhpcyxhcmd1bWVudHMpLGgmJmYuaXNGdW5jdGlvbihoLnByb21pc2Up
P2gucHJvbWlzZSgpLnRoZW4oZC5yZXNvbHZlLGQucmVqZWN0KTpkW2ddKGgpfSk6YlthXShkW2dd
KX0pfSkucHJvbWlzZSgpfSxwcm9taXNlOmZ1bmN0aW9uKGEpe2lmKGE9PW51bGwpe2lmKGQpcmV0
dXJuIGQ7ZD1hPXt9fXZhciBjPWcubGVuZ3RoO3doaWxlKGMtLSlhW2dbY11dPWJbZ1tjXV07cmV0
dXJuIGF9fSksYi5kb25lKGMuY2FuY2VsKS5mYWlsKGIuY2FuY2VsKSxkZWxldGUgYi5jYW5jZWws
YSYmYS5jYWxsKGIsYik7cmV0dXJuIGJ9LHdoZW46ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gaShhKXty
ZXR1cm4gZnVuY3Rpb24oYyl7YlthXT1hcmd1bWVudHMubGVuZ3RoPjE/aC5jYWxsKGFyZ3VtZW50
cywwKTpjLC0tZXx8Zy5yZXNvbHZlV2l0aChnLGguY2FsbChiLDApKX19dmFyIGI9YXJndW1lbnRz
LGM9MCxkPWIubGVuZ3RoLGU9ZCxnPWQ8PTEmJmEmJmYuaXNGdW5jdGlvbihhLnByb21pc2UpP2E6
Zi5EZWZlcnJlZCgpO2lmKGQ+MSl7Zm9yKDtjPGQ7YysrKWJbY10mJmYuaXNGdW5jdGlvbihiW2Nd
LnByb21pc2UpP2JbY10ucHJvbWlzZSgpLnRoZW4oaShjKSxnLnJlamVjdCk6LS1lO2V8fGcucmVz
b2x2ZVdpdGgoZyxiKX1lbHNlIGchPT1hJiZnLnJlc29sdmVXaXRoKGcsZD9bYV06W10pO3JldHVy
biBnLnByb21pc2UoKX19KSxmLnN1cHBvcnQ9ZnVuY3Rpb24oKXt2YXIgYT1jLmNyZWF0ZUVsZW1l
bnQoImRpdiIpLGI9Yy5kb2N1bWVudEVsZW1lbnQsZCxlLGYsZyxoLGksaixrLGwsbSxuLG8scCxx
LHI7YS5zZXRBdHRyaWJ1dGUoImNsYXNzTmFtZSIsInQiKSxhLmlubmVySFRNTD0iICAgPGxpbmsv
Pjx0YWJsZT48L3RhYmxlPjxhIGhyZWY9Jy9hJyBzdHlsZT0ndG9wOjFweDtmbG9hdDpsZWZ0O29w
YWNpdHk6LjU1Oyc+YTwvYT48aW5wdXQgdHlwZT0nY2hlY2tib3gnLz4iLGQ9YS5nZXRFbGVtZW50
c0J5VGFnTmFtZSgiKiIpLGU9YS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiYSIpWzBdO2lmKCFkfHwh
ZC5sZW5ndGh8fCFlKXJldHVybnt9O2Y9Yy5jcmVhdGVFbGVtZW50KCJzZWxlY3QiKSxnPWYuYXBw
ZW5kQ2hpbGQoYy5jcmVhdGVFbGVtZW50KCJvcHRpb24iKSksaD1hLmdldEVsZW1lbnRzQnlUYWdO
YW1lKCJpbnB1dCIpWzBdLGo9e2xlYWRpbmdXaGl0ZXNwYWNlOmEuZmlyc3RDaGlsZC5ub2RlVHlw
ZT09PTMsdGJvZHk6IWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoInRib2R5IikubGVuZ3RoLGh0bWxT
ZXJpYWxpemU6ISFhLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJsaW5rIikubGVuZ3RoLHN0eWxlOi90
b3AvLnRlc3QoZS5nZXRBdHRyaWJ1dGUoInN0eWxlIikpLGhyZWZOb3JtYWxpemVkOmUuZ2V0QXR0
cmlidXRlKCJocmVmIik9PT0iL2EiLG9wYWNpdHk6L14wLjU1JC8udGVzdChlLnN0eWxlLm9wYWNp
dHkpLGNzc0Zsb2F0OiEhZS5zdHlsZS5jc3NGbG9hdCxjaGVja09uOmgudmFsdWU9PT0ib24iLG9w
dFNlbGVjdGVkOmcuc2VsZWN0ZWQsZ2V0U2V0QXR0cmlidXRlOmEuY2xhc3NOYW1lIT09InQiLHN1
Ym1pdEJ1YmJsZXM6ITAsY2hhbmdlQnViYmxlczohMCxmb2N1c2luQnViYmxlczohMSxkZWxldGVF
eHBhbmRvOiEwLG5vQ2xvbmVFdmVudDohMCxpbmxpbmVCbG9ja05lZWRzTGF5b3V0OiExLHNocmlu
a1dyYXBCbG9ja3M6ITEscmVsaWFibGVNYXJnaW5SaWdodDohMH0saC5jaGVja2VkPSEwLGoubm9D
bG9uZUNoZWNrZWQ9aC5jbG9uZU5vZGUoITApLmNoZWNrZWQsZi5kaXNhYmxlZD0hMCxqLm9wdERp
c2FibGVkPSFnLmRpc2FibGVkO3RyeXtkZWxldGUgYS50ZXN0fWNhdGNoKHMpe2ouZGVsZXRlRXhw
YW5kbz0hMX0hYS5hZGRFdmVudExpc3RlbmVyJiZhLmF0dGFjaEV2ZW50JiZhLmZpcmVFdmVudCYm
KGEuYXR0YWNoRXZlbnQoIm9uY2xpY2siLGZ1bmN0aW9uIGIoKXtqLm5vQ2xvbmVFdmVudD0hMSxh
LmRldGFjaEV2ZW50KCJvbmNsaWNrIixiKX0pLGEuY2xvbmVOb2RlKCEwKS5maXJlRXZlbnQoIm9u
Y2xpY2siKSksaD1jLmNyZWF0ZUVsZW1lbnQoImlucHV0IiksaC52YWx1ZT0idCIsaC5zZXRBdHRy
aWJ1dGUoInR5cGUiLCJyYWRpbyIpLGoucmFkaW9WYWx1ZT1oLnZhbHVlPT09InQiLGguc2V0QXR0
cmlidXRlKCJjaGVja2VkIiwiY2hlY2tlZCIpLGEuYXBwZW5kQ2hpbGQoaCksaz1jLmNyZWF0ZURv
Y3VtZW50RnJhZ21lbnQoKSxrLmFwcGVuZENoaWxkKGEuZmlyc3RDaGlsZCksai5jaGVja0Nsb25l
PWsuY2xvbmVOb2RlKCEwKS5jbG9uZU5vZGUoITApLmxhc3RDaGlsZC5jaGVja2VkLGEuaW5uZXJI
VE1MPSIiLGEuc3R5bGUud2lkdGg9YS5zdHlsZS5wYWRkaW5nTGVmdD0iMXB4IixsPWMuY3JlYXRl
RWxlbWVudCgiYm9keSIpLG09e3Zpc2liaWxpdHk6ImhpZGRlbiIsd2lkdGg6MCxoZWlnaHQ6MCxi
b3JkZXI6MCxtYXJnaW46MCxiYWNrZ3JvdW5kOiJub25lIn07Zm9yKHEgaW4gbSlsLnN0eWxlW3Fd
PW1bcV07bC5hcHBlbmRDaGlsZChhKSxiLmluc2VydEJlZm9yZShsLGIuZmlyc3RDaGlsZCksai5h
cHBlbmRDaGVja2VkPWguY2hlY2tlZCxqLmJveE1vZGVsPWEub2Zmc2V0V2lkdGg9PT0yLCJ6b29t
ImluIGEuc3R5bGUmJihhLnN0eWxlLmRpc3BsYXk9ImlubGluZSIsYS5zdHlsZS56b29tPTEsai5p
bmxpbmVCbG9ja05lZWRzTGF5b3V0PWEub2Zmc2V0V2lkdGg9PT0yLGEuc3R5bGUuZGlzcGxheT0i
IixhLmlubmVySFRNTD0iPGRpdiBzdHlsZT0nd2lkdGg6NHB4Oyc+PC9kaXY+IixqLnNocmlua1dy
YXBCbG9ja3M9YS5vZmZzZXRXaWR0aCE9PTIpLGEuaW5uZXJIVE1MPSI8dGFibGU+PHRyPjx0ZCBz
dHlsZT0ncGFkZGluZzowO2JvcmRlcjowO2Rpc3BsYXk6bm9uZSc+PC90ZD48dGQ+dDwvdGQ+PC90
cj48L3RhYmxlPiIsbj1hLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJ0ZCIpLHI9blswXS5vZmZzZXRI
ZWlnaHQ9PT0wLG5bMF0uc3R5bGUuZGlzcGxheT0iIixuWzFdLnN0eWxlLmRpc3BsYXk9Im5vbmUi
LGoucmVsaWFibGVIaWRkZW5PZmZzZXRzPXImJm5bMF0ub2Zmc2V0SGVpZ2h0PT09MCxhLmlubmVy
SFRNTD0iIixjLmRlZmF1bHRWaWV3JiZjLmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUmJihp
PWMuY3JlYXRlRWxlbWVudCgiZGl2IiksaS5zdHlsZS53aWR0aD0iMCIsaS5zdHlsZS5tYXJnaW5S
aWdodD0iMCIsYS5hcHBlbmRDaGlsZChpKSxqLnJlbGlhYmxlTWFyZ2luUmlnaHQ9KHBhcnNlSW50
KChjLmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoaSxudWxsKXx8e21hcmdpblJpZ2h0OjB9
KS5tYXJnaW5SaWdodCwxMCl8fDApPT09MCksbC5pbm5lckhUTUw9IiIsYi5yZW1vdmVDaGlsZChs
KTtpZihhLmF0dGFjaEV2ZW50KWZvcihxIGlue3N1Ym1pdDoxLGNoYW5nZToxLGZvY3VzaW46MX0p
cD0ib24iK3Escj1wIGluIGEscnx8KGEuc2V0QXR0cmlidXRlKHAsInJldHVybjsiKSxyPXR5cGVv
ZiBhW3BdPT0iZnVuY3Rpb24iKSxqW3ErIkJ1YmJsZXMiXT1yO3JldHVybiBqfSgpLGYuYm94TW9k
ZWw9Zi5zdXBwb3J0LmJveE1vZGVsO3ZhciBpPS9eKD86XHsuKlx9fFxbLipcXSkkLyxqPS8oW2Et
el0pKFtBLVpdKS9nO2YuZXh0ZW5kKHtjYWNoZTp7fSx1dWlkOjAsZXhwYW5kbzoialF1ZXJ5Iiso
Zi5mbi5qcXVlcnkrTWF0aC5yYW5kb20oKSkucmVwbGFjZSgvXEQvZywiIiksbm9EYXRhOntlbWJl
ZDohMCxvYmplY3Q6ImNsc2lkOkQyN0NEQjZFLUFFNkQtMTFjZi05NkI4LTQ0NDU1MzU0MDAwMCIs
YXBwbGV0OiEwfSxoYXNEYXRhOmZ1bmN0aW9uKGEpe2E9YS5ub2RlVHlwZT9mLmNhY2hlW2FbZi5l
eHBhbmRvXV06YVtmLmV4cGFuZG9dO3JldHVybiEhYSYmIWwoYSl9LGRhdGE6ZnVuY3Rpb24oYSxj
LGQsZSl7aWYoISFmLmFjY2VwdERhdGEoYSkpe3ZhciBnPWYuZXhwYW5kbyxoPXR5cGVvZiBjPT0i
c3RyaW5nIixpLGo9YS5ub2RlVHlwZSxrPWo/Zi5jYWNoZTphLGw9aj9hW2YuZXhwYW5kb106YVtm
LmV4cGFuZG9dJiZmLmV4cGFuZG87aWYoKCFsfHxlJiZsJiYha1tsXVtnXSkmJmgmJmQ9PT1iKXJl
dHVybjtsfHwoaj9hW2YuZXhwYW5kb109bD0rK2YudXVpZDpsPWYuZXhwYW5kbyksa1tsXXx8KGtb
bF09e30sanx8KGtbbF0udG9KU09OPWYubm9vcCkpO2lmKHR5cGVvZiBjPT0ib2JqZWN0Inx8dHlw
ZW9mIGM9PSJmdW5jdGlvbiIpZT9rW2xdW2ddPWYuZXh0ZW5kKGtbbF1bZ10sYyk6a1tsXT1mLmV4
dGVuZChrW2xdLGMpO2k9a1tsXSxlJiYoaVtnXXx8KGlbZ109e30pLGk9aVtnXSksZCE9PWImJihp
W2YuY2FtZWxDYXNlKGMpXT1kKTtpZihjPT09ImV2ZW50cyImJiFpW2NdKXJldHVybiBpW2ddJiZp
W2ddLmV2ZW50cztyZXR1cm4gaD9pW2YuY2FtZWxDYXNlKGMpXTppfX0scmVtb3ZlRGF0YTpmdW5j
dGlvbihiLGMsZCl7aWYoISFmLmFjY2VwdERhdGEoYikpe3ZhciBlPWYuZXhwYW5kbyxnPWIubm9k
ZVR5cGUsaD1nP2YuY2FjaGU6YixpPWc/YltmLmV4cGFuZG9dOmYuZXhwYW5kbztpZighaFtpXSly
ZXR1cm47aWYoYyl7dmFyIGo9ZD9oW2ldW2VdOmhbaV07aWYoail7ZGVsZXRlIGpbY107aWYoIWwo
aikpcmV0dXJufX1pZihkKXtkZWxldGUgaFtpXVtlXTtpZighbChoW2ldKSlyZXR1cm59dmFyIGs9
aFtpXVtlXTtmLnN1cHBvcnQuZGVsZXRlRXhwYW5kb3x8aCE9YT9kZWxldGUgaFtpXTpoW2ldPW51
bGwsaz8oaFtpXT17fSxnfHwoaFtpXS50b0pTT049Zi5ub29wKSxoW2ldW2VdPWspOmcmJihmLnN1
cHBvcnQuZGVsZXRlRXhwYW5kbz9kZWxldGUgYltmLmV4cGFuZG9dOmIucmVtb3ZlQXR0cmlidXRl
P2IucmVtb3ZlQXR0cmlidXRlKGYuZXhwYW5kbyk6YltmLmV4cGFuZG9dPW51bGwpfX0sX2RhdGE6
ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBmLmRhdGEoYSxiLGMsITApfSxhY2NlcHREYXRhOmZ1bmN0
aW9uKGEpe2lmKGEubm9kZU5hbWUpe3ZhciBiPWYubm9EYXRhW2Eubm9kZU5hbWUudG9Mb3dlckNh
c2UoKV07aWYoYilyZXR1cm4gYiE9PSEwJiZhLmdldEF0dHJpYnV0ZSgiY2xhc3NpZCIpPT09Yn1y
ZXR1cm4hMH19KSxmLmZuLmV4dGVuZCh7ZGF0YTpmdW5jdGlvbihhLGMpe3ZhciBkPW51bGw7aWYo
dHlwZW9mIGE9PSJ1bmRlZmluZWQiKXtpZih0aGlzLmxlbmd0aCl7ZD1mLmRhdGEodGhpc1swXSk7
aWYodGhpc1swXS5ub2RlVHlwZT09PTEpe3ZhciBlPXRoaXNbMF0uYXR0cmlidXRlcyxnO2Zvcih2
YXIgaD0wLGk9ZS5sZW5ndGg7aDxpO2grKylnPWVbaF0ubmFtZSxnLmluZGV4T2YoImRhdGEtIik9
PT0wJiYoZz1mLmNhbWVsQ2FzZShnLnN1YnN0cmluZyg1KSksayh0aGlzWzBdLGcsZFtnXSkpfX1y
ZXR1cm4gZH1pZih0eXBlb2YgYT09Im9iamVjdCIpcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigp
e2YuZGF0YSh0aGlzLGEpfSk7dmFyIGo9YS5zcGxpdCgiLiIpO2pbMV09alsxXT8iLiIralsxXToi
IjtpZihjPT09Yil7ZD10aGlzLnRyaWdnZXJIYW5kbGVyKCJnZXREYXRhIitqWzFdKyIhIixbalsw
XV0pLGQ9PT1iJiZ0aGlzLmxlbmd0aCYmKGQ9Zi5kYXRhKHRoaXNbMF0sYSksZD1rKHRoaXNbMF0s
YSxkKSk7cmV0dXJuIGQ9PT1iJiZqWzFdP3RoaXMuZGF0YShqWzBdKTpkfXJldHVybiB0aGlzLmVh
Y2goZnVuY3Rpb24oKXt2YXIgYj1mKHRoaXMpLGQ9W2pbMF0sY107Yi50cmlnZ2VySGFuZGxlcigi
c2V0RGF0YSIralsxXSsiISIsZCksZi5kYXRhKHRoaXMsYSxjKSxiLnRyaWdnZXJIYW5kbGVyKCJj
aGFuZ2VEYXRhIitqWzFdKyIhIixkKX0pfSxyZW1vdmVEYXRhOmZ1bmN0aW9uKGEpe3JldHVybiB0
aGlzLmVhY2goZnVuY3Rpb24oKXtmLnJlbW92ZURhdGEodGhpcyxhKX0pfX0pLGYuZXh0ZW5kKHtf
bWFyazpmdW5jdGlvbihhLGMpe2EmJihjPShjfHwiZngiKSsibWFyayIsZi5kYXRhKGEsYywoZi5k
YXRhKGEsYyxiLCEwKXx8MCkrMSwhMCkpfSxfdW5tYXJrOmZ1bmN0aW9uKGEsYyxkKXthIT09ITAm
JihkPWMsYz1hLGE9ITEpO2lmKGMpe2Q9ZHx8ImZ4Ijt2YXIgZT1kKyJtYXJrIixnPWE/MDooZi5k
YXRhKGMsZSxiLCEwKXx8MSktMTtnP2YuZGF0YShjLGUsZywhMCk6KGYucmVtb3ZlRGF0YShjLGUs
ITApLG0oYyxkLCJtYXJrIikpfX0scXVldWU6ZnVuY3Rpb24oYSxjLGQpe2lmKGEpe2M9KGN8fCJm
eCIpKyJxdWV1ZSI7dmFyIGU9Zi5kYXRhKGEsYyxiLCEwKTtkJiYoIWV8fGYuaXNBcnJheShkKT9l
PWYuZGF0YShhLGMsZi5tYWtlQXJyYXkoZCksITApOmUucHVzaChkKSk7cmV0dXJuIGV8fFtdfX0s
ZGVxdWV1ZTpmdW5jdGlvbihhLGIpe2I9Ynx8ImZ4Ijt2YXIgYz1mLnF1ZXVlKGEsYiksZD1jLnNo
aWZ0KCksZTtkPT09ImlucHJvZ3Jlc3MiJiYoZD1jLnNoaWZ0KCkpLGQmJihiPT09ImZ4IiYmYy51
bnNoaWZ0KCJpbnByb2dyZXNzIiksZC5jYWxsKGEsZnVuY3Rpb24oKXtmLmRlcXVldWUoYSxiKX0p
KSxjLmxlbmd0aHx8KGYucmVtb3ZlRGF0YShhLGIrInF1ZXVlIiwhMCksbShhLGIsInF1ZXVlIikp
fX0pLGYuZm4uZXh0ZW5kKHtxdWV1ZTpmdW5jdGlvbihhLGMpe3R5cGVvZiBhIT0ic3RyaW5nIiYm
KGM9YSxhPSJmeCIpO2lmKGM9PT1iKXJldHVybiBmLnF1ZXVlKHRoaXNbMF0sYSk7cmV0dXJuIHRo
aXMuZWFjaChmdW5jdGlvbigpe3ZhciBiPWYucXVldWUodGhpcyxhLGMpO2E9PT0iZngiJiZiWzBd
IT09ImlucHJvZ3Jlc3MiJiZmLmRlcXVldWUodGhpcyxhKX0pfSxkZXF1ZXVlOmZ1bmN0aW9uKGEp
e3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtmLmRlcXVldWUodGhpcyxhKX0pfSxkZWxheTpm
dW5jdGlvbihhLGIpe2E9Zi5meD9mLmZ4LnNwZWVkc1thXXx8YTphLGI9Ynx8ImZ4IjtyZXR1cm4g
dGhpcy5xdWV1ZShiLGZ1bmN0aW9uKCl7dmFyIGM9dGhpcztzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7
Zi5kZXF1ZXVlKGMsYil9LGEpfSl9LGNsZWFyUXVldWU6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMu
cXVldWUoYXx8ImZ4IixbXSl9LHByb21pc2U6ZnVuY3Rpb24oYSxjKXtmdW5jdGlvbiBtKCl7LS1o
fHxkLnJlc29sdmVXaXRoKGUsW2VdKX10eXBlb2YgYSE9InN0cmluZyImJihjPWEsYT1iKSxhPWF8
fCJmeCI7dmFyIGQ9Zi5EZWZlcnJlZCgpLGU9dGhpcyxnPWUubGVuZ3RoLGg9MSxpPWErImRlZmVy
IixqPWErInF1ZXVlIixrPWErIm1hcmsiLGw7d2hpbGUoZy0tKWlmKGw9Zi5kYXRhKGVbZ10saSxi
LCEwKXx8KGYuZGF0YShlW2ddLGosYiwhMCl8fGYuZGF0YShlW2ddLGssYiwhMCkpJiZmLmRhdGEo
ZVtnXSxpLGYuX0RlZmVycmVkKCksITApKWgrKyxsLmRvbmUobSk7bSgpO3JldHVybiBkLnByb21p
c2UoKX19KTt2YXIgbj0vW1xuXHRccl0vZyxvPS9ccysvLHA9L1xyL2cscT0vXig/OmJ1dHRvbnxp
bnB1dCkkL2kscj0vXig/OmJ1dHRvbnxpbnB1dHxvYmplY3R8c2VsZWN0fHRleHRhcmVhKSQvaSxz
PS9eYSg/OnJlYSk/JC9pLHQ9L14oPzphdXRvZm9jdXN8YXV0b3BsYXl8YXN5bmN8Y2hlY2tlZHxj
b250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5
fHJlcXVpcmVkfHNjb3BlZHxzZWxlY3RlZCkkL2ksdT0vXDovLHYsdztmLmZuLmV4dGVuZCh7YXR0
cjpmdW5jdGlvbihhLGIpe3JldHVybiBmLmFjY2Vzcyh0aGlzLGEsYiwhMCxmLmF0dHIpfSxyZW1v
dmVBdHRyOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtmLnJlbW92ZUF0
dHIodGhpcyxhKX0pfSxwcm9wOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGYuYWNjZXNzKHRoaXMsYSxi
LCEwLGYucHJvcCl9LHJlbW92ZVByb3A6ZnVuY3Rpb24oYSl7YT1mLnByb3BGaXhbYV18fGE7cmV0
dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3RyeXt0aGlzW2FdPWIsZGVsZXRlIHRoaXNbYV19Y2F0
Y2goYyl7fX0pfSxhZGRDbGFzczpmdW5jdGlvbihhKXtpZihmLmlzRnVuY3Rpb24oYSkpcmV0dXJu
IHRoaXMuZWFjaChmdW5jdGlvbihiKXt2YXIgYz1mKHRoaXMpO2MuYWRkQ2xhc3MoYS5jYWxsKHRo
aXMsYixjLmF0dHIoImNsYXNzIil8fCIiKSl9KTtpZihhJiZ0eXBlb2YgYT09InN0cmluZyIpe3Zh
ciBiPShhfHwiIikuc3BsaXQobyk7Zm9yKHZhciBjPTAsZD10aGlzLmxlbmd0aDtjPGQ7YysrKXt2
YXIgZT10aGlzW2NdO2lmKGUubm9kZVR5cGU9PT0xKWlmKCFlLmNsYXNzTmFtZSllLmNsYXNzTmFt
ZT1hO2Vsc2V7dmFyIGc9IiAiK2UuY2xhc3NOYW1lKyIgIixoPWUuY2xhc3NOYW1lO2Zvcih2YXIg
aT0wLGo9Yi5sZW5ndGg7aTxqO2krKylnLmluZGV4T2YoIiAiK2JbaV0rIiAiKTwwJiYoaCs9IiAi
K2JbaV0pO2UuY2xhc3NOYW1lPWYudHJpbShoKX19fXJldHVybiB0aGlzfSxyZW1vdmVDbGFzczpm
dW5jdGlvbihhKXtpZihmLmlzRnVuY3Rpb24oYSkpcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihi
KXt2YXIgYz1mKHRoaXMpO2MucmVtb3ZlQ2xhc3MoYS5jYWxsKHRoaXMsYixjLmF0dHIoImNsYXNz
IikpKX0pO2lmKGEmJnR5cGVvZiBhPT0ic3RyaW5nInx8YT09PWIpe3ZhciBjPShhfHwiIikuc3Bs
aXQobyk7Zm9yKHZhciBkPTAsZT10aGlzLmxlbmd0aDtkPGU7ZCsrKXt2YXIgZz10aGlzW2RdO2lm
KGcubm9kZVR5cGU9PT0xJiZnLmNsYXNzTmFtZSlpZihhKXt2YXIgaD0oIiAiK2cuY2xhc3NOYW1l
KyIgIikucmVwbGFjZShuLCIgIik7Zm9yKHZhciBpPTAsaj1jLmxlbmd0aDtpPGo7aSsrKWg9aC5y
ZXBsYWNlKCIgIitjW2ldKyIgIiwiICIpO2cuY2xhc3NOYW1lPWYudHJpbShoKX1lbHNlIGcuY2xh
c3NOYW1lPSIifX1yZXR1cm4gdGhpc30sdG9nZ2xlQ2xhc3M6ZnVuY3Rpb24oYSxiKXt2YXIgYz10
eXBlb2YgYSxkPXR5cGVvZiBiPT0iYm9vbGVhbiI7aWYoZi5pc0Z1bmN0aW9uKGEpKXJldHVybiB0
aGlzLmVhY2goZnVuY3Rpb24oYyl7dmFyIGQ9Zih0aGlzKTtkLnRvZ2dsZUNsYXNzKGEuY2FsbCh0
aGlzLGMsZC5hdHRyKCJjbGFzcyIpLGIpLGIpfSk7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigp
e2lmKGM9PT0ic3RyaW5nIil7dmFyIGUsZz0wLGg9Zih0aGlzKSxpPWIsaj1hLnNwbGl0KG8pO3do
aWxlKGU9altnKytdKWk9ZD9pOiFoLmhhc0NsYXNzKGUpLGhbaT8iYWRkQ2xhc3MiOiJyZW1vdmVD
bGFzcyJdKGUpfWVsc2UgaWYoYz09PSJ1bmRlZmluZWQifHxjPT09ImJvb2xlYW4iKXRoaXMuY2xh
c3NOYW1lJiZmLl9kYXRhKHRoaXMsIl9fY2xhc3NOYW1lX18iLHRoaXMuY2xhc3NOYW1lKSx0aGlz
LmNsYXNzTmFtZT10aGlzLmNsYXNzTmFtZXx8YT09PSExPyIiOmYuX2RhdGEodGhpcywiX19jbGFz
c05hbWVfXyIpfHwiIn0pfSxoYXNDbGFzczpmdW5jdGlvbihhKXt2YXIgYj0iICIrYSsiICI7Zm9y
KHZhciBjPTAsZD10aGlzLmxlbmd0aDtjPGQ7YysrKWlmKCgiICIrdGhpc1tjXS5jbGFzc05hbWUr
IiAiKS5yZXBsYWNlKG4sIiAiKS5pbmRleE9mKGIpPi0xKXJldHVybiEwO3JldHVybiExfSx2YWw6
ZnVuY3Rpb24oYSl7dmFyIGMsZCxlPXRoaXNbMF07aWYoIWFyZ3VtZW50cy5sZW5ndGgpe2lmKGUp
e2M9Zi52YWxIb29rc1tlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldfHxmLnZhbEhvb2tzW2UudHlw
ZV07aWYoYyYmImdldCJpbiBjJiYoZD1jLmdldChlLCJ2YWx1ZSIpKSE9PWIpcmV0dXJuIGQ7cmV0
dXJuKGUudmFsdWV8fCIiKS5yZXBsYWNlKHAsIiIpfXJldHVybiBifXZhciBnPWYuaXNGdW5jdGlv
bihhKTtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGQpe3ZhciBlPWYodGhpcyksaDtpZih0aGlz
Lm5vZGVUeXBlPT09MSl7Zz9oPWEuY2FsbCh0aGlzLGQsZS52YWwoKSk6aD1hLGg9PW51bGw/aD0i
Ijp0eXBlb2YgaD09Im51bWJlciI/aCs9IiI6Zi5pc0FycmF5KGgpJiYoaD1mLm1hcChoLGZ1bmN0
aW9uKGEpe3JldHVybiBhPT1udWxsPyIiOmErIiJ9KSksYz1mLnZhbEhvb2tzW3RoaXMubm9kZU5h
bWUudG9Mb3dlckNhc2UoKV18fGYudmFsSG9va3NbdGhpcy50eXBlXTtpZighY3x8ISgic2V0Imlu
IGMpfHxjLnNldCh0aGlzLGgsInZhbHVlIik9PT1iKXRoaXMudmFsdWU9aH19KX19KSxmLmV4dGVu
ZCh7dmFsSG9va3M6e29wdGlvbjp7Z2V0OmZ1bmN0aW9uKGEpe3ZhciBiPWEuYXR0cmlidXRlcy52
YWx1ZTtyZXR1cm4hYnx8Yi5zcGVjaWZpZWQ/YS52YWx1ZTphLnRleHR9fSxzZWxlY3Q6e2dldDpm
dW5jdGlvbihhKXt2YXIgYixjPWEuc2VsZWN0ZWRJbmRleCxkPVtdLGU9YS5vcHRpb25zLGc9YS50
eXBlPT09InNlbGVjdC1vbmUiO2lmKGM8MClyZXR1cm4gbnVsbDtmb3IodmFyIGg9Zz9jOjAsaT1n
P2MrMTplLmxlbmd0aDtoPGk7aCsrKXt2YXIgaj1lW2hdO2lmKGouc2VsZWN0ZWQmJihmLnN1cHBv
cnQub3B0RGlzYWJsZWQ/IWouZGlzYWJsZWQ6ai5nZXRBdHRyaWJ1dGUoImRpc2FibGVkIik9PT1u
dWxsKSYmKCFqLnBhcmVudE5vZGUuZGlzYWJsZWR8fCFmLm5vZGVOYW1lKGoucGFyZW50Tm9kZSwi
b3B0Z3JvdXAiKSkpe2I9ZihqKS52YWwoKTtpZihnKXJldHVybiBiO2QucHVzaChiKX19aWYoZyYm
IWQubGVuZ3RoJiZlLmxlbmd0aClyZXR1cm4gZihlW2NdKS52YWwoKTtyZXR1cm4gZH0sc2V0OmZ1
bmN0aW9uKGEsYil7dmFyIGM9Zi5tYWtlQXJyYXkoYik7ZihhKS5maW5kKCJvcHRpb24iKS5lYWNo
KGZ1bmN0aW9uKCl7dGhpcy5zZWxlY3RlZD1mLmluQXJyYXkoZih0aGlzKS52YWwoKSxjKT49MH0p
LGMubGVuZ3RofHwoYS5zZWxlY3RlZEluZGV4PS0xKTtyZXR1cm4gY319fSxhdHRyRm46e3ZhbDoh
MCxjc3M6ITAsaHRtbDohMCx0ZXh0OiEwLGRhdGE6ITAsd2lkdGg6ITAsaGVpZ2h0OiEwLG9mZnNl
dDohMH0sYXR0ckZpeDp7dGFiaW5kZXg6InRhYkluZGV4In0sYXR0cjpmdW5jdGlvbihhLGMsZCxl
KXt2YXIgZz1hLm5vZGVUeXBlO2lmKCFhfHxnPT09M3x8Zz09PTh8fGc9PT0yKXJldHVybiBiO2lm
KGUmJmMgaW4gZi5hdHRyRm4pcmV0dXJuIGYoYSlbY10oZCk7aWYoISgiZ2V0QXR0cmlidXRlImlu
IGEpKXJldHVybiBmLnByb3AoYSxjLGQpO3ZhciBoLGksaj1nIT09MXx8IWYuaXNYTUxEb2MoYSk7
Yz1qJiZmLmF0dHJGaXhbY118fGMsaT1mLmF0dHJIb29rc1tjXSxpfHwoIXQudGVzdChjKXx8dHlw
ZW9mIGQhPSJib29sZWFuIiYmZCE9PWImJmQudG9Mb3dlckNhc2UoKSE9PWMudG9Mb3dlckNhc2Uo
KT92JiYoZi5ub2RlTmFtZShhLCJmb3JtIil8fHUudGVzdChjKSkmJihpPXYpOmk9dyk7aWYoZCE9
PWIpe2lmKGQ9PT1udWxsKXtmLnJlbW92ZUF0dHIoYSxjKTtyZXR1cm4gYn1pZihpJiYic2V0Imlu
IGkmJmomJihoPWkuc2V0KGEsZCxjKSkhPT1iKXJldHVybiBoO2Euc2V0QXR0cmlidXRlKGMsIiIr
ZCk7cmV0dXJuIGR9aWYoaSYmImdldCJpbiBpJiZqKXJldHVybiBpLmdldChhLGMpO2g9YS5nZXRB
dHRyaWJ1dGUoYyk7cmV0dXJuIGg9PT1udWxsP2I6aH0scmVtb3ZlQXR0cjpmdW5jdGlvbihhLGIp
e3ZhciBjO2Eubm9kZVR5cGU9PT0xJiYoYj1mLmF0dHJGaXhbYl18fGIsZi5zdXBwb3J0LmdldFNl
dEF0dHJpYnV0ZT9hLnJlbW92ZUF0dHJpYnV0ZShiKTooZi5hdHRyKGEsYiwiIiksYS5yZW1vdmVB
dHRyaWJ1dGVOb2RlKGEuZ2V0QXR0cmlidXRlTm9kZShiKSkpLHQudGVzdChiKSYmKGM9Zi5wcm9w
Rml4W2JdfHxiKWluIGEmJihhW2NdPSExKSl9LGF0dHJIb29rczp7dHlwZTp7c2V0OmZ1bmN0aW9u
KGEsYil7aWYocS50ZXN0KGEubm9kZU5hbWUpJiZhLnBhcmVudE5vZGUpZi5lcnJvcigidHlwZSBw
cm9wZXJ0eSBjYW4ndCBiZSBjaGFuZ2VkIik7ZWxzZSBpZighZi5zdXBwb3J0LnJhZGlvVmFsdWUm
JmI9PT0icmFkaW8iJiZmLm5vZGVOYW1lKGEsImlucHV0Iikpe3ZhciBjPWEudmFsdWU7YS5zZXRB
dHRyaWJ1dGUoInR5cGUiLGIpLGMmJihhLnZhbHVlPWMpO3JldHVybiBifX19LHRhYkluZGV4Ontn
ZXQ6ZnVuY3Rpb24oYSl7dmFyIGM9YS5nZXRBdHRyaWJ1dGVOb2RlKCJ0YWJJbmRleCIpO3JldHVy
biBjJiZjLnNwZWNpZmllZD9wYXJzZUludChjLnZhbHVlLDEwKTpyLnRlc3QoYS5ub2RlTmFtZSl8
fHMudGVzdChhLm5vZGVOYW1lKSYmYS5ocmVmPzA6Yn19fSxwcm9wRml4Ont0YWJpbmRleDoidGFi
SW5kZXgiLHJlYWRvbmx5OiJyZWFkT25seSIsImZvciI6Imh0bWxGb3IiLCJjbGFzcyI6ImNsYXNz
TmFtZSIsbWF4bGVuZ3RoOiJtYXhMZW5ndGgiLGNlbGxzcGFjaW5nOiJjZWxsU3BhY2luZyIsY2Vs
bHBhZGRpbmc6ImNlbGxQYWRkaW5nIixyb3dzcGFuOiJyb3dTcGFuIixjb2xzcGFuOiJjb2xTcGFu
Iix1c2VtYXA6InVzZU1hcCIsZnJhbWVib3JkZXI6ImZyYW1lQm9yZGVyIixjb250ZW50ZWRpdGFi
bGU6ImNvbnRlbnRFZGl0YWJsZSJ9LHByb3A6ZnVuY3Rpb24oYSxjLGQpe3ZhciBlPWEubm9kZVR5
cGU7aWYoIWF8fGU9PT0zfHxlPT09OHx8ZT09PTIpcmV0dXJuIGI7dmFyIGcsaCxpPWUhPT0xfHwh
Zi5pc1hNTERvYyhhKTtjPWkmJmYucHJvcEZpeFtjXXx8YyxoPWYucHJvcEhvb2tzW2NdO3JldHVy
biBkIT09Yj9oJiYic2V0ImluIGgmJihnPWguc2V0KGEsZCxjKSkhPT1iP2c6YVtjXT1kOmgmJiJn
ZXQiaW4gaCYmKGc9aC5nZXQoYSxjKSkhPT1iP2c6YVtjXX0scHJvcEhvb2tzOnt9fSksdz17Z2V0
OmZ1bmN0aW9uKGEsYyl7cmV0dXJuIGFbZi5wcm9wRml4W2NdfHxjXT9jLnRvTG93ZXJDYXNlKCk6
Yn0sc2V0OmZ1bmN0aW9uKGEsYixjKXt2YXIgZDtiPT09ITE/Zi5yZW1vdmVBdHRyKGEsYyk6KGQ9
Zi5wcm9wRml4W2NdfHxjLGQgaW4gYSYmKGFbZF09YiksYS5zZXRBdHRyaWJ1dGUoYyxjLnRvTG93
ZXJDYXNlKCkpKTtyZXR1cm4gY319LGYuYXR0ckhvb2tzLnZhbHVlPXtnZXQ6ZnVuY3Rpb24oYSxi
KXtpZih2JiZmLm5vZGVOYW1lKGEsImJ1dHRvbiIpKXJldHVybiB2LmdldChhLGIpO3JldHVybiBh
LnZhbHVlfSxzZXQ6ZnVuY3Rpb24oYSxiLGMpe2lmKHYmJmYubm9kZU5hbWUoYSwiYnV0dG9uIikp
cmV0dXJuIHYuc2V0KGEsYixjKTthLnZhbHVlPWJ9fSxmLnN1cHBvcnQuZ2V0U2V0QXR0cmlidXRl
fHwoZi5hdHRyRml4PWYucHJvcEZpeCx2PWYuYXR0ckhvb2tzLm5hbWU9Zi52YWxIb29rcy5idXR0
b249e2dldDpmdW5jdGlvbihhLGMpe3ZhciBkO2Q9YS5nZXRBdHRyaWJ1dGVOb2RlKGMpO3JldHVy
biBkJiZkLm5vZGVWYWx1ZSE9PSIiP2Qubm9kZVZhbHVlOmJ9LHNldDpmdW5jdGlvbihhLGIsYyl7
dmFyIGQ9YS5nZXRBdHRyaWJ1dGVOb2RlKGMpO2lmKGQpe2Qubm9kZVZhbHVlPWI7cmV0dXJuIGJ9
fX0sZi5lYWNoKFsid2lkdGgiLCJoZWlnaHQiXSxmdW5jdGlvbihhLGIpe2YuYXR0ckhvb2tzW2Jd
PWYuZXh0ZW5kKGYuYXR0ckhvb2tzW2JdLHtzZXQ6ZnVuY3Rpb24oYSxjKXtpZihjPT09IiIpe2Eu
c2V0QXR0cmlidXRlKGIsImF1dG8iKTtyZXR1cm4gY319fSl9KSksZi5zdXBwb3J0LmhyZWZOb3Jt
YWxpemVkfHxmLmVhY2goWyJocmVmIiwic3JjIiwid2lkdGgiLCJoZWlnaHQiXSxmdW5jdGlvbihh
LGMpe2YuYXR0ckhvb2tzW2NdPWYuZXh0ZW5kKGYuYXR0ckhvb2tzW2NdLHtnZXQ6ZnVuY3Rpb24o
YSl7dmFyIGQ9YS5nZXRBdHRyaWJ1dGUoYywyKTtyZXR1cm4gZD09PW51bGw/YjpkfX0pfSksZi5z
dXBwb3J0LnN0eWxlfHwoZi5hdHRySG9va3Muc3R5bGU9e2dldDpmdW5jdGlvbihhKXtyZXR1cm4g
YS5zdHlsZS5jc3NUZXh0LnRvTG93ZXJDYXNlKCl8fGJ9LHNldDpmdW5jdGlvbihhLGIpe3JldHVy
biBhLnN0eWxlLmNzc1RleHQ9IiIrYn19KSxmLnN1cHBvcnQub3B0U2VsZWN0ZWR8fChmLnByb3BI
b29rcy5zZWxlY3RlZD1mLmV4dGVuZChmLnByb3BIb29rcy5zZWxlY3RlZCx7Z2V0OmZ1bmN0aW9u
KGEpe3ZhciBiPWEucGFyZW50Tm9kZTtiJiYoYi5zZWxlY3RlZEluZGV4LGIucGFyZW50Tm9kZSYm
Yi5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXgpfX0pKSxmLnN1cHBvcnQuY2hlY2tPbnx8Zi5lYWNo
KFsicmFkaW8iLCJjaGVja2JveCJdLGZ1bmN0aW9uKCl7Zi52YWxIb29rc1t0aGlzXT17Z2V0OmZ1
bmN0aW9uKGEpe3JldHVybiBhLmdldEF0dHJpYnV0ZSgidmFsdWUiKT09PW51bGw/Im9uIjphLnZh
bHVlfX19KSxmLmVhY2goWyJyYWRpbyIsImNoZWNrYm94Il0sZnVuY3Rpb24oKXtmLnZhbEhvb2tz
W3RoaXNdPWYuZXh0ZW5kKGYudmFsSG9va3NbdGhpc10se3NldDpmdW5jdGlvbihhLGIpe2lmKGYu
aXNBcnJheShiKSlyZXR1cm4gYS5jaGVja2VkPWYuaW5BcnJheShmKGEpLnZhbCgpLGIpPj0wfX0p
fSk7dmFyIHg9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSx5PS9cLiguKikkLyx6PS9e
KD86dGV4dGFyZWF8aW5wdXR8c2VsZWN0KSQvaSxBPS9cLi9nLEI9LyAvZyxDPS9bXlx3XHMufGBd
L2csRD1mdW5jdGlvbihhKXtyZXR1cm4gYS5yZXBsYWNlKEMsIlxcJCYiKX07Zi5ldmVudD17YWRk
OmZ1bmN0aW9uKGEsYyxkLGUpe2lmKGEubm9kZVR5cGUhPT0zJiZhLm5vZGVUeXBlIT09OCl7aWYo
ZD09PSExKWQ9RTtlbHNlIGlmKCFkKXJldHVybjt2YXIgZyxoO2QuaGFuZGxlciYmKGc9ZCxkPWcu
aGFuZGxlciksZC5ndWlkfHwoZC5ndWlkPWYuZ3VpZCsrKTt2YXIgaT1mLl9kYXRhKGEpO2lmKCFp
KXJldHVybjt2YXIgaj1pLmV2ZW50cyxrPWkuaGFuZGxlO2p8fChpLmV2ZW50cz1qPXt9KSxrfHwo
aS5oYW5kbGU9az1mdW5jdGlvbihhKXtyZXR1cm4gdHlwZW9mIGYhPSJ1bmRlZmluZWQiJiYoIWF8
fGYuZXZlbnQudHJpZ2dlcmVkIT09YS50eXBlKT9mLmV2ZW50LmhhbmRsZS5hcHBseShrLmVsZW0s
YXJndW1lbnRzKTpifSksay5lbGVtPWEsYz1jLnNwbGl0KCIgIik7dmFyIGwsbT0wLG47d2hpbGUo
bD1jW20rK10pe2g9Zz9mLmV4dGVuZCh7fSxnKTp7aGFuZGxlcjpkLGRhdGE6ZX0sbC5pbmRleE9m
KCIuIik+LTE/KG49bC5zcGxpdCgiLiIpLGw9bi5zaGlmdCgpLGgubmFtZXNwYWNlPW4uc2xpY2Uo
MCkuc29ydCgpLmpvaW4oIi4iKSk6KG49W10saC5uYW1lc3BhY2U9IiIpLGgudHlwZT1sLGguZ3Vp
ZHx8KGguZ3VpZD1kLmd1aWQpO3ZhciBvPWpbbF0scD1mLmV2ZW50LnNwZWNpYWxbbF18fHt9O2lm
KCFvKXtvPWpbbF09W107aWYoIXAuc2V0dXB8fHAuc2V0dXAuY2FsbChhLGUsbixrKT09PSExKWEu
YWRkRXZlbnRMaXN0ZW5lcj9hLmFkZEV2ZW50TGlzdGVuZXIobCxrLCExKTphLmF0dGFjaEV2ZW50
JiZhLmF0dGFjaEV2ZW50KCJvbiIrbCxrKX1wLmFkZCYmKHAuYWRkLmNhbGwoYSxoKSxoLmhhbmRs
ZXIuZ3VpZHx8KGguaGFuZGxlci5ndWlkPWQuZ3VpZCkpLG8ucHVzaChoKSxmLmV2ZW50Lmdsb2Jh
bFtsXT0hMH1hPW51bGx9fSxnbG9iYWw6e30scmVtb3ZlOmZ1bmN0aW9uKGEsYyxkLGUpe2lmKGEu
bm9kZVR5cGUhPT0zJiZhLm5vZGVUeXBlIT09OCl7ZD09PSExJiYoZD1FKTt2YXIgZyxoLGksaixr
PTAsbCxtLG4sbyxwLHEscixzPWYuaGFzRGF0YShhKSYmZi5fZGF0YShhKSx0PXMmJnMuZXZlbnRz
O2lmKCFzfHwhdClyZXR1cm47YyYmYy50eXBlJiYoZD1jLmhhbmRsZXIsYz1jLnR5cGUpO2lmKCFj
fHx0eXBlb2YgYz09InN0cmluZyImJmMuY2hhckF0KDApPT09Ii4iKXtjPWN8fCIiO2ZvcihoIGlu
IHQpZi5ldmVudC5yZW1vdmUoYSxoK2MpO3JldHVybn1jPWMuc3BsaXQoIiAiKTt3aGlsZShoPWNb
aysrXSl7cj1oLHE9bnVsbCxsPWguaW5kZXhPZigiLiIpPDAsbT1bXSxsfHwobT1oLnNwbGl0KCIu
IiksaD1tLnNoaWZ0KCksbj1uZXcgUmVnRXhwKCIoXnxcXC4pIitmLm1hcChtLnNsaWNlKDApLnNv
cnQoKSxEKS5qb2luKCJcXC4oPzouKlxcLik/IikrIihcXC58JCkiKSkscD10W2hdO2lmKCFwKWNv
bnRpbnVlO2lmKCFkKXtmb3Ioaj0wO2o8cC5sZW5ndGg7aisrKXtxPXBbal07aWYobHx8bi50ZXN0
KHEubmFtZXNwYWNlKSlmLmV2ZW50LnJlbW92ZShhLHIscS5oYW5kbGVyLGopLHAuc3BsaWNlKGot
LSwxKX1jb250aW51ZX1vPWYuZXZlbnQuc3BlY2lhbFtoXXx8e307Zm9yKGo9ZXx8MDtqPHAubGVu
Z3RoO2orKyl7cT1wW2pdO2lmKGQuZ3VpZD09PXEuZ3VpZCl7aWYobHx8bi50ZXN0KHEubmFtZXNw
YWNlKSllPT1udWxsJiZwLnNwbGljZShqLS0sMSksby5yZW1vdmUmJm8ucmVtb3ZlLmNhbGwoYSxx
KTtpZihlIT1udWxsKWJyZWFrfX1pZihwLmxlbmd0aD09PTB8fGUhPW51bGwmJnAubGVuZ3RoPT09
MSkoIW8udGVhcmRvd258fG8udGVhcmRvd24uY2FsbChhLG0pPT09ITEpJiZmLnJlbW92ZUV2ZW50
KGEsaCxzLmhhbmRsZSksZz1udWxsLGRlbGV0ZSB0W2hdfWlmKGYuaXNFbXB0eU9iamVjdCh0KSl7
dmFyIHU9cy5oYW5kbGU7dSYmKHUuZWxlbT1udWxsKSxkZWxldGUgcy5ldmVudHMsZGVsZXRlIHMu
aGFuZGxlLGYuaXNFbXB0eU9iamVjdChzKSYmZi5yZW1vdmVEYXRhKGEsYiwhMCl9fX0sY3VzdG9t
RXZlbnQ6e2dldERhdGE6ITAsc2V0RGF0YTohMCxjaGFuZ2VEYXRhOiEwfSx0cmlnZ2VyOmZ1bmN0
aW9uKGMsZCxlLGcpe3ZhciBoPWMudHlwZXx8YyxpPVtdLGo7aC5pbmRleE9mKCIhIik+PTAmJiho
PWguc2xpY2UoMCwtMSksaj0hMCksaC5pbmRleE9mKCIuIik+PTAmJihpPWguc3BsaXQoIi4iKSxo
PWkuc2hpZnQoKSxpLnNvcnQoKSk7aWYoISFlJiYhZi5ldmVudC5jdXN0b21FdmVudFtoXXx8ISFm
LmV2ZW50Lmdsb2JhbFtoXSl7Yz10eXBlb2YgYz09Im9iamVjdCI/Y1tmLmV4cGFuZG9dP2M6bmV3
IGYuRXZlbnQoaCxjKTpuZXcgZi5FdmVudChoKSxjLnR5cGU9aCxjLmV4Y2x1c2l2ZT1qLGMubmFt
ZXNwYWNlPWkuam9pbigiLiIpLGMubmFtZXNwYWNlX3JlPW5ldyBSZWdFeHAoIihefFxcLikiK2ku
am9pbigiXFwuKD86LipcXC4pPyIpKyIoXFwufCQpIik7aWYoZ3x8IWUpYy5wcmV2ZW50RGVmYXVs
dCgpLGMuc3RvcFByb3BhZ2F0aW9uKCk7aWYoIWUpe2YuZWFjaChmLmNhY2hlLGZ1bmN0aW9uKCl7
dmFyIGE9Zi5leHBhbmRvLGI9dGhpc1thXTtiJiZiLmV2ZW50cyYmYi5ldmVudHNbaF0mJmYuZXZl
bnQudHJpZ2dlcihjLGQsYi5oYW5kbGUuZWxlbSApfSk7cmV0dXJufWlmKGUubm9kZVR5cGU9PT0z
fHxlLm5vZGVUeXBlPT09OClyZXR1cm47Yy5yZXN1bHQ9YixjLnRhcmdldD1lLGQ9ZD9mLm1ha2VB
cnJheShkKTpbXSxkLnVuc2hpZnQoYyk7dmFyIGs9ZSxsPWguaW5kZXhPZigiOiIpPDA/Im9uIito
OiIiO2Rve3ZhciBtPWYuX2RhdGEoaywiaGFuZGxlIik7Yy5jdXJyZW50VGFyZ2V0PWssbSYmbS5h
cHBseShrLGQpLGwmJmYuYWNjZXB0RGF0YShrKSYma1tsXSYma1tsXS5hcHBseShrLGQpPT09ITEm
JihjLnJlc3VsdD0hMSxjLnByZXZlbnREZWZhdWx0KCkpLGs9ay5wYXJlbnROb2RlfHxrLm93bmVy
RG9jdW1lbnR8fGs9PT1jLnRhcmdldC5vd25lckRvY3VtZW50JiZhfXdoaWxlKGsmJiFjLmlzUHJv
cGFnYXRpb25TdG9wcGVkKCkpO2lmKCFjLmlzRGVmYXVsdFByZXZlbnRlZCgpKXt2YXIgbixvPWYu
ZXZlbnQuc3BlY2lhbFtoXXx8e307aWYoKCFvLl9kZWZhdWx0fHxvLl9kZWZhdWx0LmNhbGwoZS5v
d25lckRvY3VtZW50LGMpPT09ITEpJiYoaCE9PSJjbGljayJ8fCFmLm5vZGVOYW1lKGUsImEiKSkm
JmYuYWNjZXB0RGF0YShlKSl7dHJ5e2wmJmVbaF0mJihuPWVbbF0sbiYmKGVbbF09bnVsbCksZi5l
dmVudC50cmlnZ2VyZWQ9aCxlW2hdKCkpfWNhdGNoKHApe31uJiYoZVtsXT1uKSxmLmV2ZW50LnRy
aWdnZXJlZD1ifX1yZXR1cm4gYy5yZXN1bHR9fSxoYW5kbGU6ZnVuY3Rpb24oYyl7Yz1mLmV2ZW50
LmZpeChjfHxhLmV2ZW50KTt2YXIgZD0oKGYuX2RhdGEodGhpcywiZXZlbnRzIil8fHt9KVtjLnR5
cGVdfHxbXSkuc2xpY2UoMCksZT0hYy5leGNsdXNpdmUmJiFjLm5hbWVzcGFjZSxnPUFycmF5LnBy
b3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywwKTtnWzBdPWMsYy5jdXJyZW50VGFyZ2V0PXRo
aXM7Zm9yKHZhciBoPTAsaT1kLmxlbmd0aDtoPGk7aCsrKXt2YXIgaj1kW2hdO2lmKGV8fGMubmFt
ZXNwYWNlX3JlLnRlc3Qoai5uYW1lc3BhY2UpKXtjLmhhbmRsZXI9ai5oYW5kbGVyLGMuZGF0YT1q
LmRhdGEsYy5oYW5kbGVPYmo9ajt2YXIgaz1qLmhhbmRsZXIuYXBwbHkodGhpcyxnKTtrIT09YiYm
KGMucmVzdWx0PWssaz09PSExJiYoYy5wcmV2ZW50RGVmYXVsdCgpLGMuc3RvcFByb3BhZ2F0aW9u
KCkpKTtpZihjLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpYnJlYWt9fXJldHVybiBj
LnJlc3VsdH0scHJvcHM6ImFsdEtleSBhdHRyQ2hhbmdlIGF0dHJOYW1lIGJ1YmJsZXMgYnV0dG9u
IGNhbmNlbGFibGUgY2hhckNvZGUgY2xpZW50WCBjbGllbnRZIGN0cmxLZXkgY3VycmVudFRhcmdl
dCBkYXRhIGRldGFpbCBldmVudFBoYXNlIGZyb21FbGVtZW50IGhhbmRsZXIga2V5Q29kZSBsYXll
clggbGF5ZXJZIG1ldGFLZXkgbmV3VmFsdWUgb2Zmc2V0WCBvZmZzZXRZIHBhZ2VYIHBhZ2VZIHBy
ZXZWYWx1ZSByZWxhdGVkTm9kZSByZWxhdGVkVGFyZ2V0IHNjcmVlblggc2NyZWVuWSBzaGlmdEtl
eSBzcmNFbGVtZW50IHRhcmdldCB0b0VsZW1lbnQgdmlldyB3aGVlbERlbHRhIHdoaWNoIi5zcGxp
dCgiICIpLGZpeDpmdW5jdGlvbihhKXtpZihhW2YuZXhwYW5kb10pcmV0dXJuIGE7dmFyIGQ9YTth
PWYuRXZlbnQoZCk7Zm9yKHZhciBlPXRoaXMucHJvcHMubGVuZ3RoLGc7ZTspZz10aGlzLnByb3Bz
Wy0tZV0sYVtnXT1kW2ddO2EudGFyZ2V0fHwoYS50YXJnZXQ9YS5zcmNFbGVtZW50fHxjKSxhLnRh
cmdldC5ub2RlVHlwZT09PTMmJihhLnRhcmdldD1hLnRhcmdldC5wYXJlbnROb2RlKSwhYS5yZWxh
dGVkVGFyZ2V0JiZhLmZyb21FbGVtZW50JiYoYS5yZWxhdGVkVGFyZ2V0PWEuZnJvbUVsZW1lbnQ9
PT1hLnRhcmdldD9hLnRvRWxlbWVudDphLmZyb21FbGVtZW50KTtpZihhLnBhZ2VYPT1udWxsJiZh
LmNsaWVudFghPW51bGwpe3ZhciBoPWEudGFyZ2V0Lm93bmVyRG9jdW1lbnR8fGMsaT1oLmRvY3Vt
ZW50RWxlbWVudCxqPWguYm9keTthLnBhZ2VYPWEuY2xpZW50WCsoaSYmaS5zY3JvbGxMZWZ0fHxq
JiZqLnNjcm9sbExlZnR8fDApLShpJiZpLmNsaWVudExlZnR8fGomJmouY2xpZW50TGVmdHx8MCks
YS5wYWdlWT1hLmNsaWVudFkrKGkmJmkuc2Nyb2xsVG9wfHxqJiZqLnNjcm9sbFRvcHx8MCktKGkm
JmkuY2xpZW50VG9wfHxqJiZqLmNsaWVudFRvcHx8MCl9YS53aGljaD09bnVsbCYmKGEuY2hhckNv
ZGUhPW51bGx8fGEua2V5Q29kZSE9bnVsbCkmJihhLndoaWNoPWEuY2hhckNvZGUhPW51bGw/YS5j
aGFyQ29kZTphLmtleUNvZGUpLCFhLm1ldGFLZXkmJmEuY3RybEtleSYmKGEubWV0YUtleT1hLmN0
cmxLZXkpLCFhLndoaWNoJiZhLmJ1dHRvbiE9PWImJihhLndoaWNoPWEuYnV0dG9uJjE/MTphLmJ1
dHRvbiYyPzM6YS5idXR0b24mND8yOjApO3JldHVybiBhfSxndWlkOjFlOCxwcm94eTpmLnByb3h5
LHNwZWNpYWw6e3JlYWR5OntzZXR1cDpmLmJpbmRSZWFkeSx0ZWFyZG93bjpmLm5vb3B9LGxpdmU6
e2FkZDpmdW5jdGlvbihhKXtmLmV2ZW50LmFkZCh0aGlzLE8oYS5vcmlnVHlwZSxhLnNlbGVjdG9y
KSxmLmV4dGVuZCh7fSxhLHtoYW5kbGVyOk4sZ3VpZDphLmhhbmRsZXIuZ3VpZH0pKX0scmVtb3Zl
OmZ1bmN0aW9uKGEpe2YuZXZlbnQucmVtb3ZlKHRoaXMsTyhhLm9yaWdUeXBlLGEuc2VsZWN0b3Ip
LGEpfX0sYmVmb3JldW5sb2FkOntzZXR1cDpmdW5jdGlvbihhLGIsYyl7Zi5pc1dpbmRvdyh0aGlz
KSYmKHRoaXMub25iZWZvcmV1bmxvYWQ9Yyl9LHRlYXJkb3duOmZ1bmN0aW9uKGEsYil7dGhpcy5v
bmJlZm9yZXVubG9hZD09PWImJih0aGlzLm9uYmVmb3JldW5sb2FkPW51bGwpfX19fSxmLnJlbW92
ZUV2ZW50PWMucmVtb3ZlRXZlbnRMaXN0ZW5lcj9mdW5jdGlvbihhLGIsYyl7YS5yZW1vdmVFdmVu
dExpc3RlbmVyJiZhLnJlbW92ZUV2ZW50TGlzdGVuZXIoYixjLCExKX06ZnVuY3Rpb24oYSxiLGMp
e2EuZGV0YWNoRXZlbnQmJmEuZGV0YWNoRXZlbnQoIm9uIitiLGMpfSxmLkV2ZW50PWZ1bmN0aW9u
KGEsYil7aWYoIXRoaXMucHJldmVudERlZmF1bHQpcmV0dXJuIG5ldyBmLkV2ZW50KGEsYik7YSYm
YS50eXBlPyh0aGlzLm9yaWdpbmFsRXZlbnQ9YSx0aGlzLnR5cGU9YS50eXBlLHRoaXMuaXNEZWZh
dWx0UHJldmVudGVkPWEuZGVmYXVsdFByZXZlbnRlZHx8YS5yZXR1cm5WYWx1ZT09PSExfHxhLmdl
dFByZXZlbnREZWZhdWx0JiZhLmdldFByZXZlbnREZWZhdWx0KCk/RjpFKTp0aGlzLnR5cGU9YSxi
JiZmLmV4dGVuZCh0aGlzLGIpLHRoaXMudGltZVN0YW1wPWYubm93KCksdGhpc1tmLmV4cGFuZG9d
PSEwfSxmLkV2ZW50LnByb3RvdHlwZT17cHJldmVudERlZmF1bHQ6ZnVuY3Rpb24oKXt0aGlzLmlz
RGVmYXVsdFByZXZlbnRlZD1GO3ZhciBhPXRoaXMub3JpZ2luYWxFdmVudDshYXx8KGEucHJldmVu
dERlZmF1bHQ/YS5wcmV2ZW50RGVmYXVsdCgpOmEucmV0dXJuVmFsdWU9ITEpfSxzdG9wUHJvcGFn
YXRpb246ZnVuY3Rpb24oKXt0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPUY7dmFyIGE9dGhpcy5v
cmlnaW5hbEV2ZW50OyFhfHwoYS5zdG9wUHJvcGFnYXRpb24mJmEuc3RvcFByb3BhZ2F0aW9uKCks
YS5jYW5jZWxCdWJibGU9ITApfSxzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246ZnVuY3Rpb24oKXt0
aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkPUYsdGhpcy5zdG9wUHJvcGFnYXRpb24o
KX0saXNEZWZhdWx0UHJldmVudGVkOkUsaXNQcm9wYWdhdGlvblN0b3BwZWQ6RSxpc0ltbWVkaWF0
ZVByb3BhZ2F0aW9uU3RvcHBlZDpFfTt2YXIgRz1mdW5jdGlvbihhKXt2YXIgYj1hLnJlbGF0ZWRU
YXJnZXQ7YS50eXBlPWEuZGF0YTt0cnl7aWYoYiYmYiE9PWMmJiFiLnBhcmVudE5vZGUpcmV0dXJu
O3doaWxlKGImJmIhPT10aGlzKWI9Yi5wYXJlbnROb2RlO2IhPT10aGlzJiZmLmV2ZW50LmhhbmRs
ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y2F0Y2goZCl7fX0sSD1mdW5jdGlvbihhKXthLnR5cGU9
YS5kYXRhLGYuZXZlbnQuaGFuZGxlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07Zi5lYWNoKHttb3Vz
ZWVudGVyOiJtb3VzZW92ZXIiLG1vdXNlbGVhdmU6Im1vdXNlb3V0In0sZnVuY3Rpb24oYSxiKXtm
LmV2ZW50LnNwZWNpYWxbYV09e3NldHVwOmZ1bmN0aW9uKGMpe2YuZXZlbnQuYWRkKHRoaXMsYixj
JiZjLnNlbGVjdG9yP0g6RyxhKX0sdGVhcmRvd246ZnVuY3Rpb24oYSl7Zi5ldmVudC5yZW1vdmUo
dGhpcyxiLGEmJmEuc2VsZWN0b3I/SDpHKX19fSksZi5zdXBwb3J0LnN1Ym1pdEJ1YmJsZXN8fChm
LmV2ZW50LnNwZWNpYWwuc3VibWl0PXtzZXR1cDpmdW5jdGlvbihhLGIpe2lmKCFmLm5vZGVOYW1l
KHRoaXMsImZvcm0iKSlmLmV2ZW50LmFkZCh0aGlzLCJjbGljay5zcGVjaWFsU3VibWl0IixmdW5j
dGlvbihhKXt2YXIgYj1hLnRhcmdldCxjPWIudHlwZTsoYz09PSJzdWJtaXQifHxjPT09ImltYWdl
IikmJmYoYikuY2xvc2VzdCgiZm9ybSIpLmxlbmd0aCYmTCgic3VibWl0Iix0aGlzLGFyZ3VtZW50
cyl9KSxmLmV2ZW50LmFkZCh0aGlzLCJrZXlwcmVzcy5zcGVjaWFsU3VibWl0IixmdW5jdGlvbihh
KXt2YXIgYj1hLnRhcmdldCxjPWIudHlwZTsoYz09PSJ0ZXh0Inx8Yz09PSJwYXNzd29yZCIpJiZm
KGIpLmNsb3Nlc3QoImZvcm0iKS5sZW5ndGgmJmEua2V5Q29kZT09PTEzJiZMKCJzdWJtaXQiLHRo
aXMsYXJndW1lbnRzKX0pO2Vsc2UgcmV0dXJuITF9LHRlYXJkb3duOmZ1bmN0aW9uKGEpe2YuZXZl
bnQucmVtb3ZlKHRoaXMsIi5zcGVjaWFsU3VibWl0Iil9fSk7aWYoIWYuc3VwcG9ydC5jaGFuZ2VC
dWJibGVzKXt2YXIgSSxKPWZ1bmN0aW9uKGEpe3ZhciBiPWEudHlwZSxjPWEudmFsdWU7Yj09PSJy
YWRpbyJ8fGI9PT0iY2hlY2tib3giP2M9YS5jaGVja2VkOmI9PT0ic2VsZWN0LW11bHRpcGxlIj9j
PWEuc2VsZWN0ZWRJbmRleD4tMT9mLm1hcChhLm9wdGlvbnMsZnVuY3Rpb24oYSl7cmV0dXJuIGEu
c2VsZWN0ZWR9KS5qb2luKCItIik6IiI6Zi5ub2RlTmFtZShhLCJzZWxlY3QiKSYmKGM9YS5zZWxl
Y3RlZEluZGV4KTtyZXR1cm4gY30sSz1mdW5jdGlvbihjKXt2YXIgZD1jLnRhcmdldCxlLGc7aWYo
ISF6LnRlc3QoZC5ub2RlTmFtZSkmJiFkLnJlYWRPbmx5KXtlPWYuX2RhdGEoZCwiX2NoYW5nZV9k
YXRhIiksZz1KKGQpLChjLnR5cGUhPT0iZm9jdXNvdXQifHxkLnR5cGUhPT0icmFkaW8iKSYmZi5f
ZGF0YShkLCJfY2hhbmdlX2RhdGEiLGcpO2lmKGU9PT1ifHxnPT09ZSlyZXR1cm47aWYoZSE9bnVs
bHx8ZyljLnR5cGU9ImNoYW5nZSIsYy5saXZlRmlyZWQ9YixmLmV2ZW50LnRyaWdnZXIoYyxhcmd1
bWVudHNbMV0sZCl9fTtmLmV2ZW50LnNwZWNpYWwuY2hhbmdlPXtmaWx0ZXJzOntmb2N1c291dDpL
LGJlZm9yZWRlYWN0aXZhdGU6SyxjbGljazpmdW5jdGlvbihhKXt2YXIgYj1hLnRhcmdldCxjPWYu
bm9kZU5hbWUoYiwiaW5wdXQiKT9iLnR5cGU6IiI7KGM9PT0icmFkaW8ifHxjPT09ImNoZWNrYm94
Inx8Zi5ub2RlTmFtZShiLCJzZWxlY3QiKSkmJksuY2FsbCh0aGlzLGEpfSxrZXlkb3duOmZ1bmN0
aW9uKGEpe3ZhciBiPWEudGFyZ2V0LGM9Zi5ub2RlTmFtZShiLCJpbnB1dCIpP2IudHlwZToiIjso
YS5rZXlDb2RlPT09MTMmJiFmLm5vZGVOYW1lKGIsInRleHRhcmVhIil8fGEua2V5Q29kZT09PTMy
JiYoYz09PSJjaGVja2JveCJ8fGM9PT0icmFkaW8iKXx8Yz09PSJzZWxlY3QtbXVsdGlwbGUiKSYm
Sy5jYWxsKHRoaXMsYSl9LGJlZm9yZWFjdGl2YXRlOmZ1bmN0aW9uKGEpe3ZhciBiPWEudGFyZ2V0
O2YuX2RhdGEoYiwiX2NoYW5nZV9kYXRhIixKKGIpKX19LHNldHVwOmZ1bmN0aW9uKGEsYil7aWYo
dGhpcy50eXBlPT09ImZpbGUiKXJldHVybiExO2Zvcih2YXIgYyBpbiBJKWYuZXZlbnQuYWRkKHRo
aXMsYysiLnNwZWNpYWxDaGFuZ2UiLElbY10pO3JldHVybiB6LnRlc3QodGhpcy5ub2RlTmFtZSl9
LHRlYXJkb3duOmZ1bmN0aW9uKGEpe2YuZXZlbnQucmVtb3ZlKHRoaXMsIi5zcGVjaWFsQ2hhbmdl
Iik7cmV0dXJuIHoudGVzdCh0aGlzLm5vZGVOYW1lKX19LEk9Zi5ldmVudC5zcGVjaWFsLmNoYW5n
ZS5maWx0ZXJzLEkuZm9jdXM9SS5iZWZvcmVhY3RpdmF0ZX1mLnN1cHBvcnQuZm9jdXNpbkJ1YmJs
ZXN8fGYuZWFjaCh7Zm9jdXM6ImZvY3VzaW4iLGJsdXI6ImZvY3Vzb3V0In0sZnVuY3Rpb24oYSxi
KXtmdW5jdGlvbiBlKGEpe3ZhciBjPWYuZXZlbnQuZml4KGEpO2MudHlwZT1iLGMub3JpZ2luYWxF
dmVudD17fSxmLmV2ZW50LnRyaWdnZXIoYyxudWxsLGMudGFyZ2V0KSxjLmlzRGVmYXVsdFByZXZl
bnRlZCgpJiZhLnByZXZlbnREZWZhdWx0KCl9dmFyIGQ9MDtmLmV2ZW50LnNwZWNpYWxbYl09e3Nl
dHVwOmZ1bmN0aW9uKCl7ZCsrPT09MCYmYy5hZGRFdmVudExpc3RlbmVyKGEsZSwhMCl9LHRlYXJk
b3duOmZ1bmN0aW9uKCl7LS1kPT09MCYmYy5yZW1vdmVFdmVudExpc3RlbmVyKGEsZSwhMCl9fX0p
LGYuZWFjaChbImJpbmQiLCJvbmUiXSxmdW5jdGlvbihhLGMpe2YuZm5bY109ZnVuY3Rpb24oYSxk
LGUpe3ZhciBnO2lmKHR5cGVvZiBhPT0ib2JqZWN0Iil7Zm9yKHZhciBoIGluIGEpdGhpc1tjXSho
LGQsYVtoXSxlKTtyZXR1cm4gdGhpc31pZihhcmd1bWVudHMubGVuZ3RoPT09Mnx8ZD09PSExKWU9
ZCxkPWI7Yz09PSJvbmUiPyhnPWZ1bmN0aW9uKGEpe2YodGhpcykudW5iaW5kKGEsZyk7cmV0dXJu
IGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxnLmd1aWQ9ZS5ndWlkfHxmLmd1aWQrKyk6Zz1lO2lm
KGE9PT0idW5sb2FkIiYmYyE9PSJvbmUiKXRoaXMub25lKGEsZCxlKTtlbHNlIGZvcih2YXIgaT0w
LGo9dGhpcy5sZW5ndGg7aTxqO2krKylmLmV2ZW50LmFkZCh0aGlzW2ldLGEsZyxkKTtyZXR1cm4g
dGhpc319KSxmLmZuLmV4dGVuZCh7dW5iaW5kOmZ1bmN0aW9uKGEsYil7aWYodHlwZW9mIGE9PSJv
YmplY3QiJiYhYS5wcmV2ZW50RGVmYXVsdClmb3IodmFyIGMgaW4gYSl0aGlzLnVuYmluZChjLGFb
Y10pO2Vsc2UgZm9yKHZhciBkPTAsZT10aGlzLmxlbmd0aDtkPGU7ZCsrKWYuZXZlbnQucmVtb3Zl
KHRoaXNbZF0sYSxiKTtyZXR1cm4gdGhpc30sZGVsZWdhdGU6ZnVuY3Rpb24oYSxiLGMsZCl7cmV0
dXJuIHRoaXMubGl2ZShiLGMsZCxhKX0sdW5kZWxlZ2F0ZTpmdW5jdGlvbihhLGIsYyl7cmV0dXJu
IGFyZ3VtZW50cy5sZW5ndGg9PT0wP3RoaXMudW5iaW5kKCJsaXZlIik6dGhpcy5kaWUoYixudWxs
LGMsYSl9LHRyaWdnZXI6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7
Zi5ldmVudC50cmlnZ2VyKGEsYix0aGlzKX0pfSx0cmlnZ2VySGFuZGxlcjpmdW5jdGlvbihhLGIp
e2lmKHRoaXNbMF0pcmV0dXJuIGYuZXZlbnQudHJpZ2dlcihhLGIsdGhpc1swXSwhMCl9LHRvZ2ds
ZTpmdW5jdGlvbihhKXt2YXIgYj1hcmd1bWVudHMsYz1hLmd1aWR8fGYuZ3VpZCsrLGQ9MCxlPWZ1
bmN0aW9uKGMpe3ZhciBlPShmLmRhdGEodGhpcywibGFzdFRvZ2dsZSIrYS5ndWlkKXx8MCklZDtm
LmRhdGEodGhpcywibGFzdFRvZ2dsZSIrYS5ndWlkLGUrMSksYy5wcmV2ZW50RGVmYXVsdCgpO3Jl
dHVybiBiW2VdLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8ITF9O2UuZ3VpZD1jO3doaWxlKGQ8Yi5s
ZW5ndGgpYltkKytdLmd1aWQ9YztyZXR1cm4gdGhpcy5jbGljayhlKX0saG92ZXI6ZnVuY3Rpb24o
YSxiKXtyZXR1cm4gdGhpcy5tb3VzZWVudGVyKGEpLm1vdXNlbGVhdmUoYnx8YSl9fSk7dmFyIE09
e2ZvY3VzOiJmb2N1c2luIixibHVyOiJmb2N1c291dCIsbW91c2VlbnRlcjoibW91c2VvdmVyIixt
b3VzZWxlYXZlOiJtb3VzZW91dCJ9O2YuZWFjaChbImxpdmUiLCJkaWUiXSxmdW5jdGlvbihhLGMp
e2YuZm5bY109ZnVuY3Rpb24oYSxkLGUsZyl7dmFyIGgsaT0wLGosayxsLG09Z3x8dGhpcy5zZWxl
Y3RvcixuPWc/dGhpczpmKHRoaXMuY29udGV4dCk7aWYodHlwZW9mIGE9PSJvYmplY3QiJiYhYS5w
cmV2ZW50RGVmYXVsdCl7Zm9yKHZhciBvIGluIGEpbltjXShvLGQsYVtvXSxtKTtyZXR1cm4gdGhp
c31pZihjPT09ImRpZSImJiFhJiZnJiZnLmNoYXJBdCgwKT09PSIuIil7bi51bmJpbmQoZyk7cmV0
dXJuIHRoaXN9aWYoZD09PSExfHxmLmlzRnVuY3Rpb24oZCkpZT1kfHxFLGQ9YjthPShhfHwiIiku
c3BsaXQoIiAiKTt3aGlsZSgoaD1hW2krK10pIT1udWxsKXtqPXkuZXhlYyhoKSxrPSIiLGomJihr
PWpbMF0saD1oLnJlcGxhY2UoeSwiIikpO2lmKGg9PT0iaG92ZXIiKXthLnB1c2goIm1vdXNlZW50
ZXIiK2ssIm1vdXNlbGVhdmUiK2spO2NvbnRpbnVlfWw9aCxNW2hdPyhhLnB1c2goTVtoXStrKSxo
PWgrayk6aD0oTVtoXXx8aCkraztpZihjPT09ImxpdmUiKWZvcih2YXIgcD0wLHE9bi5sZW5ndGg7
cDxxO3ArKylmLmV2ZW50LmFkZChuW3BdLCJsaXZlLiIrTyhoLG0pLHtkYXRhOmQsc2VsZWN0b3I6
bSxoYW5kbGVyOmUsb3JpZ1R5cGU6aCxvcmlnSGFuZGxlcjplLHByZVR5cGU6bH0pO2Vsc2Ugbi51
bmJpbmQoImxpdmUuIitPKGgsbSksZSl9cmV0dXJuIHRoaXN9fSksZi5lYWNoKCJibHVyIGZvY3Vz
IGZvY3VzaW4gZm9jdXNvdXQgbG9hZCByZXNpemUgc2Nyb2xsIHVubG9hZCBjbGljayBkYmxjbGlj
ayBtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50
ZXIgbW91c2VsZWF2ZSBjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVw
IGVycm9yIi5zcGxpdCgiICIpLGZ1bmN0aW9uKGEsYil7Zi5mbltiXT1mdW5jdGlvbihhLGMpe2M9
PW51bGwmJihjPWEsYT1udWxsKTtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD4wP3RoaXMuYmluZChi
LGEsYyk6dGhpcy50cmlnZ2VyKGIpfSxmLmF0dHJGbiYmKGYuYXR0ckZuW2JdPSEwKX0pLGZ1bmN0
aW9uKCl7ZnVuY3Rpb24gdShhLGIsYyxkLGUsZil7Zm9yKHZhciBnPTAsaD1kLmxlbmd0aDtnPGg7
ZysrKXt2YXIgaT1kW2ddO2lmKGkpe3ZhciBqPSExO2k9aVthXTt3aGlsZShpKXtpZihpLnNpemNh
Y2hlPT09Yyl7aj1kW2kuc2l6c2V0XTticmVha31pZihpLm5vZGVUeXBlPT09MSl7Znx8KGkuc2l6
Y2FjaGU9YyxpLnNpenNldD1nKTtpZih0eXBlb2YgYiE9InN0cmluZyIpe2lmKGk9PT1iKXtqPSEw
O2JyZWFrfX1lbHNlIGlmKGsuZmlsdGVyKGIsW2ldKS5sZW5ndGg+MCl7aj1pO2JyZWFrfX1pPWlb
YV19ZFtnXT1qfX19ZnVuY3Rpb24gdChhLGIsYyxkLGUsZil7Zm9yKHZhciBnPTAsaD1kLmxlbmd0
aDtnPGg7ZysrKXt2YXIgaT1kW2ddO2lmKGkpe3ZhciBqPSExO2k9aVthXTt3aGlsZShpKXtpZihp
LnNpemNhY2hlPT09Yyl7aj1kW2kuc2l6c2V0XTticmVha31pLm5vZGVUeXBlPT09MSYmIWYmJihp
LnNpemNhY2hlPWMsaS5zaXpzZXQ9Zyk7aWYoaS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09Yil7
aj1pO2JyZWFrfWk9aVthXX1kW2ddPWp9fX12YXIgYT0vKCg/OlwoKD86XChbXigpXStcKXxbXigp
XSspK1wpfFxbKD86XFtbXlxbXF1dKlxdfFsnIl1bXiciXSpbJyJdfFteXFtcXSciXSspK1xdfFxc
LnxbXiA+K34sKFxbXFxdKykrfFs+K35dKShccyosXHMqKT8oKD86LnxccnxcbikqKS9nLGQ9MCxl
PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsZz0hMSxoPSEwLGk9L1xcL2csaj0vXFcvO1swLDBd
LnNvcnQoZnVuY3Rpb24oKXtoPSExO3JldHVybiAwfSk7dmFyIGs9ZnVuY3Rpb24oYixkLGYsZyl7
Zj1mfHxbXSxkPWR8fGM7dmFyIGg9ZDtpZihkLm5vZGVUeXBlIT09MSYmZC5ub2RlVHlwZSE9PTkp
cmV0dXJuW107aWYoIWJ8fHR5cGVvZiBiIT0ic3RyaW5nIilyZXR1cm4gZjt2YXIgaSxqLG4sbyxx
LHIscyx0LHU9ITAsdz1rLmlzWE1MKGQpLHg9W10seT1iO2Rve2EuZXhlYygiIiksaT1hLmV4ZWMo
eSk7aWYoaSl7eT1pWzNdLHgucHVzaChpWzFdKTtpZihpWzJdKXtvPWlbM107YnJlYWt9fX13aGls
ZShpKTtpZih4Lmxlbmd0aD4xJiZtLmV4ZWMoYikpaWYoeC5sZW5ndGg9PT0yJiZsLnJlbGF0aXZl
W3hbMF1dKWo9dih4WzBdK3hbMV0sZCk7ZWxzZXtqPWwucmVsYXRpdmVbeFswXV0/W2RdOmsoeC5z
aGlmdCgpLGQpO3doaWxlKHgubGVuZ3RoKWI9eC5zaGlmdCgpLGwucmVsYXRpdmVbYl0mJihiKz14
LnNoaWZ0KCkpLGo9dihiLGopfWVsc2V7IWcmJngubGVuZ3RoPjEmJmQubm9kZVR5cGU9PT05JiYh
dyYmbC5tYXRjaC5JRC50ZXN0KHhbMF0pJiYhbC5tYXRjaC5JRC50ZXN0KHhbeC5sZW5ndGgtMV0p
JiYocT1rLmZpbmQoeC5zaGlmdCgpLGQsdyksZD1xLmV4cHI/ay5maWx0ZXIocS5leHByLHEuc2V0
KVswXTpxLnNldFswXSk7aWYoZCl7cT1nP3tleHByOngucG9wKCksc2V0OnAoZyl9OmsuZmluZCh4
LnBvcCgpLHgubGVuZ3RoPT09MSYmKHhbMF09PT0ifiJ8fHhbMF09PT0iKyIpJiZkLnBhcmVudE5v
ZGU/ZC5wYXJlbnROb2RlOmQsdyksaj1xLmV4cHI/ay5maWx0ZXIocS5leHByLHEuc2V0KTpxLnNl
dCx4Lmxlbmd0aD4wP249cChqKTp1PSExO3doaWxlKHgubGVuZ3RoKXI9eC5wb3AoKSxzPXIsbC5y
ZWxhdGl2ZVtyXT9zPXgucG9wKCk6cj0iIixzPT1udWxsJiYocz1kKSxsLnJlbGF0aXZlW3JdKG4s
cyx3KX1lbHNlIG49eD1bXX1ufHwobj1qKSxufHxrLmVycm9yKHJ8fGIpO2lmKGUuY2FsbChuKT09
PSJbb2JqZWN0IEFycmF5XSIpaWYoIXUpZi5wdXNoLmFwcGx5KGYsbik7ZWxzZSBpZihkJiZkLm5v
ZGVUeXBlPT09MSlmb3IodD0wO25bdF0hPW51bGw7dCsrKW5bdF0mJihuW3RdPT09ITB8fG5bdF0u
bm9kZVR5cGU9PT0xJiZrLmNvbnRhaW5zKGQsblt0XSkpJiZmLnB1c2goalt0XSk7ZWxzZSBmb3Io
dD0wO25bdF0hPW51bGw7dCsrKW5bdF0mJm5bdF0ubm9kZVR5cGU9PT0xJiZmLnB1c2goalt0XSk7
ZWxzZSBwKG4sZik7byYmKGsobyxoLGYsZyksay51bmlxdWVTb3J0KGYpKTtyZXR1cm4gZn07ay51
bmlxdWVTb3J0PWZ1bmN0aW9uKGEpe2lmKHIpe2c9aCxhLnNvcnQocik7aWYoZylmb3IodmFyIGI9
MTtiPGEubGVuZ3RoO2IrKylhW2JdPT09YVtiLTFdJiZhLnNwbGljZShiLS0sMSl9cmV0dXJuIGF9
LGsubWF0Y2hlcz1mdW5jdGlvbihhLGIpe3JldHVybiBrKGEsbnVsbCxudWxsLGIpfSxrLm1hdGNo
ZXNTZWxlY3Rvcj1mdW5jdGlvbihhLGIpe3JldHVybiBrKGIsbnVsbCxudWxsLFthXSkubGVuZ3Ro
PjB9LGsuZmluZD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ7aWYoIWEpcmV0dXJuW107Zm9yKHZhciBl
PTAsZj1sLm9yZGVyLmxlbmd0aDtlPGY7ZSsrKXt2YXIgZyxoPWwub3JkZXJbZV07aWYoZz1sLmxl
ZnRNYXRjaFtoXS5leGVjKGEpKXt2YXIgaj1nWzFdO2cuc3BsaWNlKDEsMSk7aWYoai5zdWJzdHIo
ai5sZW5ndGgtMSkhPT0iXFwiKXtnWzFdPShnWzFdfHwiIikucmVwbGFjZShpLCIiKSxkPWwuZmlu
ZFtoXShnLGIsYyk7aWYoZCE9bnVsbCl7YT1hLnJlcGxhY2UobC5tYXRjaFtoXSwiIik7YnJlYWt9
fX19ZHx8KGQ9dHlwZW9mIGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUhPSJ1bmRlZmluZWQiP2IuZ2V0
RWxlbWVudHNCeVRhZ05hbWUoIioiKTpbXSk7cmV0dXJue3NldDpkLGV4cHI6YX19LGsuZmlsdGVy
PWZ1bmN0aW9uKGEsYyxkLGUpe3ZhciBmLGcsaD1hLGk9W10saj1jLG09YyYmY1swXSYmay5pc1hN
TChjWzBdKTt3aGlsZShhJiZjLmxlbmd0aCl7Zm9yKHZhciBuIGluIGwuZmlsdGVyKWlmKChmPWwu
bGVmdE1hdGNoW25dLmV4ZWMoYSkpIT1udWxsJiZmWzJdKXt2YXIgbyxwLHE9bC5maWx0ZXJbbl0s
cj1mWzFdO2c9ITEsZi5zcGxpY2UoMSwxKTtpZihyLnN1YnN0cihyLmxlbmd0aC0xKT09PSJcXCIp
Y29udGludWU7aj09PWkmJihpPVtdKTtpZihsLnByZUZpbHRlcltuXSl7Zj1sLnByZUZpbHRlcltu
XShmLGosZCxpLGUsbSk7aWYoIWYpZz1vPSEwO2Vsc2UgaWYoZj09PSEwKWNvbnRpbnVlfWlmKGYp
Zm9yKHZhciBzPTA7KHA9altzXSkhPW51bGw7cysrKWlmKHApe289cShwLGYscyxqKTt2YXIgdD1l
XiEhbztkJiZvIT1udWxsP3Q/Zz0hMDpqW3NdPSExOnQmJihpLnB1c2gocCksZz0hMCl9aWYobyE9
PWIpe2R8fChqPWkpLGE9YS5yZXBsYWNlKGwubWF0Y2hbbl0sIiIpO2lmKCFnKXJldHVybltdO2Jy
ZWFrfX1pZihhPT09aClpZihnPT1udWxsKWsuZXJyb3IoYSk7ZWxzZSBicmVhaztoPWF9cmV0dXJu
IGp9LGsuZXJyb3I9ZnVuY3Rpb24oYSl7dGhyb3ciU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQg
ZXhwcmVzc2lvbjogIithfTt2YXIgbD1rLnNlbGVjdG9ycz17b3JkZXI6WyJJRCIsIk5BTUUiLCJU
QUciXSxtYXRjaDp7SUQ6LyMoKD86W1x3XHUwMGMwLVx1RkZGRlwtXXxcXC4pKykvLENMQVNTOi9c
LigoPzpbXHdcdTAwYzAtXHVGRkZGXC1dfFxcLikrKS8sTkFNRTovXFtuYW1lPVsnIl0qKCg/Oltc
d1x1MDBjMC1cdUZGRkZcLV18XFwuKSspWyciXSpcXS8sQVRUUjovXFtccyooKD86W1x3XHUwMGMw
LVx1RkZGRlwtXXxcXC4pKylccyooPzooXFM/PSlccyooPzooWyciXSkoLio/KVwzfCgjPyg/Oltc
d1x1MDBjMC1cdUZGRkZcLV18XFwuKSopfCl8KVxzKlxdLyxUQUc6L14oKD86W1x3XHUwMGMwLVx1
RkZGRlwqXC1dfFxcLikrKS8sQ0hJTEQ6Lzoob25seXxudGh8bGFzdHxmaXJzdCktY2hpbGQoPzpc
KFxzKihldmVufG9kZHwoPzpbK1wtXT9cZCt8KD86WytcLV0/XGQqKT9uXHMqKD86WytcLV1ccypc
ZCspPykpXHMqXCkpPy8sUE9TOi86KG50aHxlcXxndHxsdHxmaXJzdHxsYXN0fGV2ZW58b2RkKSg/
OlwoKFxkKilcKSk/KD89W15cLV18JCkvLFBTRVVETzovOigoPzpbXHdcdTAwYzAtXHVGRkZGXC1d
fFxcLikrKSg/OlwoKFsnIl0/KSgoPzpcKFteXCldK1wpfFteXChcKV0qKSspXDJcKSk/L30sbGVm
dE1hdGNoOnt9LGF0dHJNYXA6eyJjbGFzcyI6ImNsYXNzTmFtZSIsImZvciI6Imh0bWxGb3IifSxh
dHRySGFuZGxlOntocmVmOmZ1bmN0aW9uKGEpe3JldHVybiBhLmdldEF0dHJpYnV0ZSgiaHJlZiIp
fSx0eXBlOmZ1bmN0aW9uKGEpe3JldHVybiBhLmdldEF0dHJpYnV0ZSgidHlwZSIpfX0scmVsYXRp
dmU6eyIrIjpmdW5jdGlvbihhLGIpe3ZhciBjPXR5cGVvZiBiPT0ic3RyaW5nIixkPWMmJiFqLnRl
c3QoYiksZT1jJiYhZDtkJiYoYj1iLnRvTG93ZXJDYXNlKCkpO2Zvcih2YXIgZj0wLGc9YS5sZW5n
dGgsaDtmPGc7ZisrKWlmKGg9YVtmXSl7d2hpbGUoKGg9aC5wcmV2aW91c1NpYmxpbmcpJiZoLm5v
ZGVUeXBlIT09MSk7YVtmXT1lfHxoJiZoLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1iP2h8fCEx
Omg9PT1ifWUmJmsuZmlsdGVyKGIsYSwhMCl9LCI+IjpmdW5jdGlvbihhLGIpe3ZhciBjLGQ9dHlw
ZW9mIGI9PSJzdHJpbmciLGU9MCxmPWEubGVuZ3RoO2lmKGQmJiFqLnRlc3QoYikpe2I9Yi50b0xv
d2VyQ2FzZSgpO2Zvcig7ZTxmO2UrKyl7Yz1hW2VdO2lmKGMpe3ZhciBnPWMucGFyZW50Tm9kZTth
W2VdPWcubm9kZU5hbWUudG9Mb3dlckNhc2UoKT09PWI/ZzohMX19fWVsc2V7Zm9yKDtlPGY7ZSsr
KWM9YVtlXSxjJiYoYVtlXT1kP2MucGFyZW50Tm9kZTpjLnBhcmVudE5vZGU9PT1iKTtkJiZrLmZp
bHRlcihiLGEsITApfX0sIiI6ZnVuY3Rpb24oYSxiLGMpe3ZhciBlLGY9ZCsrLGc9dTt0eXBlb2Yg
Yj09InN0cmluZyImJiFqLnRlc3QoYikmJihiPWIudG9Mb3dlckNhc2UoKSxlPWIsZz10KSxnKCJw
YXJlbnROb2RlIixiLGYsYSxlLGMpfSwifiI6ZnVuY3Rpb24oYSxiLGMpe3ZhciBlLGY9ZCsrLGc9
dTt0eXBlb2YgYj09InN0cmluZyImJiFqLnRlc3QoYikmJihiPWIudG9Mb3dlckNhc2UoKSxlPWIs
Zz10KSxnKCJwcmV2aW91c1NpYmxpbmciLGIsZixhLGUsYyl9fSxmaW5kOntJRDpmdW5jdGlvbihh
LGIsYyl7aWYodHlwZW9mIGIuZ2V0RWxlbWVudEJ5SWQhPSJ1bmRlZmluZWQiJiYhYyl7dmFyIGQ9
Yi5nZXRFbGVtZW50QnlJZChhWzFdKTtyZXR1cm4gZCYmZC5wYXJlbnROb2RlP1tkXTpbXX19LE5B
TUU6ZnVuY3Rpb24oYSxiKXtpZih0eXBlb2YgYi5nZXRFbGVtZW50c0J5TmFtZSE9InVuZGVmaW5l
ZCIpe3ZhciBjPVtdLGQ9Yi5nZXRFbGVtZW50c0J5TmFtZShhWzFdKTtmb3IodmFyIGU9MCxmPWQu
bGVuZ3RoO2U8ZjtlKyspZFtlXS5nZXRBdHRyaWJ1dGUoIm5hbWUiKT09PWFbMV0mJmMucHVzaChk
W2VdKTtyZXR1cm4gYy5sZW5ndGg9PT0wP251bGw6Y319LFRBRzpmdW5jdGlvbihhLGIpe2lmKHR5
cGVvZiBiLmdldEVsZW1lbnRzQnlUYWdOYW1lIT0idW5kZWZpbmVkIilyZXR1cm4gYi5nZXRFbGVt
ZW50c0J5VGFnTmFtZShhWzFdKX19LHByZUZpbHRlcjp7Q0xBU1M6ZnVuY3Rpb24oYSxiLGMsZCxl
LGYpe2E9IiAiK2FbMV0ucmVwbGFjZShpLCIiKSsiICI7aWYoZilyZXR1cm4gYTtmb3IodmFyIGc9
MCxoOyhoPWJbZ10pIT1udWxsO2crKyloJiYoZV4oaC5jbGFzc05hbWUmJigiICIraC5jbGFzc05h
bWUrIiAiKS5yZXBsYWNlKC9bXHRcblxyXS9nLCIgIikuaW5kZXhPZihhKT49MCk/Y3x8ZC5wdXNo
KGgpOmMmJihiW2ddPSExKSk7cmV0dXJuITF9LElEOmZ1bmN0aW9uKGEpe3JldHVybiBhWzFdLnJl
cGxhY2UoaSwiIil9LFRBRzpmdW5jdGlvbihhLGIpe3JldHVybiBhWzFdLnJlcGxhY2UoaSwiIiku
dG9Mb3dlckNhc2UoKX0sQ0hJTEQ6ZnVuY3Rpb24oYSl7aWYoYVsxXT09PSJudGgiKXthWzJdfHxr
LmVycm9yKGFbMF0pLGFbMl09YVsyXS5yZXBsYWNlKC9eXCt8XHMqL2csIiIpO3ZhciBiPS8oLT8p
KFxkKikoPzpuKFsrXC1dP1xkKikpPy8uZXhlYyhhWzJdPT09ImV2ZW4iJiYiMm4ifHxhWzJdPT09
Im9kZCImJiIybisxInx8IS9cRC8udGVzdChhWzJdKSYmIjBuKyIrYVsyXXx8YVsyXSk7YVsyXT1i
WzFdKyhiWzJdfHwxKS0wLGFbM109YlszXS0wfWVsc2UgYVsyXSYmay5lcnJvcihhWzBdKTthWzBd
PWQrKztyZXR1cm4gYX0sQVRUUjpmdW5jdGlvbihhLGIsYyxkLGUsZil7dmFyIGc9YVsxXT1hWzFd
LnJlcGxhY2UoaSwiIik7IWYmJmwuYXR0ck1hcFtnXSYmKGFbMV09bC5hdHRyTWFwW2ddKSxhWzRd
PShhWzRdfHxhWzVdfHwiIikucmVwbGFjZShpLCIiKSxhWzJdPT09In49IiYmKGFbNF09IiAiK2Fb
NF0rIiAiKTtyZXR1cm4gYX0sUFNFVURPOmZ1bmN0aW9uKGIsYyxkLGUsZil7aWYoYlsxXT09PSJu
b3QiKWlmKChhLmV4ZWMoYlszXSl8fCIiKS5sZW5ndGg+MXx8L15cdy8udGVzdChiWzNdKSliWzNd
PWsoYlszXSxudWxsLG51bGwsYyk7ZWxzZXt2YXIgZz1rLmZpbHRlcihiWzNdLGMsZCwhMF5mKTtk
fHxlLnB1c2guYXBwbHkoZSxnKTtyZXR1cm4hMX1lbHNlIGlmKGwubWF0Y2guUE9TLnRlc3QoYlsw
XSl8fGwubWF0Y2guQ0hJTEQudGVzdChiWzBdKSlyZXR1cm4hMDtyZXR1cm4gYn0sUE9TOmZ1bmN0
aW9uKGEpe2EudW5zaGlmdCghMCk7cmV0dXJuIGF9fSxmaWx0ZXJzOntlbmFibGVkOmZ1bmN0aW9u
KGEpe3JldHVybiBhLmRpc2FibGVkPT09ITEmJmEudHlwZSE9PSJoaWRkZW4ifSxkaXNhYmxlZDpm
dW5jdGlvbihhKXtyZXR1cm4gYS5kaXNhYmxlZD09PSEwfSxjaGVja2VkOmZ1bmN0aW9uKGEpe3Jl
dHVybiBhLmNoZWNrZWQ9PT0hMH0sc2VsZWN0ZWQ6ZnVuY3Rpb24oYSl7YS5wYXJlbnROb2RlJiZh
LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtyZXR1cm4gYS5zZWxlY3RlZD09PSEwfSxwYXJlbnQ6
ZnVuY3Rpb24oYSl7cmV0dXJuISFhLmZpcnN0Q2hpbGR9LGVtcHR5OmZ1bmN0aW9uKGEpe3JldHVy
biFhLmZpcnN0Q2hpbGR9LGhhczpmdW5jdGlvbihhLGIsYyl7cmV0dXJuISFrKGNbM10sYSkubGVu
Z3RofSxoZWFkZXI6ZnVuY3Rpb24oYSl7cmV0dXJuL2hcZC9pLnRlc3QoYS5ub2RlTmFtZSl9LHRl
eHQ6ZnVuY3Rpb24oYSl7dmFyIGI9YS5nZXRBdHRyaWJ1dGUoInR5cGUiKSxjPWEudHlwZTtyZXR1
cm4gYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09ImlucHV0IiYmInRleHQiPT09YyYmKGI9PT1j
fHxiPT09bnVsbCl9LHJhZGlvOmZ1bmN0aW9uKGEpe3JldHVybiBhLm5vZGVOYW1lLnRvTG93ZXJD
YXNlKCk9PT0iaW5wdXQiJiYicmFkaW8iPT09YS50eXBlfSxjaGVja2JveDpmdW5jdGlvbihhKXty
ZXR1cm4gYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09ImlucHV0IiYmImNoZWNrYm94Ij09PWEu
dHlwZX0sZmlsZTpmdW5jdGlvbihhKXtyZXR1cm4gYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09
ImlucHV0IiYmImZpbGUiPT09YS50eXBlfSxwYXNzd29yZDpmdW5jdGlvbihhKXtyZXR1cm4gYS5u
b2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09ImlucHV0IiYmInBhc3N3b3JkIj09PWEudHlwZX0sc3Vi
bWl0OmZ1bmN0aW9uKGEpe3ZhciBiPWEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4oYj09
PSJpbnB1dCJ8fGI9PT0iYnV0dG9uIikmJiJzdWJtaXQiPT09YS50eXBlfSxpbWFnZTpmdW5jdGlv
bihhKXtyZXR1cm4gYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09ImlucHV0IiYmImltYWdlIj09
PWEudHlwZX0scmVzZXQ6ZnVuY3Rpb24oYSl7dmFyIGI9YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgp
O3JldHVybihiPT09ImlucHV0Inx8Yj09PSJidXR0b24iKSYmInJlc2V0Ij09PWEudHlwZX0sYnV0
dG9uOmZ1bmN0aW9uKGEpe3ZhciBiPWEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gYj09
PSJpbnB1dCImJiJidXR0b24iPT09YS50eXBlfHxiPT09ImJ1dHRvbiJ9LGlucHV0OmZ1bmN0aW9u
KGEpe3JldHVybi9pbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uL2kudGVzdChhLm5vZGVOYW1l
KX0sZm9jdXM6ZnVuY3Rpb24oYSl7cmV0dXJuIGE9PT1hLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxl
bWVudH19LHNldEZpbHRlcnM6e2ZpcnN0OmZ1bmN0aW9uKGEsYil7cmV0dXJuIGI9PT0wfSxsYXN0
OmZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiBiPT09ZC5sZW5ndGgtMX0sZXZlbjpmdW5jdGlvbihh
LGIpe3JldHVybiBiJTI9PT0wfSxvZGQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYiUyPT09MX0sbHQ6
ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBiPGNbM10tMH0sZ3Q6ZnVuY3Rpb24oYSxiLGMpe3JldHVy
biBiPmNbM10tMH0sbnRoOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gY1szXS0wPT09Yn0sZXE6ZnVu
Y3Rpb24oYSxiLGMpe3JldHVybiBjWzNdLTA9PT1ifX0sZmlsdGVyOntQU0VVRE86ZnVuY3Rpb24o
YSxiLGMsZCl7dmFyIGU9YlsxXSxmPWwuZmlsdGVyc1tlXTtpZihmKXJldHVybiBmKGEsYyxiLGQp
O2lmKGU9PT0iY29udGFpbnMiKXJldHVybihhLnRleHRDb250ZW50fHxhLmlubmVyVGV4dHx8ay5n
ZXRUZXh0KFthXSl8fCIiKS5pbmRleE9mKGJbM10pPj0wO2lmKGU9PT0ibm90Iil7dmFyIGc9Ylsz
XTtmb3IodmFyIGg9MCxpPWcubGVuZ3RoO2g8aTtoKyspaWYoZ1toXT09PWEpcmV0dXJuITE7cmV0
dXJuITB9ay5lcnJvcihlKX0sQ0hJTEQ6ZnVuY3Rpb24oYSxiKXt2YXIgYz1iWzFdLGQ9YTtzd2l0
Y2goYyl7Y2FzZSJvbmx5IjpjYXNlImZpcnN0Ijp3aGlsZShkPWQucHJldmlvdXNTaWJsaW5nKWlm
KGQubm9kZVR5cGU9PT0xKXJldHVybiExO2lmKGM9PT0iZmlyc3QiKXJldHVybiEwO2Q9YTtjYXNl
Imxhc3QiOndoaWxlKGQ9ZC5uZXh0U2libGluZylpZihkLm5vZGVUeXBlPT09MSlyZXR1cm4hMTty
ZXR1cm4hMDtjYXNlIm50aCI6dmFyIGU9YlsyXSxmPWJbM107aWYoZT09PTEmJmY9PT0wKXJldHVy
biEwO3ZhciBnPWJbMF0saD1hLnBhcmVudE5vZGU7aWYoaCYmKGguc2l6Y2FjaGUhPT1nfHwhYS5u
b2RlSW5kZXgpKXt2YXIgaT0wO2ZvcihkPWguZmlyc3RDaGlsZDtkO2Q9ZC5uZXh0U2libGluZylk
Lm5vZGVUeXBlPT09MSYmKGQubm9kZUluZGV4PSsraSk7aC5zaXpjYWNoZT1nfXZhciBqPWEubm9k
ZUluZGV4LWY7cmV0dXJuIGU9PT0wP2o9PT0wOmolZT09PTAmJmovZT49MH19LElEOmZ1bmN0aW9u
KGEsYil7cmV0dXJuIGEubm9kZVR5cGU9PT0xJiZhLmdldEF0dHJpYnV0ZSgiaWQiKT09PWJ9LFRB
RzpmdW5jdGlvbihhLGIpe3JldHVybiBiPT09IioiJiZhLm5vZGVUeXBlPT09MXx8YS5ub2RlTmFt
ZS50b0xvd2VyQ2FzZSgpPT09Yn0sQ0xBU1M6ZnVuY3Rpb24oYSxiKXtyZXR1cm4oIiAiKyhhLmNs
YXNzTmFtZXx8YS5nZXRBdHRyaWJ1dGUoImNsYXNzIikpKyIgIikuaW5kZXhPZihiKT4tMX0sQVRU
UjpmdW5jdGlvbihhLGIpe3ZhciBjPWJbMV0sZD1sLmF0dHJIYW5kbGVbY10/bC5hdHRySGFuZGxl
W2NdKGEpOmFbY10hPW51bGw/YVtjXTphLmdldEF0dHJpYnV0ZShjKSxlPWQrIiIsZj1iWzJdLGc9
Yls0XTtyZXR1cm4gZD09bnVsbD9mPT09IiE9IjpmPT09Ij0iP2U9PT1nOmY9PT0iKj0iP2UuaW5k
ZXhPZihnKT49MDpmPT09In49Ij8oIiAiK2UrIiAiKS5pbmRleE9mKGcpPj0wOmc/Zj09PSIhPSI/
ZSE9PWc6Zj09PSJePSI/ZS5pbmRleE9mKGcpPT09MDpmPT09IiQ9Ij9lLnN1YnN0cihlLmxlbmd0
aC1nLmxlbmd0aCk9PT1nOmY9PT0ifD0iP2U9PT1nfHxlLnN1YnN0cigwLGcubGVuZ3RoKzEpPT09
ZysiLSI6ITE6ZSYmZCE9PSExfSxQT1M6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9YlsyXSxmPWwu
c2V0RmlsdGVyc1tlXTtpZihmKXJldHVybiBmKGEsYyxiLGQpfX19LG09bC5tYXRjaC5QT1Msbj1m
dW5jdGlvbihhLGIpe3JldHVybiJcXCIrKGItMCsxKX07Zm9yKHZhciBvIGluIGwubWF0Y2gpbC5t
YXRjaFtvXT1uZXcgUmVnRXhwKGwubWF0Y2hbb10uc291cmNlKy8oPyFbXlxbXSpcXSkoPyFbXlwo
XSpcKSkvLnNvdXJjZSksbC5sZWZ0TWF0Y2hbb109bmV3IFJlZ0V4cCgvKF4oPzoufFxyfFxuKSo/
KS8uc291cmNlK2wubWF0Y2hbb10uc291cmNlLnJlcGxhY2UoL1xcKFxkKykvZyxuKSk7dmFyIHA9
ZnVuY3Rpb24oYSxiKXthPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEsMCk7aWYoYil7Yi5w
dXNoLmFwcGx5KGIsYSk7cmV0dXJuIGJ9cmV0dXJuIGF9O3RyeXtBcnJheS5wcm90b3R5cGUuc2xp
Y2UuY2FsbChjLmRvY3VtZW50RWxlbWVudC5jaGlsZE5vZGVzLDApWzBdLm5vZGVUeXBlfWNhdGNo
KHEpe3A9ZnVuY3Rpb24oYSxiKXt2YXIgYz0wLGQ9Ynx8W107aWYoZS5jYWxsKGEpPT09IltvYmpl
Y3QgQXJyYXldIilBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShkLGEpO2Vsc2UgaWYodHlwZW9m
IGEubGVuZ3RoPT0ibnVtYmVyIilmb3IodmFyIGY9YS5sZW5ndGg7YzxmO2MrKylkLnB1c2goYVtj
XSk7ZWxzZSBmb3IoO2FbY107YysrKWQucHVzaChhW2NdKTtyZXR1cm4gZH19dmFyIHIscztjLmRv
Y3VtZW50RWxlbWVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbj9yPWZ1bmN0aW9uKGEsYil7aWYo
YT09PWIpe2c9ITA7cmV0dXJuIDB9aWYoIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb258fCFiLmNv
bXBhcmVEb2N1bWVudFBvc2l0aW9uKXJldHVybiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uPy0x
OjE7cmV0dXJuIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikmND8tMToxfToocj1mdW5jdGlv
bihhLGIpe2lmKGE9PT1iKXtnPSEwO3JldHVybiAwfWlmKGEuc291cmNlSW5kZXgmJmIuc291cmNl
SW5kZXgpcmV0dXJuIGEuc291cmNlSW5kZXgtYi5zb3VyY2VJbmRleDt2YXIgYyxkLGU9W10sZj1b
XSxoPWEucGFyZW50Tm9kZSxpPWIucGFyZW50Tm9kZSxqPWg7aWYoaD09PWkpcmV0dXJuIHMoYSxi
KTtpZighaClyZXR1cm4tMTtpZighaSlyZXR1cm4gMTt3aGlsZShqKWUudW5zaGlmdChqKSxqPWou
cGFyZW50Tm9kZTtqPWk7d2hpbGUoailmLnVuc2hpZnQoaiksaj1qLnBhcmVudE5vZGU7Yz1lLmxl
bmd0aCxkPWYubGVuZ3RoO2Zvcih2YXIgaz0wO2s8YyYmazxkO2srKylpZihlW2tdIT09ZltrXSly
ZXR1cm4gcyhlW2tdLGZba10pO3JldHVybiBrPT09Yz9zKGEsZltrXSwtMSk6cyhlW2tdLGIsMSl9
LHM9ZnVuY3Rpb24oYSxiLGMpe2lmKGE9PT1iKXJldHVybiBjO3ZhciBkPWEubmV4dFNpYmxpbmc7
d2hpbGUoZCl7aWYoZD09PWIpcmV0dXJuLTE7ZD1kLm5leHRTaWJsaW5nfXJldHVybiAxfSksay5n
ZXRUZXh0PWZ1bmN0aW9uKGEpe3ZhciBiPSIiLGM7Zm9yKHZhciBkPTA7YVtkXTtkKyspYz1hW2Rd
LGMubm9kZVR5cGU9PT0zfHxjLm5vZGVUeXBlPT09ND9iKz1jLm5vZGVWYWx1ZTpjLm5vZGVUeXBl
IT09OCYmKGIrPWsuZ2V0VGV4dChjLmNoaWxkTm9kZXMpKTtyZXR1cm4gYn0sZnVuY3Rpb24oKXt2
YXIgYT1jLmNyZWF0ZUVsZW1lbnQoImRpdiIpLGQ9InNjcmlwdCIrKG5ldyBEYXRlKS5nZXRUaW1l
KCksZT1jLmRvY3VtZW50RWxlbWVudDthLmlubmVySFRNTD0iPGEgbmFtZT0nIitkKyInLz4iLGUu
aW5zZXJ0QmVmb3JlKGEsZS5maXJzdENoaWxkKSxjLmdldEVsZW1lbnRCeUlkKGQpJiYobC5maW5k
LklEPWZ1bmN0aW9uKGEsYyxkKXtpZih0eXBlb2YgYy5nZXRFbGVtZW50QnlJZCE9InVuZGVmaW5l
ZCImJiFkKXt2YXIgZT1jLmdldEVsZW1lbnRCeUlkKGFbMV0pO3JldHVybiBlP2UuaWQ9PT1hWzFd
fHx0eXBlb2YgZS5nZXRBdHRyaWJ1dGVOb2RlIT0idW5kZWZpbmVkIiYmZS5nZXRBdHRyaWJ1dGVO
b2RlKCJpZCIpLm5vZGVWYWx1ZT09PWFbMV0/W2VdOmI6W119fSxsLmZpbHRlci5JRD1mdW5jdGlv
bihhLGIpe3ZhciBjPXR5cGVvZiBhLmdldEF0dHJpYnV0ZU5vZGUhPSJ1bmRlZmluZWQiJiZhLmdl
dEF0dHJpYnV0ZU5vZGUoImlkIik7cmV0dXJuIGEubm9kZVR5cGU9PT0xJiZjJiZjLm5vZGVWYWx1
ZT09PWJ9KSxlLnJlbW92ZUNoaWxkKGEpLGU9YT1udWxsfSgpLGZ1bmN0aW9uKCl7dmFyIGE9Yy5j
cmVhdGVFbGVtZW50KCJkaXYiKTthLmFwcGVuZENoaWxkKGMuY3JlYXRlQ29tbWVudCgiIikpLGEu
Z2V0RWxlbWVudHNCeVRhZ05hbWUoIioiKS5sZW5ndGg+MCYmKGwuZmluZC5UQUc9ZnVuY3Rpb24o
YSxiKXt2YXIgYz1iLmdldEVsZW1lbnRzQnlUYWdOYW1lKGFbMV0pO2lmKGFbMV09PT0iKiIpe3Zh
ciBkPVtdO2Zvcih2YXIgZT0wO2NbZV07ZSsrKWNbZV0ubm9kZVR5cGU9PT0xJiZkLnB1c2goY1tl
XSk7Yz1kfXJldHVybiBjfSksYS5pbm5lckhUTUw9IjxhIGhyZWY9JyMnPjwvYT4iLGEuZmlyc3RD
aGlsZCYmdHlwZW9mIGEuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUhPSJ1bmRlZmluZWQiJiZhLmZp
cnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCJocmVmIikhPT0iIyImJihsLmF0dHJIYW5kbGUuaHJlZj1m
dW5jdGlvbihhKXtyZXR1cm4gYS5nZXRBdHRyaWJ1dGUoImhyZWYiLDIpfSksYT1udWxsfSgpLGMu
cXVlcnlTZWxlY3RvckFsbCYmZnVuY3Rpb24oKXt2YXIgYT1rLGI9Yy5jcmVhdGVFbGVtZW50KCJk
aXYiKSxkPSJfX3NpenpsZV9fIjtiLmlubmVySFRNTD0iPHAgY2xhc3M9J1RFU1QnPjwvcD4iO2lm
KCFiLnF1ZXJ5U2VsZWN0b3JBbGx8fGIucXVlcnlTZWxlY3RvckFsbCgiLlRFU1QiKS5sZW5ndGgh
PT0wKXtrPWZ1bmN0aW9uKGIsZSxmLGcpe2U9ZXx8YztpZighZyYmIWsuaXNYTUwoZSkpe3ZhciBo
PS9eKFx3KyQpfF5cLihbXHdcLV0rJCl8XiMoW1x3XC1dKyQpLy5leGVjKGIpO2lmKGgmJihlLm5v
ZGVUeXBlPT09MXx8ZS5ub2RlVHlwZT09PTkpKXtpZihoWzFdKXJldHVybiBwKGUuZ2V0RWxlbWVu
dHNCeVRhZ05hbWUoYiksZik7aWYoaFsyXSYmbC5maW5kLkNMQVNTJiZlLmdldEVsZW1lbnRzQnlD
bGFzc05hbWUpcmV0dXJuIHAoZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGhbMl0pLGYpfWlmKGUu
bm9kZVR5cGU9PT05KXtpZihiPT09ImJvZHkiJiZlLmJvZHkpcmV0dXJuIHAoW2UuYm9keV0sZik7
aWYoaCYmaFszXSl7dmFyIGk9ZS5nZXRFbGVtZW50QnlJZChoWzNdKTtpZighaXx8IWkucGFyZW50
Tm9kZSlyZXR1cm4gcChbXSxmKTtpZihpLmlkPT09aFszXSlyZXR1cm4gcChbaV0sZil9dHJ5e3Jl
dHVybiBwKGUucXVlcnlTZWxlY3RvckFsbChiKSxmKX1jYXRjaChqKXt9fWVsc2UgaWYoZS5ub2Rl
VHlwZT09PTEmJmUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSE9PSJvYmplY3QiKXt2YXIgbT1lLG49
ZS5nZXRBdHRyaWJ1dGUoImlkIiksbz1ufHxkLHE9ZS5wYXJlbnROb2RlLHI9L15ccypbK35dLy50
ZXN0KGIpO24/bz1vLnJlcGxhY2UoLycvZywiXFwkJiIpOmUuc2V0QXR0cmlidXRlKCJpZCIsbyks
ciYmcSYmKGU9ZS5wYXJlbnROb2RlKTt0cnl7aWYoIXJ8fHEpcmV0dXJuIHAoZS5xdWVyeVNlbGVj
dG9yQWxsKCJbaWQ9JyIrbysiJ10gIitiKSxmKX1jYXRjaChzKXt9ZmluYWxseXtufHxtLnJlbW92
ZUF0dHJpYnV0ZSgiaWQiKX19fXJldHVybiBhKGIsZSxmLGcpfTtmb3IodmFyIGUgaW4gYSlrW2Vd
PWFbZV07Yj1udWxsfX0oKSxmdW5jdGlvbigpe3ZhciBhPWMuZG9jdW1lbnRFbGVtZW50LGI9YS5t
YXRjaGVzU2VsZWN0b3J8fGEubW96TWF0Y2hlc1NlbGVjdG9yfHxhLndlYmtpdE1hdGNoZXNTZWxl
Y3Rvcnx8YS5tc01hdGNoZXNTZWxlY3RvcjtpZihiKXt2YXIgZD0hYi5jYWxsKGMuY3JlYXRlRWxl
bWVudCgiZGl2IiksImRpdiIpLGU9ITE7dHJ5e2IuY2FsbChjLmRvY3VtZW50RWxlbWVudCwiW3Rl
c3QhPScnXTpzaXp6bGUiKX1jYXRjaChmKXtlPSEwfWsubWF0Y2hlc1NlbGVjdG9yPWZ1bmN0aW9u
KGEsYyl7Yz1jLnJlcGxhY2UoL1w9XHMqKFteJyJcXV0qKVxzKlxdL2csIj0nJDEnXSIpO2lmKCFr
LmlzWE1MKGEpKXRyeXtpZihlfHwhbC5tYXRjaC5QU0VVRE8udGVzdChjKSYmIS8hPS8udGVzdChj
KSl7dmFyIGY9Yi5jYWxsKGEsYyk7aWYoZnx8IWR8fGEuZG9jdW1lbnQmJmEuZG9jdW1lbnQubm9k
ZVR5cGUhPT0xMSlyZXR1cm4gZn19Y2F0Y2goZyl7fXJldHVybiBrKGMsbnVsbCxudWxsLFthXSku
bGVuZ3RoPjB9fX0oKSxmdW5jdGlvbigpe3ZhciBhPWMuY3JlYXRlRWxlbWVudCgiZGl2Iik7YS5p
bm5lckhUTUw9IjxkaXYgY2xhc3M9J3Rlc3QgZSc+PC9kaXY+PGRpdiBjbGFzcz0ndGVzdCc+PC9k
aXY+IjtpZighIWEuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSYmYS5nZXRFbGVtZW50c0J5Q2xhc3NO
YW1lKCJlIikubGVuZ3RoIT09MCl7YS5sYXN0Q2hpbGQuY2xhc3NOYW1lPSJlIjtpZihhLmdldEVs
ZW1lbnRzQnlDbGFzc05hbWUoImUiKS5sZW5ndGg9PT0xKXJldHVybjtsLm9yZGVyLnNwbGljZSgx
LDAsIkNMQVNTIiksbC5maW5kLkNMQVNTPWZ1bmN0aW9uKGEsYixjKXtpZih0eXBlb2YgYi5nZXRF
bGVtZW50c0J5Q2xhc3NOYW1lIT0idW5kZWZpbmVkIiYmIWMpcmV0dXJuIGIuZ2V0RWxlbWVudHNC
eUNsYXNzTmFtZShhWzFdKX0sYT1udWxsfX0oKSxjLmRvY3VtZW50RWxlbWVudC5jb250YWlucz9r
LmNvbnRhaW5zPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGEhPT1iJiYoYS5jb250YWlucz9hLmNvbnRh
aW5zKGIpOiEwKX06Yy5kb2N1bWVudEVsZW1lbnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24/ay5j
b250YWlucz1mdW5jdGlvbihhLGIpe3JldHVybiEhKGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24o
YikmMTYpfTprLmNvbnRhaW5zPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGsuaXNYTUw9ZnVuY3Rpb24o
YSl7dmFyIGI9KGE/YS5vd25lckRvY3VtZW50fHxhOjApLmRvY3VtZW50RWxlbWVudDtyZXR1cm4g
Yj9iLm5vZGVOYW1lIT09IkhUTUwiOiExfTt2YXIgdj1mdW5jdGlvbihhLGIpe3ZhciBjLGQ9W10s
ZT0iIixmPWIubm9kZVR5cGU/W2JdOmI7d2hpbGUoYz1sLm1hdGNoLlBTRVVETy5leGVjKGEpKWUr
PWNbMF0sYT1hLnJlcGxhY2UobC5tYXRjaC5QU0VVRE8sIiIpO2E9bC5yZWxhdGl2ZVthXT9hKyIq
IjphO2Zvcih2YXIgZz0wLGg9Zi5sZW5ndGg7ZzxoO2crKylrKGEsZltnXSxkKTtyZXR1cm4gay5m
aWx0ZXIoZSxkKX07Zi5maW5kPWssZi5leHByPWsuc2VsZWN0b3JzLGYuZXhwclsiOiJdPWYuZXhw
ci5maWx0ZXJzLGYudW5pcXVlPWsudW5pcXVlU29ydCxmLnRleHQ9ay5nZXRUZXh0LGYuaXNYTUxE
b2M9ay5pc1hNTCxmLmNvbnRhaW5zPWsuY29udGFpbnN9KCk7dmFyIFA9L1VudGlsJC8sUT0vXig/
OnBhcmVudHN8cHJldlVudGlsfHByZXZBbGwpLyxSPS8sLyxTPS9eLlteOiNcW1wuLF0qJC8sVD1B
cnJheS5wcm90b3R5cGUuc2xpY2UsVT1mLmV4cHIubWF0Y2guUE9TLFY9e2NoaWxkcmVuOiEwLGNv
bnRlbnRzOiEwLG5leHQ6ITAscHJldjohMH07Zi5mbi5leHRlbmQoe2ZpbmQ6ZnVuY3Rpb24oYSl7
dmFyIGI9dGhpcyxjLGQ7aWYodHlwZW9mIGEhPSJzdHJpbmciKXJldHVybiBmKGEpLmZpbHRlcihm
dW5jdGlvbigpe2ZvcihjPTAsZD1iLmxlbmd0aDtjPGQ7YysrKWlmKGYuY29udGFpbnMoYltjXSx0
aGlzKSlyZXR1cm4hMH0pO3ZhciBlPXRoaXMucHVzaFN0YWNrKCIiLCJmaW5kIixhKSxnLGgsaTtm
b3IoYz0wLGQ9dGhpcy5sZW5ndGg7YzxkO2MrKyl7Zz1lLmxlbmd0aCxmLmZpbmQoYSx0aGlzW2Nd
LGUpO2lmKGM+MClmb3IoaD1nO2g8ZS5sZW5ndGg7aCsrKWZvcihpPTA7aTxnO2krKylpZihlW2ld
PT09ZVtoXSl7ZS5zcGxpY2UoaC0tLDEpO2JyZWFrfX1yZXR1cm4gZX0saGFzOmZ1bmN0aW9uKGEp
e3ZhciBiPWYoYSk7cmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKCl7Zm9yKHZhciBhPTAsYz1i
Lmxlbmd0aDthPGM7YSsrKWlmKGYuY29udGFpbnModGhpcyxiW2FdKSlyZXR1cm4hMH0pfSxub3Q6
ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKFgodGhpcyxhLCExKSwibm90IixhKX0s
ZmlsdGVyOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnB1c2hTdGFjayhYKHRoaXMsYSwhMCksImZp
bHRlciIsYSl9LGlzOmZ1bmN0aW9uKGEpe3JldHVybiEhYSYmKHR5cGVvZiBhPT0ic3RyaW5nIj9m
LmZpbHRlcihhLHRoaXMpLmxlbmd0aD4wOnRoaXMuZmlsdGVyKGEpLmxlbmd0aD4wKX0sY2xvc2Vz
dDpmdW5jdGlvbihhLGIpe3ZhciBjPVtdLGQsZSxnPXRoaXNbMF07aWYoZi5pc0FycmF5KGEpKXt2
YXIgaCxpLGo9e30saz0xO2lmKGcmJmEubGVuZ3RoKXtmb3IoZD0wLGU9YS5sZW5ndGg7ZDxlO2Qr
KylpPWFbZF0saltpXXx8KGpbaV09VS50ZXN0KGkpP2YoaSxifHx0aGlzLmNvbnRleHQpOmkpO3do
aWxlKGcmJmcub3duZXJEb2N1bWVudCYmZyE9PWIpe2ZvcihpIGluIGopaD1qW2ldLChoLmpxdWVy
eT9oLmluZGV4KGcpPi0xOmYoZykuaXMoaCkpJiZjLnB1c2goe3NlbGVjdG9yOmksZWxlbTpnLGxl
dmVsOmt9KTtnPWcucGFyZW50Tm9kZSxrKyt9fXJldHVybiBjfXZhciBsPVUudGVzdChhKXx8dHlw
ZW9mIGEhPSJzdHJpbmciP2YoYSxifHx0aGlzLmNvbnRleHQpOjA7Zm9yKGQ9MCxlPXRoaXMubGVu
Z3RoO2Q8ZTtkKyspe2c9dGhpc1tkXTt3aGlsZShnKXtpZihsP2wuaW5kZXgoZyk+LTE6Zi5maW5k
Lm1hdGNoZXNTZWxlY3RvcihnLGEpKXtjLnB1c2goZyk7YnJlYWt9Zz1nLnBhcmVudE5vZGU7aWYo
IWd8fCFnLm93bmVyRG9jdW1lbnR8fGc9PT1ifHxnLm5vZGVUeXBlPT09MTEpYnJlYWt9fWM9Yy5s
ZW5ndGg+MT9mLnVuaXF1ZShjKTpjO3JldHVybiB0aGlzLnB1c2hTdGFjayhjLCJjbG9zZXN0Iixh
KX0saW5kZXg6ZnVuY3Rpb24oYSl7aWYoIWF8fHR5cGVvZiBhPT0ic3RyaW5nIilyZXR1cm4gZi5p
bkFycmF5KHRoaXNbMF0sYT9mKGEpOnRoaXMucGFyZW50KCkuY2hpbGRyZW4oKSk7cmV0dXJuIGYu
aW5BcnJheShhLmpxdWVyeT9hWzBdOmEsdGhpcyl9LGFkZDpmdW5jdGlvbihhLGIpe3ZhciBjPXR5
cGVvZiBhPT0ic3RyaW5nIj9mKGEsYik6Zi5tYWtlQXJyYXkoYSYmYS5ub2RlVHlwZT9bYV06YSks
ZD1mLm1lcmdlKHRoaXMuZ2V0KCksYyk7cmV0dXJuIHRoaXMucHVzaFN0YWNrKFcoY1swXSl8fFco
ZFswXSk/ZDpmLnVuaXF1ZShkKSl9LGFuZFNlbGY6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hZGQo
dGhpcy5wcmV2T2JqZWN0KX19KSxmLmVhY2goe3BhcmVudDpmdW5jdGlvbihhKXt2YXIgYj1hLnBh
cmVudE5vZGU7cmV0dXJuIGImJmIubm9kZVR5cGUhPT0xMT9iOm51bGx9LHBhcmVudHM6ZnVuY3Rp
b24oYSl7cmV0dXJuIGYuZGlyKGEsInBhcmVudE5vZGUiKX0scGFyZW50c1VudGlsOmZ1bmN0aW9u
KGEsYixjKXtyZXR1cm4gZi5kaXIoYSwicGFyZW50Tm9kZSIsYyl9LG5leHQ6ZnVuY3Rpb24oYSl7
cmV0dXJuIGYubnRoKGEsMiwibmV4dFNpYmxpbmciKX0scHJldjpmdW5jdGlvbihhKXtyZXR1cm4g
Zi5udGgoYSwyLCJwcmV2aW91c1NpYmxpbmciKX0sbmV4dEFsbDpmdW5jdGlvbihhKXtyZXR1cm4g
Zi5kaXIoYSwibmV4dFNpYmxpbmciKX0scHJldkFsbDpmdW5jdGlvbihhKXtyZXR1cm4gZi5kaXIo
YSwicHJldmlvdXNTaWJsaW5nIil9LG5leHRVbnRpbDpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIGYu
ZGlyKGEsIm5leHRTaWJsaW5nIixjKX0scHJldlVudGlsOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4g
Zi5kaXIoYSwicHJldmlvdXNTaWJsaW5nIixjKX0sc2libGluZ3M6ZnVuY3Rpb24oYSl7cmV0dXJu
IGYuc2libGluZyhhLnBhcmVudE5vZGUuZmlyc3RDaGlsZCxhKX0sY2hpbGRyZW46ZnVuY3Rpb24o
YSl7cmV0dXJuIGYuc2libGluZyhhLmZpcnN0Q2hpbGQpfSxjb250ZW50czpmdW5jdGlvbihhKXty
ZXR1cm4gZi5ub2RlTmFtZShhLCJpZnJhbWUiKT9hLmNvbnRlbnREb2N1bWVudHx8YS5jb250ZW50
V2luZG93LmRvY3VtZW50OmYubWFrZUFycmF5KGEuY2hpbGROb2Rlcyl9fSxmdW5jdGlvbihhLGIp
e2YuZm5bYV09ZnVuY3Rpb24oYyxkKXt2YXIgZT1mLm1hcCh0aGlzLGIsYyksZz1ULmNhbGwoYXJn
dW1lbnRzKTtQLnRlc3QoYSl8fChkPWMpLGQmJnR5cGVvZiBkPT0ic3RyaW5nIiYmKGU9Zi5maWx0
ZXIoZCxlKSksZT10aGlzLmxlbmd0aD4xJiYhVlthXT9mLnVuaXF1ZShlKTplLCh0aGlzLmxlbmd0
aD4xfHxSLnRlc3QoZCkpJiZRLnRlc3QoYSkmJihlPWUucmV2ZXJzZSgpKTtyZXR1cm4gdGhpcy5w
dXNoU3RhY2soZSxhLGcuam9pbigiLCIpKX19KSxmLmV4dGVuZCh7ZmlsdGVyOmZ1bmN0aW9uKGEs
YixjKXtjJiYoYT0iOm5vdCgiK2ErIikiKTtyZXR1cm4gYi5sZW5ndGg9PT0xP2YuZmluZC5tYXRj
aGVzU2VsZWN0b3IoYlswXSxhKT9bYlswXV06W106Zi5maW5kLm1hdGNoZXMoYSxiKX0sZGlyOmZ1
bmN0aW9uKGEsYyxkKXt2YXIgZT1bXSxnPWFbY107d2hpbGUoZyYmZy5ub2RlVHlwZSE9PTkmJihk
PT09Ynx8Zy5ub2RlVHlwZSE9PTF8fCFmKGcpLmlzKGQpKSlnLm5vZGVUeXBlPT09MSYmZS5wdXNo
KGcpLGc9Z1tjXTtyZXR1cm4gZX0sbnRoOmZ1bmN0aW9uKGEsYixjLGQpe2I9Ynx8MTt2YXIgZT0w
O2Zvcig7YTthPWFbY10paWYoYS5ub2RlVHlwZT09PTEmJisrZT09PWIpYnJlYWs7cmV0dXJuIGF9
LHNpYmxpbmc6ZnVuY3Rpb24oYSxiKXt2YXIgYz1bXTtmb3IoO2E7YT1hLm5leHRTaWJsaW5nKWEu
bm9kZVR5cGU9PT0xJiZhIT09YiYmYy5wdXNoKGEpO3JldHVybiBjfX0pO3ZhciBZPS8galF1ZXJ5
XGQrPSIoPzpcZCt8bnVsbCkiL2csWj0vXlxzKy8sJD0vPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhy
fGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbXHc6XSspW14+XSopXC8+L2lnLF89LzwoW1x3
Ol0rKS8sYmE9Lzx0Ym9keS9pLGJiPS88fCYjP1x3KzsvLGJjPS88KD86c2NyaXB0fG9iamVjdHxl
bWJlZHxvcHRpb258c3R5bGUpL2ksYmQ9L2NoZWNrZWRccyooPzpbXj1dfD1ccyouY2hlY2tlZC4p
L2ksYmU9L1wvKGphdmF8ZWNtYSlzY3JpcHQvaSxiZj0vXlxzKjwhKD86XFtDREFUQVxbfFwtXC0p
LyxiZz17b3B0aW9uOlsxLCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+IiwiPC9zZWxlY3Q+
Il0sbGVnZW5kOlsxLCI8ZmllbGRzZXQ+IiwiPC9maWVsZHNldD4iXSx0aGVhZDpbMSwiPHRhYmxl
PiIsIjwvdGFibGU+Il0sdHI6WzIsIjx0YWJsZT48dGJvZHk+IiwiPC90Ym9keT48L3RhYmxlPiJd
LHRkOlszLCI8dGFibGU+PHRib2R5Pjx0cj4iLCI8L3RyPjwvdGJvZHk+PC90YWJsZT4iXSxjb2w6
WzIsIjx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+IiwiPC9jb2xncm91cD48L3RhYmxl
PiJdLGFyZWE6WzEsIjxtYXA+IiwiPC9tYXA+Il0sX2RlZmF1bHQ6WzAsIiIsIiJdfTtiZy5vcHRn
cm91cD1iZy5vcHRpb24sYmcudGJvZHk9YmcudGZvb3Q9YmcuY29sZ3JvdXA9YmcuY2FwdGlvbj1i
Zy50aGVhZCxiZy50aD1iZy50ZCxmLnN1cHBvcnQuaHRtbFNlcmlhbGl6ZXx8KGJnLl9kZWZhdWx0
PVsxLCJkaXY8ZGl2PiIsIjwvZGl2PiJdKSxmLmZuLmV4dGVuZCh7dGV4dDpmdW5jdGlvbihhKXtp
ZihmLmlzRnVuY3Rpb24oYSkpcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihiKXt2YXIgYz1mKHRo
aXMpO2MudGV4dChhLmNhbGwodGhpcyxiLGMudGV4dCgpKSl9KTtpZih0eXBlb2YgYSE9Im9iamVj
dCImJmEhPT1iKXJldHVybiB0aGlzLmVtcHR5KCkuYXBwZW5kKCh0aGlzWzBdJiZ0aGlzWzBdLm93
bmVyRG9jdW1lbnR8fGMpLmNyZWF0ZVRleHROb2RlKGEpKTtyZXR1cm4gZi50ZXh0KHRoaXMpfSx3
cmFwQWxsOmZ1bmN0aW9uKGEpe2lmKGYuaXNGdW5jdGlvbihhKSlyZXR1cm4gdGhpcy5lYWNoKGZ1
bmN0aW9uKGIpe2YodGhpcykud3JhcEFsbChhLmNhbGwodGhpcyxiKSl9KTtpZih0aGlzWzBdKXt2
YXIgYj1mKGEsdGhpc1swXS5vd25lckRvY3VtZW50KS5lcSgwKS5jbG9uZSghMCk7dGhpc1swXS5w
YXJlbnROb2RlJiZiLmluc2VydEJlZm9yZSh0aGlzWzBdKSxiLm1hcChmdW5jdGlvbigpe3ZhciBh
PXRoaXM7d2hpbGUoYS5maXJzdENoaWxkJiZhLmZpcnN0Q2hpbGQubm9kZVR5cGU9PT0xKWE9YS5m
aXJzdENoaWxkO3JldHVybiBhfSkuYXBwZW5kKHRoaXMpfXJldHVybiB0aGlzfSx3cmFwSW5uZXI6
ZnVuY3Rpb24oYSl7aWYoZi5pc0Z1bmN0aW9uKGEpKXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24o
Yil7Zih0aGlzKS53cmFwSW5uZXIoYS5jYWxsKHRoaXMsYikpfSk7cmV0dXJuIHRoaXMuZWFjaChm
dW5jdGlvbigpe3ZhciBiPWYodGhpcyksYz1iLmNvbnRlbnRzKCk7Yy5sZW5ndGg/Yy53cmFwQWxs
KGEpOmIuYXBwZW5kKGEpfSl9LHdyYXA6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZWFjaChmdW5j
dGlvbigpe2YodGhpcykud3JhcEFsbChhKX0pfSx1bndyYXA6ZnVuY3Rpb24oKXtyZXR1cm4gdGhp
cy5wYXJlbnQoKS5lYWNoKGZ1bmN0aW9uKCl7Zi5ub2RlTmFtZSh0aGlzLCJib2R5Iil8fGYodGhp
cykucmVwbGFjZVdpdGgodGhpcy5jaGlsZE5vZGVzKX0pLmVuZCgpfSxhcHBlbmQ6ZnVuY3Rpb24o
KXtyZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsITAsZnVuY3Rpb24oYSl7dGhpcy5ub2Rl
VHlwZT09PTEmJnRoaXMuYXBwZW5kQ2hpbGQoYSl9KX0scHJlcGVuZDpmdW5jdGlvbigpe3JldHVy
biB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cywhMCxmdW5jdGlvbihhKXt0aGlzLm5vZGVUeXBlPT09
MSYmdGhpcy5pbnNlcnRCZWZvcmUoYSx0aGlzLmZpcnN0Q2hpbGQpfSl9LGJlZm9yZTpmdW5jdGlv
bigpe2lmKHRoaXNbMF0mJnRoaXNbMF0ucGFyZW50Tm9kZSlyZXR1cm4gdGhpcy5kb21NYW5pcChh
cmd1bWVudHMsITEsZnVuY3Rpb24oYSl7dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLHRo
aXMpfSk7aWYoYXJndW1lbnRzLmxlbmd0aCl7dmFyIGE9Zihhcmd1bWVudHNbMF0pO2EucHVzaC5h
cHBseShhLHRoaXMudG9BcnJheSgpKTtyZXR1cm4gdGhpcy5wdXNoU3RhY2soYSwiYmVmb3JlIixh
cmd1bWVudHMpfX0sYWZ0ZXI6ZnVuY3Rpb24oKXtpZih0aGlzWzBdJiZ0aGlzWzBdLnBhcmVudE5v
ZGUpcmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCExLGZ1bmN0aW9uKGEpe3RoaXMucGFy
ZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSx0aGlzLm5leHRTaWJsaW5nKX0pO2lmKGFyZ3VtZW50cy5s
ZW5ndGgpe3ZhciBhPXRoaXMucHVzaFN0YWNrKHRoaXMsImFmdGVyIixhcmd1bWVudHMpO2EucHVz
aC5hcHBseShhLGYoYXJndW1lbnRzWzBdKS50b0FycmF5KCkpO3JldHVybiBhfX0scmVtb3ZlOmZ1
bmN0aW9uKGEsYil7Zm9yKHZhciBjPTAsZDsoZD10aGlzW2NdKSE9bnVsbDtjKyspaWYoIWF8fGYu
ZmlsdGVyKGEsW2RdKS5sZW5ndGgpIWImJmQubm9kZVR5cGU9PT0xJiYoZi5jbGVhbkRhdGEoZC5n
ZXRFbGVtZW50c0J5VGFnTmFtZSgiKiIpKSxmLmNsZWFuRGF0YShbZF0pKSxkLnBhcmVudE5vZGUm
JmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkKTtyZXR1cm4gdGhpc30sZW1wdHk6ZnVuY3Rpb24o
KXtmb3IodmFyIGE9MCxiOyhiPXRoaXNbYV0pIT1udWxsO2ErKyl7Yi5ub2RlVHlwZT09PTEmJmYu
Y2xlYW5EYXRhKGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIioiKSk7d2hpbGUoYi5maXJzdENoaWxk
KWIucmVtb3ZlQ2hpbGQoYi5maXJzdENoaWxkKX1yZXR1cm4gdGhpc30sY2xvbmU6ZnVuY3Rpb24o
YSxiKXthPWE9PW51bGw/ITE6YSxiPWI9PW51bGw/YTpiO3JldHVybiB0aGlzLm1hcChmdW5jdGlv
bigpe3JldHVybiBmLmNsb25lKHRoaXMsYSxiKX0pfSxodG1sOmZ1bmN0aW9uKGEpe2lmKGE9PT1i
KXJldHVybiB0aGlzWzBdJiZ0aGlzWzBdLm5vZGVUeXBlPT09MT90aGlzWzBdLmlubmVySFRNTC5y
ZXBsYWNlKFksIiIpOm51bGw7aWYodHlwZW9mIGE9PSJzdHJpbmciJiYhYmMudGVzdChhKSYmKGYu
c3VwcG9ydC5sZWFkaW5nV2hpdGVzcGFjZXx8IVoudGVzdChhKSkmJiFiZ1soXy5leGVjKGEpfHxb
IiIsIiJdKVsxXS50b0xvd2VyQ2FzZSgpXSl7YT1hLnJlcGxhY2UoJCwiPCQxPjwvJDI+Iik7dHJ5
e2Zvcih2YXIgYz0wLGQ9dGhpcy5sZW5ndGg7YzxkO2MrKyl0aGlzW2NdLm5vZGVUeXBlPT09MSYm
KGYuY2xlYW5EYXRhKHRoaXNbY10uZ2V0RWxlbWVudHNCeVRhZ05hbWUoIioiKSksdGhpc1tjXS5p
bm5lckhUTUw9YSl9Y2F0Y2goZSl7dGhpcy5lbXB0eSgpLmFwcGVuZChhKX19ZWxzZSBmLmlzRnVu
Y3Rpb24oYSk/dGhpcy5lYWNoKGZ1bmN0aW9uKGIpe3ZhciBjPWYodGhpcyk7Yy5odG1sKGEuY2Fs
bCh0aGlzLGIsYy5odG1sKCkpKX0pOnRoaXMuZW1wdHkoKS5hcHBlbmQoYSk7cmV0dXJuIHRoaXN9
LHJlcGxhY2VXaXRoOmZ1bmN0aW9uKGEpe2lmKHRoaXNbMF0mJnRoaXNbMF0ucGFyZW50Tm9kZSl7
aWYoZi5pc0Z1bmN0aW9uKGEpKXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oYil7dmFyIGM9Zih0
aGlzKSxkPWMuaHRtbCgpO2MucmVwbGFjZVdpdGgoYS5jYWxsKHRoaXMsYixkKSl9KTt0eXBlb2Yg
YSE9InN0cmluZyImJihhPWYoYSkuZGV0YWNoKCkpO3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24o
KXt2YXIgYj10aGlzLm5leHRTaWJsaW5nLGM9dGhpcy5wYXJlbnROb2RlO2YodGhpcykucmVtb3Zl
KCksYj9mKGIpLmJlZm9yZShhKTpmKGMpLmFwcGVuZChhKX0pfXJldHVybiB0aGlzLmxlbmd0aD90
aGlzLnB1c2hTdGFjayhmKGYuaXNGdW5jdGlvbihhKT9hKCk6YSksInJlcGxhY2VXaXRoIixhKTp0
aGlzfSxkZXRhY2g6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucmVtb3ZlKGEsITApfSxkb21NYW5p
cDpmdW5jdGlvbihhLGMsZCl7dmFyIGUsZyxoLGksaj1hWzBdLGs9W107aWYoIWYuc3VwcG9ydC5j
aGVja0Nsb25lJiZhcmd1bWVudHMubGVuZ3RoPT09MyYmdHlwZW9mIGo9PSJzdHJpbmciJiZiZC50
ZXN0KGopKXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtmKHRoaXMpLmRvbU1hbmlwKGEsYyxk
LCEwKX0pO2lmKGYuaXNGdW5jdGlvbihqKSlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGUpe3Zh
ciBnPWYodGhpcyk7YVswXT1qLmNhbGwodGhpcyxlLGM/Zy5odG1sKCk6YiksZy5kb21NYW5pcChh
LGMsZCl9KTtpZih0aGlzWzBdKXtpPWomJmoucGFyZW50Tm9kZSxmLnN1cHBvcnQucGFyZW50Tm9k
ZSYmaSYmaS5ub2RlVHlwZT09PTExJiZpLmNoaWxkTm9kZXMubGVuZ3RoPT09dGhpcy5sZW5ndGg/
ZT17ZnJhZ21lbnQ6aX06ZT1mLmJ1aWxkRnJhZ21lbnQoYSx0aGlzLGspLGg9ZS5mcmFnbWVudCxo
LmNoaWxkTm9kZXMubGVuZ3RoPT09MT9nPWg9aC5maXJzdENoaWxkOmc9aC5maXJzdENoaWxkO2lm
KGcpe2M9YyYmZi5ub2RlTmFtZShnLCJ0ciIpO2Zvcih2YXIgbD0wLG09dGhpcy5sZW5ndGgsbj1t
LTE7bDxtO2wrKylkLmNhbGwoYz9iaCh0aGlzW2xdLGcpOnRoaXNbbF0sZS5jYWNoZWFibGV8fG0+
MSYmbDxuP2YuY2xvbmUoaCwhMCwhMCk6aCl9ay5sZW5ndGgmJmYuZWFjaChrLGJuKX1yZXR1cm4g
dGhpc319KSxmLmJ1aWxkRnJhZ21lbnQ9ZnVuY3Rpb24oYSxiLGQpe3ZhciBlLGcsaCxpPWImJmJb
MF0/YlswXS5vd25lckRvY3VtZW50fHxiWzBdOmM7YS5sZW5ndGg9PT0xJiZ0eXBlb2YgYVswXT09
InN0cmluZyImJmFbMF0ubGVuZ3RoPDUxMiYmaT09PWMmJmFbMF0uY2hhckF0KDApPT09IjwiJiYh
YmMudGVzdChhWzBdKSYmKGYuc3VwcG9ydC5jaGVja0Nsb25lfHwhYmQudGVzdChhWzBdKSkmJihn
PSEwLGg9Zi5mcmFnbWVudHNbYVswXV0saCYmaCE9PTEmJihlPWgpKSxlfHwoZT1pLmNyZWF0ZURv
Y3VtZW50RnJhZ21lbnQoKSxmLmNsZWFuKGEsaSxlLGQpKSxnJiYoZi5mcmFnbWVudHNbYVswXV09
aD9lOjEpO3JldHVybntmcmFnbWVudDplLGNhY2hlYWJsZTpnfX0sZi5mcmFnbWVudHM9e30sZi5l
YWNoKHthcHBlbmRUbzoiYXBwZW5kIixwcmVwZW5kVG86InByZXBlbmQiLGluc2VydEJlZm9yZToi
YmVmb3JlIixpbnNlcnRBZnRlcjoiYWZ0ZXIiLHJlcGxhY2VBbGw6InJlcGxhY2VXaXRoIn0sZnVu
Y3Rpb24oYSxiKXtmLmZuW2FdPWZ1bmN0aW9uKGMpe3ZhciBkPVtdLGU9ZihjKSxnPXRoaXMubGVu
Z3RoPT09MSYmdGhpc1swXS5wYXJlbnROb2RlO2lmKGcmJmcubm9kZVR5cGU9PT0xMSYmZy5jaGls
ZE5vZGVzLmxlbmd0aD09PTEmJmUubGVuZ3RoPT09MSl7ZVtiXSh0aGlzWzBdKTtyZXR1cm4gdGhp
c31mb3IodmFyIGg9MCxpPWUubGVuZ3RoO2g8aTtoKyspe3ZhciBqPShoPjA/dGhpcy5jbG9uZSgh
MCk6dGhpcykuZ2V0KCk7ZihlW2hdKVtiXShqKSxkPWQuY29uY2F0KGopfXJldHVybiB0aGlzLnB1
c2hTdGFjayhkLGEsZS5zZWxlY3Rvcil9fSksZi5leHRlbmQoe2Nsb25lOmZ1bmN0aW9uKGEsYixj
KXt2YXIgZD1hLmNsb25lTm9kZSghMCksZSxnLGg7aWYoKCFmLnN1cHBvcnQubm9DbG9uZUV2ZW50
fHwhZi5zdXBwb3J0Lm5vQ2xvbmVDaGVja2VkKSYmKGEubm9kZVR5cGU9PT0xfHxhLm5vZGVUeXBl
PT09MTEpJiYhZi5pc1hNTERvYyhhKSl7YmooYSxkKSxlPWJrKGEpLGc9YmsoZCk7Zm9yKGg9MDtl
W2hdOysraCliaihlW2hdLGdbaF0pfWlmKGIpe2JpKGEsZCk7aWYoYyl7ZT1iayhhKSxnPWJrKGQp
O2ZvcihoPTA7ZVtoXTsrK2gpYmkoZVtoXSxnW2hdKX19cmV0dXJuIGR9LGNsZWFuOmZ1bmN0aW9u
KGEsYixkLGUpe3ZhciBnO2I9Ynx8Yyx0eXBlb2YgYi5jcmVhdGVFbGVtZW50PT0idW5kZWZpbmVk
IiYmKGI9Yi5vd25lckRvY3VtZW50fHwgYlswXSYmYlswXS5vd25lckRvY3VtZW50fHxjKTt2YXIg
aD1bXSxpO2Zvcih2YXIgaj0wLGs7KGs9YVtqXSkhPW51bGw7aisrKXt0eXBlb2Ygaz09Im51bWJl
ciImJihrKz0iIik7aWYoIWspY29udGludWU7aWYodHlwZW9mIGs9PSJzdHJpbmciKWlmKCFiYi50
ZXN0KGspKWs9Yi5jcmVhdGVUZXh0Tm9kZShrKTtlbHNle2s9ay5yZXBsYWNlKCQsIjwkMT48LyQy
PiIpO3ZhciBsPShfLmV4ZWMoayl8fFsiIiwiIl0pWzFdLnRvTG93ZXJDYXNlKCksbT1iZ1tsXXx8
YmcuX2RlZmF1bHQsbj1tWzBdLG89Yi5jcmVhdGVFbGVtZW50KCJkaXYiKTtvLmlubmVySFRNTD1t
WzFdK2srbVsyXTt3aGlsZShuLS0pbz1vLmxhc3RDaGlsZDtpZighZi5zdXBwb3J0LnRib2R5KXt2
YXIgcD1iYS50ZXN0KGspLHE9bD09PSJ0YWJsZSImJiFwP28uZmlyc3RDaGlsZCYmby5maXJzdENo
aWxkLmNoaWxkTm9kZXM6bVsxXT09PSI8dGFibGU+IiYmIXA/by5jaGlsZE5vZGVzOltdO2Zvcihp
PXEubGVuZ3RoLTE7aT49MDstLWkpZi5ub2RlTmFtZShxW2ldLCJ0Ym9keSIpJiYhcVtpXS5jaGls
ZE5vZGVzLmxlbmd0aCYmcVtpXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHFbaV0pfSFmLnN1cHBv
cnQubGVhZGluZ1doaXRlc3BhY2UmJloudGVzdChrKSYmby5pbnNlcnRCZWZvcmUoYi5jcmVhdGVU
ZXh0Tm9kZShaLmV4ZWMoaylbMF0pLG8uZmlyc3RDaGlsZCksaz1vLmNoaWxkTm9kZXN9dmFyIHI7
aWYoIWYuc3VwcG9ydC5hcHBlbmRDaGVja2VkKWlmKGtbMF0mJnR5cGVvZiAocj1rLmxlbmd0aCk9
PSJudW1iZXIiKWZvcihpPTA7aTxyO2krKylibShrW2ldKTtlbHNlIGJtKGspO2subm9kZVR5cGU/
aC5wdXNoKGspOmg9Zi5tZXJnZShoLGspfWlmKGQpe2c9ZnVuY3Rpb24oYSl7cmV0dXJuIWEudHlw
ZXx8YmUudGVzdChhLnR5cGUpfTtmb3Ioaj0wO2hbal07aisrKWlmKGUmJmYubm9kZU5hbWUoaFtq
XSwic2NyaXB0IikmJighaFtqXS50eXBlfHxoW2pdLnR5cGUudG9Mb3dlckNhc2UoKT09PSJ0ZXh0
L2phdmFzY3JpcHQiKSllLnB1c2goaFtqXS5wYXJlbnROb2RlP2hbal0ucGFyZW50Tm9kZS5yZW1v
dmVDaGlsZChoW2pdKTpoW2pdKTtlbHNle2lmKGhbal0ubm9kZVR5cGU9PT0xKXt2YXIgcz1mLmdy
ZXAoaFtqXS5nZXRFbGVtZW50c0J5VGFnTmFtZSgic2NyaXB0IiksZyk7aC5zcGxpY2UuYXBwbHko
aCxbaisxLDBdLmNvbmNhdChzKSl9ZC5hcHBlbmRDaGlsZChoW2pdKX19cmV0dXJuIGh9LGNsZWFu
RGF0YTpmdW5jdGlvbihhKXt2YXIgYixjLGQ9Zi5jYWNoZSxlPWYuZXhwYW5kbyxnPWYuZXZlbnQu
c3BlY2lhbCxoPWYuc3VwcG9ydC5kZWxldGVFeHBhbmRvO2Zvcih2YXIgaT0wLGo7KGo9YVtpXSkh
PW51bGw7aSsrKXtpZihqLm5vZGVOYW1lJiZmLm5vRGF0YVtqLm5vZGVOYW1lLnRvTG93ZXJDYXNl
KCldKWNvbnRpbnVlO2M9altmLmV4cGFuZG9dO2lmKGMpe2I9ZFtjXSYmZFtjXVtlXTtpZihiJiZi
LmV2ZW50cyl7Zm9yKHZhciBrIGluIGIuZXZlbnRzKWdba10/Zi5ldmVudC5yZW1vdmUoaixrKTpm
LnJlbW92ZUV2ZW50KGosayxiLmhhbmRsZSk7Yi5oYW5kbGUmJihiLmhhbmRsZS5lbGVtPW51bGwp
fWg/ZGVsZXRlIGpbZi5leHBhbmRvXTpqLnJlbW92ZUF0dHJpYnV0ZSYmai5yZW1vdmVBdHRyaWJ1
dGUoZi5leHBhbmRvKSxkZWxldGUgZFtjXX19fX0pO3ZhciBibz0vYWxwaGFcKFteKV0qXCkvaSxi
cD0vb3BhY2l0eT0oW14pXSopLyxicT0vLShbYS16XSkvaWcsYnI9LyhbQS1aXXxebXMpL2csYnM9
L14tP1xkKyg/OnB4KT8kL2ksYnQ9L14tP1xkLyxidT0vXlsrXC1dPS8sYnY9L1teK1wtXC5cZGVd
Ky9nLGJ3PXtwb3NpdGlvbjoiYWJzb2x1dGUiLHZpc2liaWxpdHk6ImhpZGRlbiIsZGlzcGxheToi
YmxvY2sifSxieD1bIkxlZnQiLCJSaWdodCJdLGJ5PVsiVG9wIiwiQm90dG9tIl0sYnosYkEsYkIs
YkM9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi50b1VwcGVyQ2FzZSgpfTtmLmZuLmNzcz1mdW5jdGlv
bihhLGMpe2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0yJiZjPT09YilyZXR1cm4gdGhpcztyZXR1cm4g
Zi5hY2Nlc3ModGhpcyxhLGMsITAsZnVuY3Rpb24oYSxjLGQpe3JldHVybiBkIT09Yj9mLnN0eWxl
KGEsYyxkKTpmLmNzcyhhLGMpfSl9LGYuZXh0ZW5kKHtjc3NIb29rczp7b3BhY2l0eTp7Z2V0OmZ1
bmN0aW9uKGEsYil7aWYoYil7dmFyIGM9YnooYSwib3BhY2l0eSIsIm9wYWNpdHkiKTtyZXR1cm4g
Yz09PSIiPyIxIjpjfXJldHVybiBhLnN0eWxlLm9wYWNpdHl9fX0sY3NzTnVtYmVyOnt6SW5kZXg6
ITAsZm9udFdlaWdodDohMCxvcGFjaXR5OiEwLHpvb206ITAsbGluZUhlaWdodDohMCx3aWRvd3M6
ITAsb3JwaGFuczohMH0sY3NzUHJvcHM6eyJmbG9hdCI6Zi5zdXBwb3J0LmNzc0Zsb2F0PyJjc3NG
bG9hdCI6InN0eWxlRmxvYXQifSxzdHlsZTpmdW5jdGlvbihhLGMsZCxlKXtpZighIWEmJmEubm9k
ZVR5cGUhPT0zJiZhLm5vZGVUeXBlIT09OCYmISFhLnN0eWxlKXt2YXIgZyxoLGk9Zi5jYW1lbENh
c2UoYyksaj1hLnN0eWxlLGs9Zi5jc3NIb29rc1tpXTtjPWYuY3NzUHJvcHNbaV18fGk7aWYoZD09
PWIpe2lmKGsmJiJnZXQiaW4gayYmKGc9ay5nZXQoYSwhMSxlKSkhPT1iKXJldHVybiBnO3JldHVy
biBqW2NdfWg9dHlwZW9mIGQ7aWYoaD09PSJudW1iZXIiJiZpc05hTihkKXx8ZD09bnVsbClyZXR1
cm47aD09PSJzdHJpbmciJiZidS50ZXN0KGQpJiYoZD0rZC5yZXBsYWNlKGJ2LCIiKStwYXJzZUZs
b2F0KGYuY3NzKGEsYykpKSxoPT09Im51bWJlciImJiFmLmNzc051bWJlcltpXSYmKGQrPSJweCIp
O2lmKCFrfHwhKCJzZXQiaW4gayl8fChkPWsuc2V0KGEsZCkpIT09Yil0cnl7altjXT1kfWNhdGNo
KGwpe319fSxjc3M6ZnVuY3Rpb24oYSxjLGQpe3ZhciBlLGc7Yz1mLmNhbWVsQ2FzZShjKSxnPWYu
Y3NzSG9va3NbY10sYz1mLmNzc1Byb3BzW2NdfHxjLGM9PT0iY3NzRmxvYXQiJiYoYz0iZmxvYXQi
KTtpZihnJiYiZ2V0ImluIGcmJihlPWcuZ2V0KGEsITAsZCkpIT09YilyZXR1cm4gZTtpZihieily
ZXR1cm4gYnooYSxjKX0sc3dhcDpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9e307Zm9yKHZhciBlIGlu
IGIpZFtlXT1hLnN0eWxlW2VdLGEuc3R5bGVbZV09YltlXTtjLmNhbGwoYSk7Zm9yKGUgaW4gYilh
LnN0eWxlW2VdPWRbZV19LGNhbWVsQ2FzZTpmdW5jdGlvbihhKXtyZXR1cm4gYS5yZXBsYWNlKGJx
LGJDKX19KSxmLmN1ckNTUz1mLmNzcyxmLmVhY2goWyJoZWlnaHQiLCJ3aWR0aCJdLGZ1bmN0aW9u
KGEsYil7Zi5jc3NIb29rc1tiXT17Z2V0OmZ1bmN0aW9uKGEsYyxkKXt2YXIgZTtpZihjKXthLm9m
ZnNldFdpZHRoIT09MD9lPWJEKGEsYixkKTpmLnN3YXAoYSxidyxmdW5jdGlvbigpe2U9YkQoYSxi
LGQpfSk7aWYoZTw9MCl7ZT1ieihhLGIsYiksZT09PSIwcHgiJiZiQiYmKGU9YkIoYSxiLGIpKTtp
ZihlIT1udWxsKXJldHVybiBlPT09IiJ8fGU9PT0iYXV0byI/IjBweCI6ZX1pZihlPDB8fGU9PW51
bGwpe2U9YS5zdHlsZVtiXTtyZXR1cm4gZT09PSIifHxlPT09ImF1dG8iPyIwcHgiOmV9cmV0dXJu
IHR5cGVvZiBlPT0ic3RyaW5nIj9lOmUrInB4In19LHNldDpmdW5jdGlvbihhLGIpe2lmKCFicy50
ZXN0KGIpKXJldHVybiBiO2I9cGFyc2VGbG9hdChiKTtpZihiPj0wKXJldHVybiBiKyJweCJ9fX0p
LGYuc3VwcG9ydC5vcGFjaXR5fHwoZi5jc3NIb29rcy5vcGFjaXR5PXtnZXQ6ZnVuY3Rpb24oYSxi
KXtyZXR1cm4gYnAudGVzdCgoYiYmYS5jdXJyZW50U3R5bGU/YS5jdXJyZW50U3R5bGUuZmlsdGVy
OmEuc3R5bGUuZmlsdGVyKXx8IiIpP3BhcnNlRmxvYXQoUmVnRXhwLiQxKS8xMDArIiI6Yj8iMSI6
IiJ9LHNldDpmdW5jdGlvbihhLGIpe3ZhciBjPWEuc3R5bGUsZD1hLmN1cnJlbnRTdHlsZTtjLnpv
b209MTt2YXIgZT1mLmlzTmFOKGIpPyIiOiJhbHBoYShvcGFjaXR5PSIrYioxMDArIikiLGc9ZCYm
ZC5maWx0ZXJ8fGMuZmlsdGVyfHwiIjtjLmZpbHRlcj1iby50ZXN0KGcpP2cucmVwbGFjZShibyxl
KTpnKyIgIitlfX0pLGYoZnVuY3Rpb24oKXtmLnN1cHBvcnQucmVsaWFibGVNYXJnaW5SaWdodHx8
KGYuY3NzSG9va3MubWFyZ2luUmlnaHQ9e2dldDpmdW5jdGlvbihhLGIpe3ZhciBjO2Yuc3dhcChh
LHtkaXNwbGF5OiJpbmxpbmUtYmxvY2sifSxmdW5jdGlvbigpe2I/Yz1ieihhLCJtYXJnaW4tcmln
aHQiLCJtYXJnaW5SaWdodCIpOmM9YS5zdHlsZS5tYXJnaW5SaWdodH0pO3JldHVybiBjfX0pfSks
Yy5kZWZhdWx0VmlldyYmYy5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlJiYoYkE9ZnVuY3Rp
b24oYSxjKXt2YXIgZCxlLGc7Yz1jLnJlcGxhY2UoYnIsIi0kMSIpLnRvTG93ZXJDYXNlKCk7aWYo
IShlPWEub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykpcmV0dXJuIGI7aWYoZz1lLmdldENvbXB1
dGVkU3R5bGUoYSxudWxsKSlkPWcuZ2V0UHJvcGVydHlWYWx1ZShjKSxkPT09IiImJiFmLmNvbnRh
aW5zKGEub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsYSkmJihkPWYuc3R5bGUoYSxjKSk7
cmV0dXJuIGR9KSxjLmRvY3VtZW50RWxlbWVudC5jdXJyZW50U3R5bGUmJihiQj1mdW5jdGlvbihh
LGIpe3ZhciBjLGQ9YS5jdXJyZW50U3R5bGUmJmEuY3VycmVudFN0eWxlW2JdLGU9YS5ydW50aW1l
U3R5bGUmJmEucnVudGltZVN0eWxlW2JdLGY9YS5zdHlsZTshYnMudGVzdChkKSYmYnQudGVzdChk
KSYmKGM9Zi5sZWZ0LGUmJihhLnJ1bnRpbWVTdHlsZS5sZWZ0PWEuY3VycmVudFN0eWxlLmxlZnQp
LGYubGVmdD1iPT09ImZvbnRTaXplIj8iMWVtIjpkfHwwLGQ9Zi5waXhlbExlZnQrInB4IixmLmxl
ZnQ9YyxlJiYoYS5ydW50aW1lU3R5bGUubGVmdD1lKSk7cmV0dXJuIGQ9PT0iIj8iYXV0byI6ZH0p
LGJ6PWJBfHxiQixmLmV4cHImJmYuZXhwci5maWx0ZXJzJiYoZi5leHByLmZpbHRlcnMuaGlkZGVu
PWZ1bmN0aW9uKGEpe3ZhciBiPWEub2Zmc2V0V2lkdGgsYz1hLm9mZnNldEhlaWdodDtyZXR1cm4g
Yj09PTAmJmM9PT0wfHwhZi5zdXBwb3J0LnJlbGlhYmxlSGlkZGVuT2Zmc2V0cyYmKGEuc3R5bGUu
ZGlzcGxheXx8Zi5jc3MoYSwiZGlzcGxheSIpKT09PSJub25lIn0sZi5leHByLmZpbHRlcnMudmlz
aWJsZT1mdW5jdGlvbihhKXtyZXR1cm4hZi5leHByLmZpbHRlcnMuaGlkZGVuKGEpfSk7dmFyIGJF
PS8lMjAvZyxiRj0vXFtcXSQvLGJHPS9ccj9cbi9nLGJIPS8jLiokLyxiST0vXiguKj8pOlsgXHRd
KihbXlxyXG5dKilccj8kL21nLGJKPS9eKD86Y29sb3J8ZGF0ZXxkYXRldGltZXxlbWFpbHxoaWRk
ZW58bW9udGh8bnVtYmVyfHBhc3N3b3JkfHJhbmdlfHNlYXJjaHx0ZWx8dGV4dHx0aW1lfHVybHx3
ZWVrKSQvaSxiSz0vXig/OmFib3V0fGFwcHxhcHBcLXN0b3JhZ2V8LitcLWV4dGVuc2lvbnxmaWxl
fHdpZGdldCk6JC8sYkw9L14oPzpHRVR8SEVBRCkkLyxiTT0vXlwvXC8vLGJOPS9cPy8sYk89Lzxz
Y3JpcHRcYltePF0qKD86KD8hPFwvc2NyaXB0Pik8W148XSopKjxcL3NjcmlwdD4vZ2ksYlA9L14o
PzpzZWxlY3R8dGV4dGFyZWEpL2ksYlE9L1xzKy8sYlI9LyhbPyZdKV89W14mXSovLGJTPS9eKFtc
d1wrXC5cLV0rOikoPzpcL1wvKFteXC8/IzpdKikoPzo6KFxkKykpPyk/LyxiVD1mLmZuLmxvYWQs
YlU9e30sYlY9e30sYlcsYlg7dHJ5e2JXPWUuaHJlZn1jYXRjaChiWSl7Ylc9Yy5jcmVhdGVFbGVt
ZW50KCJhIiksYlcuaHJlZj0iIixiVz1iVy5ocmVmfWJYPWJTLmV4ZWMoYlcudG9Mb3dlckNhc2Uo
KSl8fFtdLGYuZm4uZXh0ZW5kKHtsb2FkOmZ1bmN0aW9uKGEsYyxkKXtpZih0eXBlb2YgYSE9InN0
cmluZyImJmJUKXJldHVybiBiVC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYoIXRoaXMubGVuZ3Ro
KXJldHVybiB0aGlzO3ZhciBlPWEuaW5kZXhPZigiICIpO2lmKGU+PTApe3ZhciBnPWEuc2xpY2Uo
ZSxhLmxlbmd0aCk7YT1hLnNsaWNlKDAsZSl9dmFyIGg9IkdFVCI7YyYmKGYuaXNGdW5jdGlvbihj
KT8oZD1jLGM9Yik6dHlwZW9mIGM9PSJvYmplY3QiJiYoYz1mLnBhcmFtKGMsZi5hamF4U2V0dGlu
Z3MudHJhZGl0aW9uYWwpLGg9IlBPU1QiKSk7dmFyIGk9dGhpcztmLmFqYXgoe3VybDphLHR5cGU6
aCxkYXRhVHlwZToiaHRtbCIsZGF0YTpjLGNvbXBsZXRlOmZ1bmN0aW9uKGEsYixjKXtjPWEucmVz
cG9uc2VUZXh0LGEuaXNSZXNvbHZlZCgpJiYoYS5kb25lKGZ1bmN0aW9uKGEpe2M9YX0pLGkuaHRt
bChnP2YoIjxkaXY+IikuYXBwZW5kKGMucmVwbGFjZShiTywiIikpLmZpbmQoZyk6YykpLGQmJmku
ZWFjaChkLFtjLGIsYV0pfX0pO3JldHVybiB0aGlzfSxzZXJpYWxpemU6ZnVuY3Rpb24oKXtyZXR1
cm4gZi5wYXJhbSh0aGlzLnNlcmlhbGl6ZUFycmF5KCkpfSxzZXJpYWxpemVBcnJheTpmdW5jdGlv
bigpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe3JldHVybiB0aGlzLmVsZW1lbnRzP2YubWFr
ZUFycmF5KHRoaXMuZWxlbWVudHMpOnRoaXN9KS5maWx0ZXIoZnVuY3Rpb24oKXtyZXR1cm4gdGhp
cy5uYW1lJiYhdGhpcy5kaXNhYmxlZCYmKHRoaXMuY2hlY2tlZHx8YlAudGVzdCh0aGlzLm5vZGVO
YW1lKXx8YkoudGVzdCh0aGlzLnR5cGUpKX0pLm1hcChmdW5jdGlvbihhLGIpe3ZhciBjPWYodGhp
cykudmFsKCk7cmV0dXJuIGM9PW51bGw/bnVsbDpmLmlzQXJyYXkoYyk/Zi5tYXAoYyxmdW5jdGlv
bihhLGMpe3JldHVybntuYW1lOmIubmFtZSx2YWx1ZTphLnJlcGxhY2UoYkcsIlxyXG4iKX19KTp7
bmFtZTpiLm5hbWUsdmFsdWU6Yy5yZXBsYWNlKGJHLCJcclxuIil9fSkuZ2V0KCl9fSksZi5lYWNo
KCJhamF4U3RhcnQgYWpheFN0b3AgYWpheENvbXBsZXRlIGFqYXhFcnJvciBhamF4U3VjY2VzcyBh
amF4U2VuZCIuc3BsaXQoIiAiKSxmdW5jdGlvbihhLGIpe2YuZm5bYl09ZnVuY3Rpb24oYSl7cmV0
dXJuIHRoaXMuYmluZChiLGEpfX0pLGYuZWFjaChbImdldCIsInBvc3QiXSxmdW5jdGlvbihhLGMp
e2ZbY109ZnVuY3Rpb24oYSxkLGUsZyl7Zi5pc0Z1bmN0aW9uKGQpJiYoZz1nfHxlLGU9ZCxkPWIp
O3JldHVybiBmLmFqYXgoe3R5cGU6Yyx1cmw6YSxkYXRhOmQsc3VjY2VzczplLGRhdGFUeXBlOmd9
KX19KSxmLmV4dGVuZCh7Z2V0U2NyaXB0OmZ1bmN0aW9uKGEsYyl7cmV0dXJuIGYuZ2V0KGEsYixj
LCJzY3JpcHQiKX0sZ2V0SlNPTjpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIGYuZ2V0KGEsYixjLCJq
c29uIil9LGFqYXhTZXR1cDpmdW5jdGlvbihhLGIpe2I/Zi5leHRlbmQoITAsYSxmLmFqYXhTZXR0
aW5ncyxiKTooYj1hLGE9Zi5leHRlbmQoITAsZi5hamF4U2V0dGluZ3MsYikpO2Zvcih2YXIgYyBp
bntjb250ZXh0OjEsdXJsOjF9KWMgaW4gYj9hW2NdPWJbY106YyBpbiBmLmFqYXhTZXR0aW5ncyYm
KGFbY109Zi5hamF4U2V0dGluZ3NbY10pO3JldHVybiBhfSxhamF4U2V0dGluZ3M6e3VybDpiVyxp
c0xvY2FsOmJLLnRlc3QoYlhbMV0pLGdsb2JhbDohMCx0eXBlOiJHRVQiLGNvbnRlbnRUeXBlOiJh
cHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQiLHByb2Nlc3NEYXRhOiEwLGFzeW5jOiEw
LGFjY2VwdHM6e3htbDoiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbCIsaHRtbDoidGV4dC9odG1s
Iix0ZXh0OiJ0ZXh0L3BsYWluIixqc29uOiJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3Jp
cHQiLCIqIjoiKi8qIn0sY29udGVudHM6e3htbDoveG1sLyxodG1sOi9odG1sLyxqc29uOi9qc29u
L30scmVzcG9uc2VGaWVsZHM6e3htbDoicmVzcG9uc2VYTUwiLHRleHQ6InJlc3BvbnNlVGV4dCJ9
LGNvbnZlcnRlcnM6eyIqIHRleHQiOmEuU3RyaW5nLCJ0ZXh0IGh0bWwiOiEwLCJ0ZXh0IGpzb24i
OmYucGFyc2VKU09OLCJ0ZXh0IHhtbCI6Zi5wYXJzZVhNTH19LGFqYXhQcmVmaWx0ZXI6YlooYlUp
LGFqYXhUcmFuc3BvcnQ6YlooYlYpLGFqYXg6ZnVuY3Rpb24oYSxjKXtmdW5jdGlvbiB3KGEsYyxs
LG0pe2lmKHMhPT0yKXtzPTIscSYmY2xlYXJUaW1lb3V0KHEpLHA9YixuPW18fCIiLHYucmVhZHlT
dGF0ZT1hPzQ6MDt2YXIgbyxyLHUsdz1sP2NhKGQsdixsKTpiLHgseTtpZihhPj0yMDAmJmE8MzAw
fHxhPT09MzA0KXtpZihkLmlmTW9kaWZpZWQpe2lmKHg9di5nZXRSZXNwb25zZUhlYWRlcigiTGFz
dC1Nb2RpZmllZCIpKWYubGFzdE1vZGlmaWVkW2tdPXg7aWYoeT12LmdldFJlc3BvbnNlSGVhZGVy
KCJFdGFnIikpZi5ldGFnW2tdPXl9aWYoYT09PTMwNCljPSJub3Rtb2RpZmllZCIsbz0hMDtlbHNl
IHRyeXtyPWNiKGQsdyksYz0ic3VjY2VzcyIsbz0hMH1jYXRjaCh6KXtjPSJwYXJzZXJlcnJvciIs
dT16fX1lbHNle3U9YztpZighY3x8YSljPSJlcnJvciIsYTwwJiYoYT0wKX12LnN0YXR1cz1hLHYu
c3RhdHVzVGV4dD1jLG8/aC5yZXNvbHZlV2l0aChlLFtyLGMsdl0pOmgucmVqZWN0V2l0aChlLFt2
LGMsdV0pLHYuc3RhdHVzQ29kZShqKSxqPWIsdCYmZy50cmlnZ2VyKCJhamF4Iisobz8iU3VjY2Vz
cyI6IkVycm9yIiksW3YsZCxvP3I6dV0pLGkucmVzb2x2ZVdpdGgoZSxbdixjXSksdCYmKGcudHJp
Z2dlcigiYWpheENvbXBsZXRlIixbdixkXSksLS1mLmFjdGl2ZXx8Zi5ldmVudC50cmlnZ2VyKCJh
amF4U3RvcCIpKX19dHlwZW9mIGE9PSJvYmplY3QiJiYoYz1hLGE9YiksYz1jfHx7fTt2YXIgZD1m
LmFqYXhTZXR1cCh7fSxjKSxlPWQuY29udGV4dHx8ZCxnPWUhPT1kJiYoZS5ub2RlVHlwZXx8ZSBp
bnN0YW5jZW9mIGYpP2YoZSk6Zi5ldmVudCxoPWYuRGVmZXJyZWQoKSxpPWYuX0RlZmVycmVkKCks
aj1kLnN0YXR1c0NvZGV8fHt9LGssbD17fSxtPXt9LG4sbyxwLHEscixzPTAsdCx1LHY9e3JlYWR5
U3RhdGU6MCxzZXRSZXF1ZXN0SGVhZGVyOmZ1bmN0aW9uKGEsYil7aWYoIXMpe3ZhciBjPWEudG9M
b3dlckNhc2UoKTthPW1bY109bVtjXXx8YSxsW2FdPWJ9cmV0dXJuIHRoaXN9LGdldEFsbFJlc3Bv
bnNlSGVhZGVyczpmdW5jdGlvbigpe3JldHVybiBzPT09Mj9uOm51bGx9LGdldFJlc3BvbnNlSGVh
ZGVyOmZ1bmN0aW9uKGEpe3ZhciBjO2lmKHM9PT0yKXtpZighbyl7bz17fTt3aGlsZShjPWJJLmV4
ZWMobikpb1tjWzFdLnRvTG93ZXJDYXNlKCldPWNbMl19Yz1vW2EudG9Mb3dlckNhc2UoKV19cmV0
dXJuIGM9PT1iP251bGw6Y30sb3ZlcnJpZGVNaW1lVHlwZTpmdW5jdGlvbihhKXtzfHwoZC5taW1l
VHlwZT1hKTtyZXR1cm4gdGhpc30sYWJvcnQ6ZnVuY3Rpb24oYSl7YT1hfHwiYWJvcnQiLHAmJnAu
YWJvcnQoYSksdygwLGEpO3JldHVybiB0aGlzfX07aC5wcm9taXNlKHYpLHYuc3VjY2Vzcz12LmRv
bmUsdi5lcnJvcj12LmZhaWwsdi5jb21wbGV0ZT1pLmRvbmUsdi5zdGF0dXNDb2RlPWZ1bmN0aW9u
KGEpe2lmKGEpe3ZhciBiO2lmKHM8Milmb3IoYiBpbiBhKWpbYl09W2pbYl0sYVtiXV07ZWxzZSBi
PWFbdi5zdGF0dXNdLHYudGhlbihiLGIpfXJldHVybiB0aGlzfSxkLnVybD0oKGF8fGQudXJsKSsi
IikucmVwbGFjZShiSCwiIikucmVwbGFjZShiTSxiWFsxXSsiLy8iKSxkLmRhdGFUeXBlcz1mLnRy
aW0oZC5kYXRhVHlwZXx8IioiKS50b0xvd2VyQ2FzZSgpLnNwbGl0KGJRKSxkLmNyb3NzRG9tYWlu
PT1udWxsJiYocj1iUy5leGVjKGQudXJsLnRvTG93ZXJDYXNlKCkpLGQuY3Jvc3NEb21haW49ISgh
cnx8clsxXT09YlhbMV0mJnJbMl09PWJYWzJdJiYoclszXXx8KHJbMV09PT0iaHR0cDoiPzgwOjQ0
MykpPT0oYlhbM118fChiWFsxXT09PSJodHRwOiI/ODA6NDQzKSkpKSxkLmRhdGEmJmQucHJvY2Vz
c0RhdGEmJnR5cGVvZiBkLmRhdGEhPSJzdHJpbmciJiYoZC5kYXRhPWYucGFyYW0oZC5kYXRhLGQu
dHJhZGl0aW9uYWwpKSxiJChiVSxkLGMsdik7aWYocz09PTIpcmV0dXJuITE7dD1kLmdsb2JhbCxk
LnR5cGU9ZC50eXBlLnRvVXBwZXJDYXNlKCksZC5oYXNDb250ZW50PSFiTC50ZXN0KGQudHlwZSks
dCYmZi5hY3RpdmUrKz09PTAmJmYuZXZlbnQudHJpZ2dlcigiYWpheFN0YXJ0Iik7aWYoIWQuaGFz
Q29udGVudCl7ZC5kYXRhJiYoZC51cmwrPShiTi50ZXN0KGQudXJsKT8iJiI6Ij8iKStkLmRhdGEp
LGs9ZC51cmw7aWYoZC5jYWNoZT09PSExKXt2YXIgeD1mLm5vdygpLHk9ZC51cmwucmVwbGFjZShi
UiwiJDFfPSIreCk7ZC51cmw9eSsoeT09PWQudXJsPyhiTi50ZXN0KGQudXJsKT8iJiI6Ij8iKSsi
Xz0iK3g6IiIpfX0oZC5kYXRhJiZkLmhhc0NvbnRlbnQmJmQuY29udGVudFR5cGUhPT0hMXx8Yy5j
b250ZW50VHlwZSkmJnYuc2V0UmVxdWVzdEhlYWRlcigiQ29udGVudC1UeXBlIixkLmNvbnRlbnRU
eXBlKSxkLmlmTW9kaWZpZWQmJihrPWt8fGQudXJsLGYubGFzdE1vZGlmaWVkW2tdJiZ2LnNldFJl
cXVlc3RIZWFkZXIoIklmLU1vZGlmaWVkLVNpbmNlIixmLmxhc3RNb2RpZmllZFtrXSksZi5ldGFn
W2tdJiZ2LnNldFJlcXVlc3RIZWFkZXIoIklmLU5vbmUtTWF0Y2giLGYuZXRhZ1trXSkpLHYuc2V0
UmVxdWVzdEhlYWRlcigiQWNjZXB0IixkLmRhdGFUeXBlc1swXSYmZC5hY2NlcHRzW2QuZGF0YVR5
cGVzWzBdXT9kLmFjY2VwdHNbZC5kYXRhVHlwZXNbMF1dKyhkLmRhdGFUeXBlc1swXSE9PSIqIj8i
LCAqLyo7IHE9MC4wMSI6IiIpOmQuYWNjZXB0c1siKiJdKTtmb3IodSBpbiBkLmhlYWRlcnMpdi5z
ZXRSZXF1ZXN0SGVhZGVyKHUsZC5oZWFkZXJzW3VdKTtpZihkLmJlZm9yZVNlbmQmJihkLmJlZm9y
ZVNlbmQuY2FsbChlLHYsZCk9PT0hMXx8cz09PTIpKXt2LmFib3J0KCk7cmV0dXJuITF9Zm9yKHUg
aW57c3VjY2VzczoxLGVycm9yOjEsY29tcGxldGU6MX0pdlt1XShkW3VdKTtwPWIkKGJWLGQsYyx2
KTtpZighcCl3KC0xLCJObyBUcmFuc3BvcnQiKTtlbHNle3YucmVhZHlTdGF0ZT0xLHQmJmcudHJp
Z2dlcigiYWpheFNlbmQiLFt2LGRdKSxkLmFzeW5jJiZkLnRpbWVvdXQ+MCYmKHE9c2V0VGltZW91
dChmdW5jdGlvbigpe3YuYWJvcnQoInRpbWVvdXQiKX0sZC50aW1lb3V0KSk7dHJ5e3M9MSxwLnNl
bmQobCx3KX1jYXRjaCh6KXtzdGF0dXM8Mj93KC0xLHopOmYuZXJyb3Ioeil9fXJldHVybiB2fSxw
YXJhbTpmdW5jdGlvbihhLGMpe3ZhciBkPVtdLGU9ZnVuY3Rpb24oYSxiKXtiPWYuaXNGdW5jdGlv
bihiKT9iKCk6YixkW2QubGVuZ3RoXT1lbmNvZGVVUklDb21wb25lbnQoYSkrIj0iK2VuY29kZVVS
SUNvbXBvbmVudChiKX07Yz09PWImJihjPWYuYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsKTtpZihm
LmlzQXJyYXkoYSl8fGEuanF1ZXJ5JiYhZi5pc1BsYWluT2JqZWN0KGEpKWYuZWFjaChhLGZ1bmN0
aW9uKCl7ZSh0aGlzLm5hbWUsdGhpcy52YWx1ZSl9KTtlbHNlIGZvcih2YXIgZyBpbiBhKWJfKGcs
YVtnXSxjLGUpO3JldHVybiBkLmpvaW4oIiYiKS5yZXBsYWNlKGJFLCIrIil9fSksZi5leHRlbmQo
e2FjdGl2ZTowLGxhc3RNb2RpZmllZDp7fSxldGFnOnt9fSk7dmFyIGNjPWYubm93KCksY2Q9Lyhc
PSlcPygmfCQpfFw/XD8vaTtmLmFqYXhTZXR1cCh7anNvbnA6ImNhbGxiYWNrIixqc29ucENhbGxi
YWNrOmZ1bmN0aW9uKCl7cmV0dXJuIGYuZXhwYW5kbysiXyIrY2MrK319KSxmLmFqYXhQcmVmaWx0
ZXIoImpzb24ganNvbnAiLGZ1bmN0aW9uKGIsYyxkKXt2YXIgZT1iLmNvbnRlbnRUeXBlPT09ImFw
cGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCImJnR5cGVvZiBiLmRhdGE9PSJzdHJpbmci
O2lmKGIuZGF0YVR5cGVzWzBdPT09Impzb25wInx8Yi5qc29ucCE9PSExJiYoY2QudGVzdChiLnVy
bCl8fGUmJmNkLnRlc3QoYi5kYXRhKSkpe3ZhciBnLGg9Yi5qc29ucENhbGxiYWNrPWYuaXNGdW5j
dGlvbihiLmpzb25wQ2FsbGJhY2spP2IuanNvbnBDYWxsYmFjaygpOmIuanNvbnBDYWxsYmFjayxp
PWFbaF0saj1iLnVybCxrPWIuZGF0YSxsPSIkMSIraCsiJDIiO2IuanNvbnAhPT0hMSYmKGo9ai5y
ZXBsYWNlKGNkLGwpLGIudXJsPT09aiYmKGUmJihrPWsucmVwbGFjZShjZCxsKSksYi5kYXRhPT09
ayYmKGorPSgvXD8vLnRlc3Qoaik/IiYiOiI/IikrYi5qc29ucCsiPSIraCkpKSxiLnVybD1qLGIu
ZGF0YT1rLGFbaF09ZnVuY3Rpb24oYSl7Zz1bYV19LGQuYWx3YXlzKGZ1bmN0aW9uKCl7YVtoXT1p
LGcmJmYuaXNGdW5jdGlvbihpKSYmYVtoXShnWzBdKX0pLGIuY29udmVydGVyc1sic2NyaXB0IGpz
b24iXT1mdW5jdGlvbigpe2d8fGYuZXJyb3IoaCsiIHdhcyBub3QgY2FsbGVkIik7cmV0dXJuIGdb
MF19LGIuZGF0YVR5cGVzWzBdPSJqc29uIjtyZXR1cm4ic2NyaXB0In19KSxmLmFqYXhTZXR1cCh7
YWNjZXB0czp7c2NyaXB0OiJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQs
IGFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdCJ9LGNvbnRl
bnRzOntzY3JpcHQ6L2phdmFzY3JpcHR8ZWNtYXNjcmlwdC99LGNvbnZlcnRlcnM6eyJ0ZXh0IHNj
cmlwdCI6ZnVuY3Rpb24oYSl7Zi5nbG9iYWxFdmFsKGEpO3JldHVybiBhfX19KSxmLmFqYXhQcmVm
aWx0ZXIoInNjcmlwdCIsZnVuY3Rpb24oYSl7YS5jYWNoZT09PWImJihhLmNhY2hlPSExKSxhLmNy
b3NzRG9tYWluJiYoYS50eXBlPSJHRVQiLGEuZ2xvYmFsPSExKX0pLGYuYWpheFRyYW5zcG9ydCgi
c2NyaXB0IixmdW5jdGlvbihhKXtpZihhLmNyb3NzRG9tYWluKXt2YXIgZCxlPWMuaGVhZHx8Yy5n
ZXRFbGVtZW50c0J5VGFnTmFtZSgiaGVhZCIpWzBdfHxjLmRvY3VtZW50RWxlbWVudDtyZXR1cm57
c2VuZDpmdW5jdGlvbihmLGcpe2Q9Yy5jcmVhdGVFbGVtZW50KCJzY3JpcHQiKSxkLmFzeW5jPSJh
c3luYyIsYS5zY3JpcHRDaGFyc2V0JiYoZC5jaGFyc2V0PWEuc2NyaXB0Q2hhcnNldCksZC5zcmM9
YS51cmwsZC5vbmxvYWQ9ZC5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oYSxjKXtpZihjfHwh
ZC5yZWFkeVN0YXRlfHwvbG9hZGVkfGNvbXBsZXRlLy50ZXN0KGQucmVhZHlTdGF0ZSkpZC5vbmxv
YWQ9ZC5vbnJlYWR5c3RhdGVjaGFuZ2U9bnVsbCxlJiZkLnBhcmVudE5vZGUmJmUucmVtb3ZlQ2hp
bGQoZCksZD1iLGN8fGcoMjAwLCJzdWNjZXNzIil9LGUuaW5zZXJ0QmVmb3JlKGQsZS5maXJzdENo
aWxkKX0sYWJvcnQ6ZnVuY3Rpb24oKXtkJiZkLm9ubG9hZCgwLDEpfX19fSk7dmFyIGNlPWEuQWN0
aXZlWE9iamVjdD9mdW5jdGlvbigpe2Zvcih2YXIgYSBpbiBjZyljZ1thXSgwLDEpfTohMSxjZj0w
LGNnO2YuYWpheFNldHRpbmdzLnhocj1hLkFjdGl2ZVhPYmplY3Q/ZnVuY3Rpb24oKXtyZXR1cm4h
dGhpcy5pc0xvY2FsJiZjaCgpfHxjaSgpfTpjaCxmdW5jdGlvbihhKXtmLmV4dGVuZChmLnN1cHBv
cnQse2FqYXg6ISFhLGNvcnM6ISFhJiYid2l0aENyZWRlbnRpYWxzImluIGF9KX0oZi5hamF4U2V0
dGluZ3MueGhyKCkpLGYuc3VwcG9ydC5hamF4JiZmLmFqYXhUcmFuc3BvcnQoZnVuY3Rpb24oYyl7
aWYoIWMuY3Jvc3NEb21haW58fGYuc3VwcG9ydC5jb3JzKXt2YXIgZDtyZXR1cm57c2VuZDpmdW5j
dGlvbihlLGcpe3ZhciBoPWMueGhyKCksaSxqO2MudXNlcm5hbWU/aC5vcGVuKGMudHlwZSxjLnVy
bCxjLmFzeW5jLGMudXNlcm5hbWUsYy5wYXNzd29yZCk6aC5vcGVuKGMudHlwZSxjLnVybCxjLmFz
eW5jKTtpZihjLnhockZpZWxkcylmb3IoaiBpbiBjLnhockZpZWxkcyloW2pdPWMueGhyRmllbGRz
W2pdO2MubWltZVR5cGUmJmgub3ZlcnJpZGVNaW1lVHlwZSYmaC5vdmVycmlkZU1pbWVUeXBlKGMu
bWltZVR5cGUpLCFjLmNyb3NzRG9tYWluJiYhZVsiWC1SZXF1ZXN0ZWQtV2l0aCJdJiYoZVsiWC1S
ZXF1ZXN0ZWQtV2l0aCJdPSJYTUxIdHRwUmVxdWVzdCIpO3RyeXtmb3IoaiBpbiBlKWguc2V0UmVx
dWVzdEhlYWRlcihqLGVbal0pfWNhdGNoKGspe31oLnNlbmQoYy5oYXNDb250ZW50JiZjLmRhdGF8
fG51bGwpLGQ9ZnVuY3Rpb24oYSxlKXt2YXIgaixrLGwsbSxuO3RyeXtpZihkJiYoZXx8aC5yZWFk
eVN0YXRlPT09NCkpe2Q9YixpJiYoaC5vbnJlYWR5c3RhdGVjaGFuZ2U9Zi5ub29wLGNlJiZkZWxl
dGUgY2dbaV0pO2lmKGUpaC5yZWFkeVN0YXRlIT09NCYmaC5hYm9ydCgpO2Vsc2V7aj1oLnN0YXR1
cyxsPWguZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCksbT17fSxuPWgucmVzcG9uc2VYTUwsbiYmbi5k
b2N1bWVudEVsZW1lbnQmJihtLnhtbD1uKSxtLnRleHQ9aC5yZXNwb25zZVRleHQ7dHJ5e2s9aC5z
dGF0dXNUZXh0fWNhdGNoKG8pe2s9IiJ9IWomJmMuaXNMb2NhbCYmIWMuY3Jvc3NEb21haW4/aj1t
LnRleHQ/MjAwOjQwNDpqPT09MTIyMyYmKGo9MjA0KX19fWNhdGNoKHApe2V8fGcoLTEscCl9bSYm
ZyhqLGssbSxsKX0sIWMuYXN5bmN8fGgucmVhZHlTdGF0ZT09PTQ/ZCgpOihpPSsrY2YsY2UmJihj
Z3x8KGNnPXt9LGYoYSkudW5sb2FkKGNlKSksY2dbaV09ZCksaC5vbnJlYWR5c3RhdGVjaGFuZ2U9
ZCl9LGFib3J0OmZ1bmN0aW9uKCl7ZCYmZCgwLDEpfX19fSk7dmFyIGNqPXt9LGNrLGNsLGNtPS9e
KD86dG9nZ2xlfHNob3d8aGlkZSkkLyxjbj0vXihbK1wtXT0pPyhbXGQrLlwtXSspKFthLXolXSop
JC9pLGNvLGNwPVtbImhlaWdodCIsIm1hcmdpblRvcCIsIm1hcmdpbkJvdHRvbSIsInBhZGRpbmdU
b3AiLCJwYWRkaW5nQm90dG9tIl0sWyJ3aWR0aCIsIm1hcmdpbkxlZnQiLCJtYXJnaW5SaWdodCIs
InBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0Il0sWyJvcGFjaXR5Il1dLGNxLGNyPWEud2Via2l0
UmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxhLm1velJlcXVlc3RBbmltYXRpb25GcmFtZXx8YS5vUmVx
dWVzdEFuaW1hdGlvbkZyYW1lO2YuZm4uZXh0ZW5kKHtzaG93OmZ1bmN0aW9uKGEsYixjKXt2YXIg
ZCxlO2lmKGF8fGE9PT0wKXJldHVybiB0aGlzLmFuaW1hdGUoY3UoInNob3ciLDMpLGEsYixjKTtm
b3IodmFyIGc9MCxoPXRoaXMubGVuZ3RoO2c8aDtnKyspZD10aGlzW2ddLGQuc3R5bGUmJihlPWQu
c3R5bGUuZGlzcGxheSwhZi5fZGF0YShkLCJvbGRkaXNwbGF5IikmJmU9PT0ibm9uZSImJihlPWQu
c3R5bGUuZGlzcGxheT0iIiksZT09PSIiJiZmLmNzcyhkLCJkaXNwbGF5Iik9PT0ibm9uZSImJmYu
X2RhdGEoZCwib2xkZGlzcGxheSIsY3YoZC5ub2RlTmFtZSkpKTtmb3IoZz0wO2c8aDtnKyspe2Q9
dGhpc1tnXTtpZihkLnN0eWxlKXtlPWQuc3R5bGUuZGlzcGxheTtpZihlPT09IiJ8fGU9PT0ibm9u
ZSIpZC5zdHlsZS5kaXNwbGF5PWYuX2RhdGEoZCwib2xkZGlzcGxheSIpfHwiIn19cmV0dXJuIHRo
aXN9LGhpZGU6ZnVuY3Rpb24oYSxiLGMpe2lmKGF8fGE9PT0wKXJldHVybiB0aGlzLmFuaW1hdGUo
Y3UoImhpZGUiLDMpLGEsYixjKTtmb3IodmFyIGQ9MCxlPXRoaXMubGVuZ3RoO2Q8ZTtkKyspaWYo
dGhpc1tkXS5zdHlsZSl7dmFyIGc9Zi5jc3ModGhpc1tkXSwiZGlzcGxheSIpO2chPT0ibm9uZSIm
JiFmLl9kYXRhKHRoaXNbZF0sIm9sZGRpc3BsYXkiKSYmZi5fZGF0YSh0aGlzW2RdLCJvbGRkaXNw
bGF5IixnKX1mb3IoZD0wO2Q8ZTtkKyspdGhpc1tkXS5zdHlsZSYmKHRoaXNbZF0uc3R5bGUuZGlz
cGxheT0ibm9uZSIpO3JldHVybiB0aGlzfSxfdG9nZ2xlOmYuZm4udG9nZ2xlLHRvZ2dsZTpmdW5j
dGlvbihhLGIsYyl7dmFyIGQ9dHlwZW9mIGE9PSJib29sZWFuIjtmLmlzRnVuY3Rpb24oYSkmJmYu
aXNGdW5jdGlvbihiKT90aGlzLl90b2dnbGUuYXBwbHkodGhpcyxhcmd1bWVudHMpOmE9PW51bGx8
fGQ/dGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGI9ZD9hOmYodGhpcykuaXMoIjpoaWRkZW4iKTtm
KHRoaXMpW2I/InNob3ciOiJoaWRlIl0oKX0pOnRoaXMuYW5pbWF0ZShjdSgidG9nZ2xlIiwzKSxh
LGIsYyk7cmV0dXJuIHRoaXN9LGZhZGVUbzpmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gdGhpcy5m
aWx0ZXIoIjpoaWRkZW4iKS5jc3MoIm9wYWNpdHkiLDApLnNob3coKS5lbmQoKS5hbmltYXRlKHtv
cGFjaXR5OmJ9LGEsYyxkKX0sYW5pbWF0ZTpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1mLnNwZWVk
KGIsYyxkKTtpZihmLmlzRW1wdHlPYmplY3QoYSkpcmV0dXJuIHRoaXMuZWFjaChlLmNvbXBsZXRl
LFshMV0pO2E9Zi5leHRlbmQoe30sYSk7cmV0dXJuIHRoaXNbZS5xdWV1ZT09PSExPyJlYWNoIjoi
cXVldWUiXShmdW5jdGlvbigpe2UucXVldWU9PT0hMSYmZi5fbWFyayh0aGlzKTt2YXIgYj1mLmV4
dGVuZCh7fSxlKSxjPXRoaXMubm9kZVR5cGU9PT0xLGQ9YyYmZih0aGlzKS5pcygiOmhpZGRlbiIp
LGcsaCxpLGosayxsLG0sbixvO2IuYW5pbWF0ZWRQcm9wZXJ0aWVzPXt9O2ZvcihpIGluIGEpe2c9
Zi5jYW1lbENhc2UoaSksaSE9PWcmJihhW2ddPWFbaV0sZGVsZXRlIGFbaV0pLGg9YVtnXSxmLmlz
QXJyYXkoaCk/KGIuYW5pbWF0ZWRQcm9wZXJ0aWVzW2ddPWhbMV0saD1hW2ddPWhbMF0pOmIuYW5p
bWF0ZWRQcm9wZXJ0aWVzW2ddPWIuc3BlY2lhbEVhc2luZyYmYi5zcGVjaWFsRWFzaW5nW2ddfHxi
LmVhc2luZ3x8InN3aW5nIjtpZihoPT09ImhpZGUiJiZkfHxoPT09InNob3ciJiYhZClyZXR1cm4g
Yi5jb21wbGV0ZS5jYWxsKHRoaXMpO2MmJihnPT09ImhlaWdodCJ8fGc9PT0id2lkdGgiKSYmKGIu
b3ZlcmZsb3c9W3RoaXMuc3R5bGUub3ZlcmZsb3csdGhpcy5zdHlsZS5vdmVyZmxvd1gsdGhpcy5z
dHlsZS5vdmVyZmxvd1ldLGYuY3NzKHRoaXMsImRpc3BsYXkiKT09PSJpbmxpbmUiJiZmLmNzcyh0
aGlzLCJmbG9hdCIpPT09Im5vbmUiJiYoZi5zdXBwb3J0LmlubGluZUJsb2NrTmVlZHNMYXlvdXQ/
KGo9Y3YodGhpcy5ub2RlTmFtZSksaj09PSJpbmxpbmUiP3RoaXMuc3R5bGUuZGlzcGxheT0iaW5s
aW5lLWJsb2NrIjoodGhpcy5zdHlsZS5kaXNwbGF5PSJpbmxpbmUiLHRoaXMuc3R5bGUuem9vbT0x
KSk6dGhpcy5zdHlsZS5kaXNwbGF5PSJpbmxpbmUtYmxvY2siKSl9Yi5vdmVyZmxvdyE9bnVsbCYm
KHRoaXMuc3R5bGUub3ZlcmZsb3c9ImhpZGRlbiIpO2ZvcihpIGluIGEpaz1uZXcgZi5meCh0aGlz
LGIsaSksaD1hW2ldLGNtLnRlc3QoaCk/a1toPT09InRvZ2dsZSI/ZD8ic2hvdyI6ImhpZGUiOmhd
KCk6KGw9Y24uZXhlYyhoKSxtPWsuY3VyKCksbD8obj1wYXJzZUZsb2F0KGxbMl0pLG89bFszXXx8
KGYuY3NzTnVtYmVyW2ldPyIiOiJweCIpLG8hPT0icHgiJiYoZi5zdHlsZSh0aGlzLGksKG58fDEp
K28pLG09KG58fDEpL2suY3VyKCkqbSxmLnN0eWxlKHRoaXMsaSxtK28pKSxsWzFdJiYobj0obFsx
XT09PSItPSI/LTE6MSkqbittKSxrLmN1c3RvbShtLG4sbykpOmsuY3VzdG9tKG0saCwiIikpO3Jl
dHVybiEwfSl9LHN0b3A6ZnVuY3Rpb24oYSxiKXthJiZ0aGlzLnF1ZXVlKFtdKSx0aGlzLmVhY2go
ZnVuY3Rpb24oKXt2YXIgYT1mLnRpbWVycyxjPWEubGVuZ3RoO2J8fGYuX3VubWFyayghMCx0aGlz
KTt3aGlsZShjLS0pYVtjXS5lbGVtPT09dGhpcyYmKGImJmFbY10oITApLGEuc3BsaWNlKGMsMSkp
fSksYnx8dGhpcy5kZXF1ZXVlKCk7cmV0dXJuIHRoaXN9fSksZi5lYWNoKHtzbGlkZURvd246Y3Uo
InNob3ciLDEpLHNsaWRlVXA6Y3UoImhpZGUiLDEpLHNsaWRlVG9nZ2xlOmN1KCJ0b2dnbGUiLDEp
LGZhZGVJbjp7b3BhY2l0eToic2hvdyJ9LGZhZGVPdXQ6e29wYWNpdHk6ImhpZGUifSxmYWRlVG9n
Z2xlOntvcGFjaXR5OiJ0b2dnbGUifX0sZnVuY3Rpb24oYSxiKXtmLmZuW2FdPWZ1bmN0aW9uKGEs
YyxkKXtyZXR1cm4gdGhpcy5hbmltYXRlKGIsYSxjLGQpfX0pLGYuZXh0ZW5kKHtzcGVlZDpmdW5j
dGlvbihhLGIsYyl7dmFyIGQ9YSYmdHlwZW9mIGE9PSJvYmplY3QiP2YuZXh0ZW5kKHt9LGEpOntj
b21wbGV0ZTpjfHwhYyYmYnx8Zi5pc0Z1bmN0aW9uKGEpJiZhLGR1cmF0aW9uOmEsZWFzaW5nOmMm
JmJ8fGImJiFmLmlzRnVuY3Rpb24oYikmJmJ9O2QuZHVyYXRpb249Zi5meC5vZmY/MDp0eXBlb2Yg
ZC5kdXJhdGlvbj09Im51bWJlciI/ZC5kdXJhdGlvbjpkLmR1cmF0aW9uIGluIGYuZnguc3BlZWRz
P2YuZnguc3BlZWRzW2QuZHVyYXRpb25dOmYuZnguc3BlZWRzLl9kZWZhdWx0LGQub2xkPWQuY29t
cGxldGUsZC5jb21wbGV0ZT1mdW5jdGlvbihhKXtkLnF1ZXVlIT09ITE/Zi5kZXF1ZXVlKHRoaXMp
OmEhPT0hMSYmZi5fdW5tYXJrKHRoaXMpLGYuaXNGdW5jdGlvbihkLm9sZCkmJmQub2xkLmNhbGwo
dGhpcyl9O3JldHVybiBkfSxlYXNpbmc6e2xpbmVhcjpmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4g
YytkKmF9LHN3aW5nOmZ1bmN0aW9uKGEsYixjLGQpe3JldHVybigtTWF0aC5jb3MoYSpNYXRoLlBJ
KS8yKy41KSpkK2N9fSx0aW1lcnM6W10sZng6ZnVuY3Rpb24oYSxiLGMpe3RoaXMub3B0aW9ucz1i
LHRoaXMuZWxlbT1hLHRoaXMucHJvcD1jLGIub3JpZz1iLm9yaWd8fHt9fX0pLGYuZngucHJvdG90
eXBlPXt1cGRhdGU6ZnVuY3Rpb24oKXt0aGlzLm9wdGlvbnMuc3RlcCYmdGhpcy5vcHRpb25zLnN0
ZXAuY2FsbCh0aGlzLmVsZW0sdGhpcy5ub3csdGhpcyksKGYuZnguc3RlcFt0aGlzLnByb3BdfHxm
LmZ4LnN0ZXAuX2RlZmF1bHQpKHRoaXMpfSxjdXI6ZnVuY3Rpb24oKXtpZih0aGlzLmVsZW1bdGhp
cy5wcm9wXSE9bnVsbCYmKCF0aGlzLmVsZW0uc3R5bGV8fHRoaXMuZWxlbS5zdHlsZVt0aGlzLnBy
b3BdPT1udWxsKSlyZXR1cm4gdGhpcy5lbGVtW3RoaXMucHJvcF07dmFyIGEsYj1mLmNzcyh0aGlz
LmVsZW0sdGhpcy5wcm9wKTtyZXR1cm4gaXNOYU4oYT1wYXJzZUZsb2F0KGIpKT8hYnx8Yj09PSJh
dXRvIj8wOmI6YX0sY3VzdG9tOmZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBoKGEpe3JldHVybiBk
LnN0ZXAoYSl9dmFyIGQ9dGhpcyxlPWYuZngsZzt0aGlzLnN0YXJ0VGltZT1jcXx8Y3MoKSx0aGlz
LnN0YXJ0PWEsdGhpcy5lbmQ9Yix0aGlzLnVuaXQ9Y3x8dGhpcy51bml0fHwoZi5jc3NOdW1iZXJb
dGhpcy5wcm9wXT8iIjoicHgiKSx0aGlzLm5vdz10aGlzLnN0YXJ0LHRoaXMucG9zPXRoaXMuc3Rh
dGU9MCxoLmVsZW09dGhpcy5lbGVtLGgoKSYmZi50aW1lcnMucHVzaChoKSYmIWNvJiYoY3I/KGNv
PTEsZz1mdW5jdGlvbigpe2NvJiYoY3IoZyksZS50aWNrKCkpfSxjcihnKSk6Y289c2V0SW50ZXJ2
YWwoZS50aWNrLGUuaW50ZXJ2YWwpKX0sc2hvdzpmdW5jdGlvbigpe3RoaXMub3B0aW9ucy5vcmln
W3RoaXMucHJvcF09Zi5zdHlsZSh0aGlzLmVsZW0sdGhpcy5wcm9wKSx0aGlzLm9wdGlvbnMuc2hv
dz0hMCx0aGlzLmN1c3RvbSh0aGlzLnByb3A9PT0id2lkdGgifHx0aGlzLnByb3A9PT0iaGVpZ2h0
Ij8xOjAsdGhpcy5jdXIoKSksZih0aGlzLmVsZW0pLnNob3coKX0saGlkZTpmdW5jdGlvbigpe3Ro
aXMub3B0aW9ucy5vcmlnW3RoaXMucHJvcF09Zi5zdHlsZSh0aGlzLmVsZW0sdGhpcy5wcm9wKSx0
aGlzLm9wdGlvbnMuaGlkZT0hMCx0aGlzLmN1c3RvbSh0aGlzLmN1cigpLDApfSxzdGVwOmZ1bmN0
aW9uKGEpe3ZhciBiPWNxfHxjcygpLGM9ITAsZD10aGlzLmVsZW0sZT10aGlzLm9wdGlvbnMsZyxo
O2lmKGF8fGI+PWUuZHVyYXRpb24rdGhpcy5zdGFydFRpbWUpe3RoaXMubm93PXRoaXMuZW5kLHRo
aXMucG9zPXRoaXMuc3RhdGU9MSx0aGlzLnVwZGF0ZSgpLGUuYW5pbWF0ZWRQcm9wZXJ0aWVzW3Ro
aXMucHJvcF09ITA7Zm9yKGcgaW4gZS5hbmltYXRlZFByb3BlcnRpZXMpZS5hbmltYXRlZFByb3Bl
cnRpZXNbZ10hPT0hMCYmKGM9ITEpO2lmKGMpe2Uub3ZlcmZsb3chPW51bGwmJiFmLnN1cHBvcnQu
c2hyaW5rV3JhcEJsb2NrcyYmZi5lYWNoKFsiIiwiWCIsIlkiXSxmdW5jdGlvbihhLGIpe2Quc3R5
bGVbIm92ZXJmbG93IitiXT1lLm92ZXJmbG93W2FdfSksZS5oaWRlJiZmKGQpLmhpZGUoKTtpZihl
LmhpZGV8fGUuc2hvdylmb3IodmFyIGkgaW4gZS5hbmltYXRlZFByb3BlcnRpZXMpZi5zdHlsZShk
LGksZS5vcmlnW2ldKTtlLmNvbXBsZXRlLmNhbGwoZCl9cmV0dXJuITF9ZS5kdXJhdGlvbj09SW5m
aW5pdHk/dGhpcy5ub3c9YjooaD1iLXRoaXMuc3RhcnRUaW1lLHRoaXMuc3RhdGU9aC9lLmR1cmF0
aW9uLHRoaXMucG9zPWYuZWFzaW5nW2UuYW5pbWF0ZWRQcm9wZXJ0aWVzW3RoaXMucHJvcF1dKHRo
aXMuc3RhdGUsaCwwLDEsZS5kdXJhdGlvbiksdGhpcy5ub3c9dGhpcy5zdGFydCsodGhpcy5lbmQt
dGhpcy5zdGFydCkqdGhpcy5wb3MpLHRoaXMudXBkYXRlKCk7cmV0dXJuITB9fSxmLmV4dGVuZChm
LmZ4LHt0aWNrOmZ1bmN0aW9uKCl7Zm9yKHZhciBhPWYudGltZXJzLGI9MDtiPGEubGVuZ3RoOysr
YilhW2JdKCl8fGEuc3BsaWNlKGItLSwxKTthLmxlbmd0aHx8Zi5meC5zdG9wKCl9LGludGVydmFs
OjEzLHN0b3A6ZnVuY3Rpb24oKXtjbGVhckludGVydmFsKGNvKSxjbz1udWxsfSxzcGVlZHM6e3Ns
b3c6NjAwLGZhc3Q6MjAwLF9kZWZhdWx0OjQwMH0sc3RlcDp7b3BhY2l0eTpmdW5jdGlvbihhKXtm
LnN0eWxlKGEuZWxlbSwib3BhY2l0eSIsYS5ub3cpfSxfZGVmYXVsdDpmdW5jdGlvbihhKXthLmVs
ZW0uc3R5bGUmJmEuZWxlbS5zdHlsZVthLnByb3BdIT1udWxsP2EuZWxlbS5zdHlsZVthLnByb3Bd
PShhLnByb3A9PT0id2lkdGgifHxhLnByb3A9PT0iaGVpZ2h0Ij9NYXRoLm1heCgwLGEubm93KTph
Lm5vdykrYS51bml0OmEuZWxlbVthLnByb3BdPWEubm93fX19KSxmLmV4cHImJmYuZXhwci5maWx0
ZXJzJiYoZi5leHByLmZpbHRlcnMuYW5pbWF0ZWQ9ZnVuY3Rpb24oYSl7cmV0dXJuIGYuZ3JlcChm
LnRpbWVycyxmdW5jdGlvbihiKXtyZXR1cm4gYT09PWIuZWxlbX0pLmxlbmd0aH0pO3ZhciBjdz0v
XnQoPzphYmxlfGR8aCkkL2ksY3g9L14oPzpib2R5fGh0bWwpJC9pOyJnZXRCb3VuZGluZ0NsaWVu
dFJlY3QiaW4gYy5kb2N1bWVudEVsZW1lbnQ/Zi5mbi5vZmZzZXQ9ZnVuY3Rpb24oYSl7dmFyIGI9
dGhpc1swXSxjO2lmKGEpcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihiKXtmLm9mZnNldC5zZXRP
ZmZzZXQodGhpcyxhLGIpfSk7aWYoIWJ8fCFiLm93bmVyRG9jdW1lbnQpcmV0dXJuIG51bGw7aWYo
Yj09PWIub3duZXJEb2N1bWVudC5ib2R5KXJldHVybiBmLm9mZnNldC5ib2R5T2Zmc2V0KGIpO3Ry
eXtjPWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCl9Y2F0Y2goZCl7fXZhciBlPWIub3duZXJEb2N1
bWVudCxnPWUuZG9jdW1lbnRFbGVtZW50O2lmKCFjfHwhZi5jb250YWlucyhnLGIpKXJldHVybiBj
P3t0b3A6Yy50b3AsbGVmdDpjLmxlZnR9Ont0b3A6MCxsZWZ0OjB9O3ZhciBoPWUuYm9keSxpPWN5
KGUpLGo9Zy5jbGllbnRUb3B8fGguY2xpZW50VG9wfHwwLGs9Zy5jbGllbnRMZWZ0fHxoLmNsaWVu
dExlZnR8fDAsbD1pLnBhZ2VZT2Zmc2V0fHxmLnN1cHBvcnQuYm94TW9kZWwmJmcuc2Nyb2xsVG9w
fHxoLnNjcm9sbFRvcCxtPWkucGFnZVhPZmZzZXR8fGYuc3VwcG9ydC5ib3hNb2RlbCYmZy5zY3Jv
bGxMZWZ0fHxoLnNjcm9sbExlZnQsbj1jLnRvcCtsLWosbz1jLmxlZnQrbS1rO3JldHVybnt0b3A6
bixsZWZ0Om99fTpmLmZuLm9mZnNldD1mdW5jdGlvbihhKXt2YXIgYj10aGlzWzBdO2lmKGEpcmV0
dXJuIHRoaXMuZWFjaChmdW5jdGlvbihiKXtmLm9mZnNldC5zZXRPZmZzZXQodGhpcyxhLGIpfSk7
aWYoIWJ8fCFiLm93bmVyRG9jdW1lbnQpcmV0dXJuIG51bGw7aWYoYj09PWIub3duZXJEb2N1bWVu
dC5ib2R5KXJldHVybiBmLm9mZnNldC5ib2R5T2Zmc2V0KGIpO2Yub2Zmc2V0LmluaXRpYWxpemUo
KTt2YXIgYyxkPWIub2Zmc2V0UGFyZW50LGU9YixnPWIub3duZXJEb2N1bWVudCxoPWcuZG9jdW1l
bnRFbGVtZW50LGk9Zy5ib2R5LGo9Zy5kZWZhdWx0VmlldyxrPWo/ai5nZXRDb21wdXRlZFN0eWxl
KGIsbnVsbCk6Yi5jdXJyZW50U3R5bGUsbD1iLm9mZnNldFRvcCxtPWIub2Zmc2V0TGVmdDt3aGls
ZSgoYj1iLnBhcmVudE5vZGUpJiZiIT09aSYmYiE9PWgpe2lmKGYub2Zmc2V0LnN1cHBvcnRzRml4
ZWRQb3NpdGlvbiYmay5wb3NpdGlvbj09PSJmaXhlZCIpYnJlYWs7Yz1qP2ouZ2V0Q29tcHV0ZWRT
dHlsZShiLG51bGwpOmIuY3VycmVudFN0eWxlLGwtPWIuc2Nyb2xsVG9wLG0tPWIuc2Nyb2xsTGVm
dCxiPT09ZCYmKGwrPWIub2Zmc2V0VG9wLG0rPWIub2Zmc2V0TGVmdCxmLm9mZnNldC5kb2VzTm90
QWRkQm9yZGVyJiYoIWYub2Zmc2V0LmRvZXNBZGRCb3JkZXJGb3JUYWJsZUFuZENlbGxzfHwhY3cu
dGVzdChiLm5vZGVOYW1lKSkmJihsKz1wYXJzZUZsb2F0KGMuYm9yZGVyVG9wV2lkdGgpfHwwLG0r
PXBhcnNlRmxvYXQoYy5ib3JkZXJMZWZ0V2lkdGgpfHwwKSxlPWQsZD1iLm9mZnNldFBhcmVudCks
Zi5vZmZzZXQuc3VidHJhY3RzQm9yZGVyRm9yT3ZlcmZsb3dOb3RWaXNpYmxlJiZjLm92ZXJmbG93
IT09InZpc2libGUiJiYobCs9cGFyc2VGbG9hdChjLmJvcmRlclRvcFdpZHRoKXx8MCxtKz1wYXJz
ZUZsb2F0KGMuYm9yZGVyTGVmdFdpZHRoKXx8MCksaz1jfWlmKGsucG9zaXRpb249PT0icmVsYXRp
dmUifHxrLnBvc2l0aW9uPT09InN0YXRpYyIpbCs9aS5vZmZzZXRUb3AsbSs9aS5vZmZzZXRMZWZ0
O2Yub2Zmc2V0LnN1cHBvcnRzRml4ZWRQb3NpdGlvbiYmay5wb3NpdGlvbj09PSJmaXhlZCImJihs
Kz1NYXRoLm1heChoLnNjcm9sbFRvcCxpLnNjcm9sbFRvcCksbSs9TWF0aC5tYXgoaC5zY3JvbGxM
ZWZ0LGkuc2Nyb2xsTGVmdCkpO3JldHVybnt0b3A6bCxsZWZ0Om19fSxmLm9mZnNldD17aW5pdGlh
bGl6ZTpmdW5jdGlvbigpe3ZhciBhPWMuYm9keSxiPWMuY3JlYXRlRWxlbWVudCgiZGl2IiksZCxl
LGcsaCxpPXBhcnNlRmxvYXQoZi5jc3MoYSwibWFyZ2luVG9wIikpfHwwLGo9IjxkaXYgc3R5bGU9
J3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDttYXJnaW46MDtib3JkZXI6NXB4IHNvbGlk
ICMwMDA7cGFkZGluZzowO3dpZHRoOjFweDtoZWlnaHQ6MXB4Oyc+PGRpdj48L2Rpdj48L2Rpdj48
dGFibGUgc3R5bGU9J3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDttYXJnaW46MDtib3Jk
ZXI6NXB4IHNvbGlkICMwMDA7cGFkZGluZzowO3dpZHRoOjFweDtoZWlnaHQ6MXB4OycgY2VsbHBh
ZGRpbmc9JzAnIGNlbGxzcGFjaW5nPScwJz48dHI+PHRkPjwvdGQ+PC90cj48L3RhYmxlPiI7Zi5l
eHRlbmQoYi5zdHlsZSx7cG9zaXRpb246ImFic29sdXRlIix0b3A6MCxsZWZ0OjAsbWFyZ2luOjAs
Ym9yZGVyOjAsd2lkdGg6IjFweCIsaGVpZ2h0OiIxcHgiLHZpc2liaWxpdHk6ImhpZGRlbiJ9KSxi
LmlubmVySFRNTD1qLGEuaW5zZXJ0QmVmb3JlKGIsYS5maXJzdENoaWxkKSxkPWIuZmlyc3RDaGls
ZCxlPWQuZmlyc3RDaGlsZCxoPWQubmV4dFNpYmxpbmcuZmlyc3RDaGlsZC5maXJzdENoaWxkLHRo
aXMuZG9lc05vdEFkZEJvcmRlcj1lLm9mZnNldFRvcCE9PTUsdGhpcy5kb2VzQWRkQm9yZGVyRm9y
VGFibGVBbmRDZWxscz1oLm9mZnNldFRvcD09PTUsZS5zdHlsZS5wb3NpdGlvbj0iZml4ZWQiLGUu
c3R5bGUudG9wPSIyMHB4Iix0aGlzLnN1cHBvcnRzRml4ZWRQb3NpdGlvbj1lLm9mZnNldFRvcD09
PTIwfHxlLm9mZnNldFRvcD09PTE1LGUuc3R5bGUucG9zaXRpb249ZS5zdHlsZS50b3A9IiIsZC5z
dHlsZS5vdmVyZmxvdz0iaGlkZGVuIixkLnN0eWxlLnBvc2l0aW9uPSJyZWxhdGl2ZSIsdGhpcy5z
dWJ0cmFjdHNCb3JkZXJGb3JPdmVyZmxvd05vdFZpc2libGU9ZS5vZmZzZXRUb3A9PT0tNSx0aGlz
LmRvZXNOb3RJbmNsdWRlTWFyZ2luSW5Cb2R5T2Zmc2V0PWEub2Zmc2V0VG9wIT09aSxhLnJlbW92
ZUNoaWxkKGIpLGYub2Zmc2V0LmluaXRpYWxpemU9Zi5ub29wfSxib2R5T2Zmc2V0OmZ1bmN0aW9u
KGEpe3ZhciBiPWEub2Zmc2V0VG9wLGM9YS5vZmZzZXRMZWZ0O2Yub2Zmc2V0LmluaXRpYWxpemUo
KSxmLm9mZnNldC5kb2VzTm90SW5jbHVkZU1hcmdpbkluQm9keU9mZnNldCYmKGIrPXBhcnNlRmxv
YXQoZi5jc3MoYSwibWFyZ2luVG9wIikpfHwwLGMrPXBhcnNlRmxvYXQoZi5jc3MoYSwibWFyZ2lu
TGVmdCIpKXx8MCk7cmV0dXJue3RvcDpiLGxlZnQ6Y319LHNldE9mZnNldDpmdW5jdGlvbihhLGIs
Yyl7dmFyIGQ9Zi5jc3MoYSwicG9zaXRpb24iKTtkPT09InN0YXRpYyImJihhLnN0eWxlLnBvc2l0
aW9uPSJyZWxhdGl2ZSIpO3ZhciBlPWYoYSksZz1lLm9mZnNldCgpLGg9Zi5jc3MoYSwidG9wIiks
aT1mLmNzcyhhLCJsZWZ0Iiksaj0oZD09PSJhYnNvbHV0ZSJ8fGQ9PT0iZml4ZWQiKSYmZi5pbkFy
cmF5KCJhdXRvIixbaCxpXSk+LTEsaz17fSxsPXt9LG0sbjtqPyhsPWUucG9zaXRpb24oKSxtPWwu
dG9wLG49bC5sZWZ0KToobT1wYXJzZUZsb2F0KGgpfHwwLG49cGFyc2VGbG9hdChpKXx8MCksZi5p
c0Z1bmN0aW9uKGIpJiYoYj1iLmNhbGwoYSxjLGcpKSxiLnRvcCE9bnVsbCYmKGsudG9wPWIudG9w
LWcudG9wK20pLGIubGVmdCE9bnVsbCYmKGsubGVmdD1iLmxlZnQtZy5sZWZ0K24pLCJ1c2luZyJp
biBiP2IudXNpbmcuY2FsbChhLGspOmUuY3NzKGspfX0sZi5mbi5leHRlbmQoe3Bvc2l0aW9uOmZ1
bmN0aW9uKCl7aWYoIXRoaXNbMF0pcmV0dXJuIG51bGw7dmFyIGE9dGhpc1swXSxiPXRoaXMub2Zm
c2V0UGFyZW50KCksYz10aGlzLm9mZnNldCgpLGQ9Y3gudGVzdChiWzBdLm5vZGVOYW1lKT97dG9w
OjAsbGVmdDowfTpiLm9mZnNldCgpO2MudG9wLT1wYXJzZUZsb2F0KGYuY3NzKGEsIm1hcmdpblRv
cCIpKXx8MCxjLmxlZnQtPXBhcnNlRmxvYXQoZi5jc3MoYSwibWFyZ2luTGVmdCIpKXx8MCxkLnRv
cCs9cGFyc2VGbG9hdChmLmNzcyhiWzBdLCJib3JkZXJUb3BXaWR0aCIpKXx8MCxkLmxlZnQrPXBh
cnNlRmxvYXQoZi5jc3MoYlswXSwiYm9yZGVyTGVmdFdpZHRoIikpfHwwO3JldHVybnt0b3A6Yy50
b3AtZC50b3AsbGVmdDpjLmxlZnQtZC5sZWZ0fX0sb2Zmc2V0UGFyZW50OmZ1bmN0aW9uKCl7cmV0
dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vZmZzZXRQYXJlbnR8fGMuYm9keTt3
aGlsZShhJiYhY3gudGVzdChhLm5vZGVOYW1lKSYmZi5jc3MoYSwicG9zaXRpb24iKT09PSJzdGF0
aWMiKWE9YS5vZmZzZXRQYXJlbnQ7cmV0dXJuIGF9KX19KSxmLmVhY2goWyJMZWZ0IiwiVG9wIl0s
ZnVuY3Rpb24oYSxjKXt2YXIgZD0ic2Nyb2xsIitjO2YuZm5bZF09ZnVuY3Rpb24oYyl7dmFyIGUs
ZztpZihjPT09Yil7ZT10aGlzWzBdO2lmKCFlKXJldHVybiBudWxsO2c9Y3koZSk7cmV0dXJuIGc/
InBhZ2VYT2Zmc2V0ImluIGc/Z1thPyJwYWdlWU9mZnNldCI6InBhZ2VYT2Zmc2V0Il06Zi5zdXBw
b3J0LmJveE1vZGVsJiZnLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtkXXx8Zy5kb2N1bWVudC5i
b2R5W2RdOmVbZF19cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe2c9Y3kodGhpcyksZz9nLnNj
cm9sbFRvKGE/ZihnKS5zY3JvbGxMZWZ0KCk6YyxhP2M6ZihnKS5zY3JvbGxUb3AoKSk6dGhpc1tk
XT1jfSl9fSksZi5lYWNoKFsiSGVpZ2h0IiwiV2lkdGgiXSxmdW5jdGlvbihhLGMpe3ZhciBkPWMu
dG9Mb3dlckNhc2UoKTtmLmZuWyJpbm5lciIrY109ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1swXT9w
YXJzZUZsb2F0KGYuY3NzKHRoaXNbMF0sZCwicGFkZGluZyIpKTpudWxsfSxmLmZuWyJvdXRlciIr
Y109ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXNbMF0/cGFyc2VGbG9hdChmLmNzcyh0aGlzWzBdLGQs
YT8ibWFyZ2luIjoiYm9yZGVyIikpOm51bGx9LGYuZm5bZF09ZnVuY3Rpb24oYSl7dmFyIGU9dGhp
c1swXTtpZighZSlyZXR1cm4gYT09bnVsbD9udWxsOnRoaXM7aWYoZi5pc0Z1bmN0aW9uKGEpKXJl
dHVybiB0aGlzLmVhY2goZnVuY3Rpb24oYil7dmFyIGM9Zih0aGlzKTtjW2RdKGEuY2FsbCh0aGlz
LGIsY1tkXSgpKSl9KTtpZihmLmlzV2luZG93KGUpKXt2YXIgZz1lLmRvY3VtZW50LmRvY3VtZW50
RWxlbWVudFsiY2xpZW50IitjXTtyZXR1cm4gZS5kb2N1bWVudC5jb21wYXRNb2RlPT09IkNTUzFD
b21wYXQiJiZnfHxlLmRvY3VtZW50LmJvZHlbImNsaWVudCIrY118fGd9aWYoZS5ub2RlVHlwZT09
PTkpcmV0dXJuIE1hdGgubWF4KGUuZG9jdW1lbnRFbGVtZW50WyJjbGllbnQiK2NdLGUuYm9keVsi
c2Nyb2xsIitjXSxlLmRvY3VtZW50RWxlbWVudFsic2Nyb2xsIitjXSxlLmJvZHlbIm9mZnNldCIr
Y10sZS5kb2N1bWVudEVsZW1lbnRbIm9mZnNldCIrY10pO2lmKGE9PT1iKXt2YXIgaD1mLmNzcyhl
LGQpLGk9cGFyc2VGbG9hdChoKTtyZXR1cm4gZi5pc05hTihpKT9oOml9cmV0dXJuIHRoaXMuY3Nz
KGQsdHlwZW9mIGE9PSJzdHJpbmciP2E6YSsicHgiKX19KSxhLmpRdWVyeT1hLiQ9Zn0pKHdpbmRv
dyk7IAk8L3NjcmlwdD4NCgk8L3NjcmlwdD4NCiAgICA8c2NyaXB0IGxhbmd1YWdlPSJqYXZhc2Ny
aXB0IiB0eXBlPSJ0ZXh0L2phdmFzY3JpcHQiPg0KICAgIC8qIGpxdWVyeSBsaXN0bmF2IHBsdWdp
biAqLw0KICAgIGV2YWwoZnVuY3Rpb24ocCwgYSwgYywgaywgZSwgcikgeyBlID0gZnVuY3Rpb24o
YykgeyByZXR1cm4gKGMgPCBhID8gJycgOiBlKHBhcnNlSW50KGMgLyBhKSkpICsgKChjID0gYyAl
IGEpID4gMzUgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGMgKyAyOSkgOiBjLnRvU3RyaW5nKDM2KSkg
fTsgaWYgKCEnJy5yZXBsYWNlKC9eLywgU3RyaW5nKSkgeyB3aGlsZSAoYy0tKSByW2UoYyldID0g
a1tjXSB8fCBlKGMpOyBrID0gW2Z1bmN0aW9uKGUpIHsgcmV0dXJuIHJbZV0gfSBdOyBlID0gZnVu
Y3Rpb24oKSB7IHJldHVybiAnXFx3KycgfTsgYyA9IDEgfTsgd2hpbGUgKGMtLSkgaWYgKGtbY10p
IHAgPSBwLnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxiJyArIGUoYykgKyAnXFxiJywgJ2cnKSwga1tj
XSk7IHJldHVybiBwIH0gKCcoMygkKXskLjE1LjE2PTMoZil7NCBnPSQuMU8oe30sJC4xNS4xNi4x
bSxmKTs0IGg9W1wnVFwnLFwnYVwnLFwnYlwnLFwnY1wnLFwnZFwnLFwnZVwnLFwnZlwnLFwnZ1wn
LFwnaFwnLFwnaVwnLFwnalwnLFwna1wnLFwnbFwnLFwnbVwnLFwnblwnLFwnb1wnLFwncFwnLFwn
cVwnLFwnclwnLFwnc1wnLFwndFwnLFwndVwnLFwndlwnLFwnd1wnLFwneFwnLFwneVwnLFwnelwn
LFwnLVwnXTs0IGo9RTtnLks9JC4xUChnLkssMyhuKXtGIG4uMTcoKX0pO0YgNy4xbigzKCl7NCBk
LDgsJDgsJDUsJEcsVTtVPTcuVTtkPSQoXCcjXCcrVStcJy0xUVwnKTskOD0kKDcpOzQgZT17fSwx
OD0wLFY9QSwxUj0wLFg9XCdcJzszIDFvKCl7ZC4xcCgxcSgpKTskNT0kKFwnLjYtNVwnLGQpLkwo
MCwxKTsyKGcuTSkkRz0kKFwnLjYtMXItMXNcJyxkKS5MKDAsMSk7MXQoKTsxdSgpOzIoZy4xdikx
dygpOzF4KCk7MighZy5ZKSQ4Lk4oKTsyKCFnLlkpJChcJy5PXCcsJDUpLjE5KCk7MighZy4xYSkk
KFwnLlRcJywkNSkuMTkoKTsyKCFnLjFTKSQoXCcuLVwnLCQ1KS4xOSgpOyQoXCc6MXlcJywkNSku
UChcJzYtMXlcJyk7MigkLlomJihnLlEhPUgpKXs0IGE9JC5aKGcuUSk7MihhIT1IKWcuMTA9YX0y
KGcuMTAhPVwnXCcpe2o9QTskKFwnLlwnK2cuMTAuMTcoKSwkNSkuTCgwLDEpLjFiKCl9RHsyKGcu
WSkkKFwnLk9cJywkNSkuUChcJzYtMTFcJyk7RHsxYyg0IGk9KChnLjFhKT8wOjEpO2k8aC5JO2kr
Kyl7MihlW2hbaV1dPjApe2o9QTskKFwnLlwnK2hbaV0sJDUpLkwoMCwxKS4xYigpOzFUfX19fX0z
IDF6KCl7JEcuMUEoezFkOiQoXCcuYVwnLCQ1KS5MKDAsMSkuMVUoezFlOkUsMVY6QX0pLjFkLSRH
LjFXKHsxZTpBfSl9KX0zIDF0KCl7NCBhLEosMVgsUiwkNywxQj0oZy5LLkk+MCk7JCgkOCkuQigp
LjFuKDMoKXskNz0kKDcpLEo9XCdcJyxhPSQuMVkoJDcuMUMoKSkuMTcoKTsyKGEhPVwnXCcpezIo
MUIpe1I9YS4xZihcJyBcJyk7MigoUi5JPjEpJiYoJC4xWihSWzBdLGcuSyk+LTEpKXtKPVJbMV0u
MUQoMCk7MWcoSiwkNyxBKX19Sj1hLjFEKDApOzFnKEosJDcpfX0pfTMgMWcoYSxiLGMpezIoL1xc
Vy8uMjAoYSkpYT1cJy1cJzsyKCEyMShhKSlhPVwnVFwnO2IuUChcJzYtXCcrYSk7MihlW2FdPT0x
aCllW2FdPTA7ZVthXSsrOzIoIWMpMTgrK30zIDF3KCl7MWMoNCBpPTA7aTxoLkk7aSsrKXsyKGVb
aFtpXV09PTFoKSQoXCcuXCcraFtpXSwkNSkuUChcJzYtMjJcJyl9fTMgMXUoKXskOC4xcChcJzwx
RSBDPSI2LTEyLTEzIiAxRj0iMUc6MUgiPlwnK2cuMUkrXCc8LzFFPlwnKX0zIDFpKGEpezIoJChh
KS4yMyhcJ09cJykpRiAxODtEezQgYj1lWyQoYSkuMUooXCdDXCcpLjFmKFwnIFwnKVswXV07Rihi
IT0xaCk/YjowfX0zIDF4KCl7MihnLk0pe2QuMUsoMygpezF6KCl9KX0yKGcuTSl7JChcJ2FcJywk
NSkuMUsoMygpezQgYT0kKDcpLjFMKCkuMWo7NCBiPSgkKDcpLjI0KHsxZTpBfSktMSkrXCcyNVwn
OzQgYz0xaSg3KTskRy4xQSh7MWo6YSwxTTpifSkuMUMoYykuTigpfSk7JChcJ2FcJywkNSkuMjYo
MygpeyRHLlMoKX0pfSQoXCdhXCcsJDUpLjFiKDMoKXskKFwnYS42LTExXCcsJDUpLjI3KFwnNi0x
MVwnKTs0IGE9JCg3KS4xSihcJ0NcJykuMWYoXCcgXCcpWzBdOzIoYT09XCdPXCcpeyQ4LkIoKS5O
KCk7JDguQihcJy42LTEyLTEzXCcpLlMoKTtWPUF9RHsyKFYpeyQ4LkIoKS5TKCk7Vj1FfUQgMihY
IT1cJ1wnKSQ4LkIoXCcuNi1cJytYKS5TKCk7NCBiPTFpKDcpOzIoYj4wKXskOC5CKFwnLjYtMTIt
MTNcJykuUygpOyQ4LkIoXCcuNi1cJythKS5OKCl9RCAkOC5CKFwnLjYtMTItMTNcJykuTigpO1g9
YX0yKCQuWiYmKGcuUSE9SCkpJC5aKGcuUSxhKTskKDcpLlAoXCc2LTExXCcpOyQoNykuMjgoKTsy
KCFqJiYoZy4xayE9SCkpZy4xayhhKTtEIGo9RTtGIEV9KX0zIDFxKCl7NCBhPVtdOzFjKDQgaT0x
O2k8aC5JO2krKyl7MihhLkk9PTApYS4xTihcJzxhIEM9Ik8iIDFsPSIjIj4yOTwvYT48YSBDPSJU
IiAxbD0iIyI+MC05PC9hPlwnKTthLjFOKFwnPGEgQz0iXCcraFtpXStcJyIgMWw9IiMiPlwnKygo
aFtpXT09XCctXCcpP1wnLi4uXCc6aFtpXS4yYSgpKStcJzwvYT5cJyl9RlwnPDE0IEM9IjYtNSI+
XCcrYS4yYihcJ1wnKStcJzwvMTQ+XCcrKChnLk0pP1wnPDE0IEM9IjYtMXItMXMiIDFGPSIxRzox
SDsgMUw6MmM7IDFkOjA7IDFqOjA7IDFNOjJkOyI+MDwvMTQ+XCc6XCdcJyl9MW8oKX0pfTskLjE1
LjE2LjFtPXsxMDpcJ1wnLFk6QSwyZTpFLDFhOkEsMXY6QSwxSTpcJzJmIDJnIDJoXCcsTTpBLFE6
SCwxazpILEs6W119fSkoMmkpOycsIDYyLCAxNDMsICd8fGlmfGZ1bmN0aW9ufHZhcnxsZXR0ZXJz
fGxufHRoaXN8bGlzdHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx0cnVlfGNoaWxkcmVufGNs
YXNzfGVsc2V8ZmFsc2V8cmV0dXJufGxldHRlckNvdW50fG51bGx8bGVuZ3RofGZpcnN0Q2hhcnxw
cmVmaXhlc3xzbGljZXxzaG93Q291bnRzfHNob3d8YWxsfGFkZENsYXNzfGNvb2tpZU5hbWV8c3Bs
fGhpZGV8X3xpZHxpc0FsbHx8cHJldkxldHRlcnxpbmNsdWRlQWxsfGNvb2tpZXxpbml0TGV0dGVy
fHNlbGVjdGVkfG5vfG1hdGNofGRpdnxmbnxsaXN0bmF2fHRvTG93ZXJDYXNlfGFsbENvdW50fHJl
bW92ZXxpbmNsdWRlTnVtc3xjbGlja3xmb3J8dG9wfG1hcmdpbnxzcGxpdHxhZGRMZXR0ZXJDbGFz
c3x1bmRlZmluZWR8Z2V0TGV0dGVyQ291bnR8bGVmdHxvbkNsaWNrfGhyZWZ8ZGVmYXVsdHN8ZWFj
aHxpbml0fGFwcGVuZHxjcmVhdGVMZXR0ZXJzSHRtbHxsZXR0ZXJ8Y291bnR8YWRkQ2xhc3Nlc3xh
ZGROb01hdGNoTEl8ZmxhZ0Rpc2FibGVkfGFkZERpc2FibGVkQ2xhc3N8YmluZEhhbmRsZXJzfGxh
c3R8c2V0TGV0dGVyQ291bnRUb3B8Y3NzfGhhc1ByZWZpeGVzfHRleHR8Y2hhckF0fGxpfHN0eWxl
fGRpc3BsYXl8bm9uZXxub01hdGNoVGV4dHxhdHRyfG1vdXNlb3Zlcnxwb3NpdGlvbnx3aWR0aHxw
dXNofGV4dGVuZHxtYXB8bmF2fG51bUNvdW50fGluY2x1ZGVPdGhlcnxicmVha3xvZmZzZXR8Ym9y
ZGVyfG91dGVySGVpZ2h0fGZpcnN0V29yZHx0cmltfGluQXJyYXl8dGVzdHxpc05hTnxkaXNhYmxl
ZHxoYXNDbGFzc3xvdXRlcldpZHRofHB4fG1vdXNlb3V0fHJlbW92ZUNsYXNzfGJsdXJ8QUxMfHRv
VXBwZXJDYXNlfGpvaW58YWJzb2x1dGV8MjBweHxpbmN1ZGVPdGhlcnxOb3xtYXRjaGluZ3xlbnRy
aWVzfGpRdWVyeScuc3BsaXQoJ3wnKSwgMCwge30pKQ0KICAgIDwvc2NyaXB0Pg0KICAgIDxzY3Jp
cHQgbGFuZ3VhZ2U9ImphdmFzY3JpcHQiIHR5cGU9InRleHQvamF2YXNjcmlwdCI+DQoJLyogSmF2
YXNjcmlwdCBwbG90dGluZyBsaWJyYXJ5IGZvciBqUXVlcnksIHYuIDAuNy4gKGh0dHA6Ly9jb2Rl
Lmdvb2dsZS5jb20vcC9mbG90LykgKi8NCgkoZnVuY3Rpb24obil7bi5jb2xvcj17fTtuLmNvbG9y
Lm1ha2U9ZnVuY3Rpb24oeCxnLHAsVyl7dmFyIGw9e307bC5yPXh8fDA7bC5nPWd8fDA7bC5iPXB8
fDA7bC5hPVchPW51bGw/VzoxO2wuYWRkPWZ1bmN0aW9uKGcsbil7Zm9yKHZhciBwPTA7cDxnLmxl
bmd0aDsrK3ApbFtnLmNoYXJBdChwKV0rPW47cmV0dXJuIGwubm9ybWFsaXplKCl9O2wuc2NhbGU9
ZnVuY3Rpb24oZyxuKXtmb3IodmFyIHA9MDtwPGcubGVuZ3RoOysrcClsW2cuY2hhckF0KHApXSo9
bjtyZXR1cm4gbC5ub3JtYWxpemUoKX07bC50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiBsLmE+
PTE/InJnYigiK1tsLnIsbC5nLGwuYl0uam9pbigiLCIpKyIpIjoicmdiYSgiK1tsLnIsbC5nLGwu
YixsLmFdLmpvaW4oIiwiKSsiKSJ9O2wubm9ybWFsaXplPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZyhu
LGwscCl7cmV0dXJuIGw8bj9uOmw+cD9wOmx9bC5yPWcoMCxwYXJzZUludChsLnIpLDI1NSk7bC5n
PWcoMCxwYXJzZUludChsLmcpLCAyNTUpO2wuYj1nKDAscGFyc2VJbnQobC5iKSwyNTUpO2wuYT1n
KDAsbC5hLDEpO3JldHVybiBsfTtsLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIG4uY29sb3IubWFr
ZShsLnIsbC5iLGwuZyxsLmEpfTtyZXR1cm4gbC5ub3JtYWxpemUoKX07bi5jb2xvci5leHRyYWN0
PWZ1bmN0aW9uKHgsZyl7dmFyIHA7ZG97cD14LmNzcyhnKS50b0xvd2VyQ2FzZSgpO2lmKHAhPSIi
JiZwIT0idHJhbnNwYXJlbnQiKWJyZWFrO3g9eC5wYXJlbnQoKX13aGlsZSghbi5ub2RlTmFtZSh4
LmdldCgwKSwiYm9keSIpKTtwPT0icmdiYSgwLCAwLCAwLCAwKSImJihwPSJ0cmFuc3BhcmVudCIp
O3JldHVybiBuLmNvbG9yLnBhcnNlKHApfTtuLmNvbG9yLnBhcnNlPWZ1bmN0aW9uKHgpe3ZhciBn
LHA9bi5jb2xvci5tYWtlO2lmKGc9L3JnYlwoXHMqKFswLTldezEsM30pXHMqLFxzKihbMC05XXsx
LDN9KVxzKixccyooWzAtOV17MSwzfSlccypcKS8uZXhlYyh4KSlyZXR1cm4gcChwYXJzZUludChn
WzFdLDEwKSwgcGFyc2VJbnQoZ1syXSwxMCkscGFyc2VJbnQoZ1szXSwxMCkpO2lmKGc9L3JnYmFc
KFxzKihbMC05XXsxLDN9KVxzKixccyooWzAtOV17MSwzfSlccyosXHMqKFswLTldezEsM30pXHMq
LFxzKihbMC05XSsoPzpcLlswLTldKyk/KVxzKlwpLy5leGVjKHgpKXJldHVybiBwKHBhcnNlSW50
KGdbMV0sMTApLHBhcnNlSW50KGdbMl0sMTApLHBhcnNlSW50KGdbM10sMTApLHBhcnNlRmxvYXQo
Z1s0XSkpO2lmKGc9L3JnYlwoXHMqKFswLTldKyg/OlwuWzAtOV0rKT8pXCVccyosXHMqKFswLTld
Kyg/OlwuWzAtOV0rKT8pXCVccyosXHMqKFswLTldKyg/OlwuWzAtOV0rKT8pXCVccypcKS8uZXhl
Yyh4KSlyZXR1cm4gcChwYXJzZUZsb2F0KGdbMV0pKjIuNTUscGFyc2VGbG9hdChnWzJdKSoyLjU1
LHBhcnNlRmxvYXQoZ1szXSkqMi41NSk7aWYoZz0vcmdiYVwoXHMqKFswLTldKyg/OlwuWzAtOV0r
KT8pXCVccyosXHMqKFswLTldKyg/OlwuWzAtOV0rKT8pXCVccyosXHMqKFswLTldKyg/OlwuWzAt
OV0rKT8pXCVccyosXHMqKFswLTldKyg/OlwuWzAtOV0rKT8pXHMqXCkvLmV4ZWMoeCkpcmV0dXJu
IHAocGFyc2VGbG9hdChnWzFdKSogMi41NSxwYXJzZUZsb2F0KGdbMl0pKjIuNTUscGFyc2VGbG9h
dChnWzNdKSoyLjU1LHBhcnNlRmxvYXQoZ1s0XSkpO2lmKGc9LyMoW2EtZkEtRjAtOV17Mn0pKFth
LWZBLUYwLTldezJ9KShbYS1mQS1GMC05XXsyfSkvLmV4ZWMoeCkpcmV0dXJuIHAocGFyc2VJbnQo
Z1sxXSwxNikscGFyc2VJbnQoZ1syXSwxNikscGFyc2VJbnQoZ1szXSwxNikpO2lmKGc9LyMoW2Et
ZkEtRjAtOV0pKFthLWZBLUYwLTldKShbYS1mQS1GMC05XSkvLmV4ZWMoeCkpcmV0dXJuIHAocGFy
c2VJbnQoZ1sxXStnWzFdLDE2KSxwYXJzZUludChnWzJdK2dbMl0sMTYpLHBhcnNlSW50KGdbM10r
Z1szXSwxNikpO3g9bi50cmltKHgpLnRvTG93ZXJDYXNlKCk7cmV0dXJuIHg9PSJ0cmFuc3BhcmVu
dCI/cCgyNTUsMjU1LDI1NSwwKTooZz1NW3hdfHxbMCwwLDBdLHAoZ1swXSxnWzFdLGdbMl0pKX07
dmFyIE09e2FxdWE6WzAsMjU1LDI1NV0sYXp1cmU6WzI0MCwyNTUsMjU1XSxiZWlnZTpbMjQ1LDI0
NSwyMjBdLGJsYWNrOlswLCAwLDBdLGJsdWU6WzAsMCwyNTVdLGJyb3duOlsxNjUsNDIsNDJdLGN5
YW46WzAsMjU1LDI1NV0sZGFya2JsdWU6WzAsMCwxMzldLGRhcmtjeWFuOlswLDEzOSwxMzldLGRh
cmtncmV5OlsxNjksMTY5LDE2OV0sZGFya2dyZWVuOlswLDEwMCwwXSxkYXJra2hha2k6WzE4OSwx
ODMsMTA3XSxkYXJrbWFnZW50YTpbMTM5LDAsMTM5XSxkYXJrb2xpdmVncmVlbjpbODUsMTA3LDQ3
XSxkYXJrb3JhbmdlOlsyNTUsMTQwLDBdLGRhcmtvcmNoaWQ6WzE1Myw1MCwyMDRdLGRhcmtyZWQ6
WzEzOSwwLDBdLGRhcmtzYWxtb246WzIzMywxNTAsMTIyXSxkYXJrdmlvbGV0OlsxNDgsMCwyMTFd
LGZ1Y2hzaWE6WzI1NSwwLDI1NV0sZ29sZDpbMjU1LDIxNSwwXSxncmVlbjpbMCwxMjgsMF0saW5k
aWdvOls3NSwwLDEzMF0sa2hha2k6WzI0MCwyMzAsMTQwXSxsaWdodGJsdWU6WzE3MywyMTYsMjMw
XSxsaWdodGN5YW46WzIyNCwyNTUsMjU1XSxsaWdodGdyZWVuOlsxNDQsMjM4LDE0NF0sbGlnaHRn
cmV5OlsyMTEsIDIxMSwyMTFdLGxpZ2h0cGluazpbMjU1LDE4MiwxOTNdLGxpZ2h0eWVsbG93Olsy
NTUsMjU1LDIyNF0sbGltZTpbMCwyNTUsMF0sbWFnZW50YTpbMjU1LDAsMjU1XSxtYXJvb246WzEy
OCwwLDBdLG5hdnk6WzAsMCwxMjhdLG9saXZlOlsxMjgsMTI4LDBdLG9yYW5nZTpbMjU1LDE2NSww
XSxwaW5rOlsyNTUsMTkyLDIwM10scHVycGxlOlsxMjgsMCwxMjhdLHZpb2xldDpbMTI4LDAsMTI4
XSxyZWQ6WzI1NSwwLDBdLHNpbHZlcjpbMTkyLDE5MiwxOTJdLHdoaXRlOlsyNTUsMjU1LDI1NV0s
eWVsbG93OlsyNTUsMjU1LDBdfX0pKGpRdWVyeSk7IChmdW5jdGlvbihuKXtmdW5jdGlvbiBNKGcs
cCxXLGwpe2Z1bmN0aW9uIEkoYSxkKXtmb3IodmFyIGQ9W3ZdLmNvbmNhdChkKSxiPTA7YjxhLmxl
bmd0aDsrK2IpYVtiXS5hcHBseSh0aGlzLGQpfWZ1bmN0aW9uICQoYSl7Zm9yKHZhciBkPVtdLGI9
MDtiPGEubGVuZ3RoOysrYil7dmFyIGM9bi5leHRlbmQoITAse30sZi5zZXJpZXMpO2FbYl0uZGF0
YSE9bnVsbD8oYy5kYXRhPWFbYl0uZGF0YSxkZWxldGUgYVtiXS5kYXRhLG4uZXh0ZW5kKCEwLGMs
YVtiXSksYVtiXS5kYXRhPWMuZGF0YSk6Yy5kYXRhPWFbYl07ZC5wdXNoKGMpfXc9ZDtkPXcubGVu
Z3RoO2I9W107Yz1bXTtmb3IoYT0wO2E8dy5sZW5ndGg7KythKXt2YXIgZT13W2FdLmNvbG9yO2Uh
PW51bGwmJigtLWQsdHlwZW9mIGU9PSJudW1iZXIiP2MucHVzaChlKTpiLnB1c2gobi5jb2xvci5w
YXJzZSh3W2FdLmNvbG9yKSkpfWZvcihhPTA7YTxjLmxlbmd0aDsrK2EpZD1NYXRoLm1heChkLGNb
YV0rMSk7Yj1bXTtmb3IoYT1jPSAwO2IubGVuZ3RoPGQ7KWU9Zi5jb2xvcnMubGVuZ3RoPT1hP24u
Y29sb3IubWFrZSgxMDAsMTAwLDEwMCk6bi5jb2xvci5wYXJzZShmLmNvbG9yc1thXSksZS5zY2Fs
ZSgicmdiIiwxKyhjJTI9PTE/LTE6MSkqTWF0aC5jZWlsKGMvMikqMC4yKSxiLnB1c2goZSksKyth
LGE+PWYuY29sb3JzLmxlbmd0aCYmKGE9MCwrK2MpO2ZvcihhPWQ9MDthPHcubGVuZ3RoOysrYSl7
Yz13W2FdO2lmKGMuY29sb3I9PW51bGwpYy5jb2xvcj1iW2RdLnRvU3RyaW5nKCksKytkO2Vsc2Ug
aWYodHlwZW9mIGMuY29sb3I9PSJudW1iZXIiKWMuY29sb3I9YltjLmNvbG9yXS50b1N0cmluZygp
O2lmKGMubGluZXMuc2hvdz09bnVsbCl7dmFyIHUsZT0hMDtmb3IodSBpbiBjKWlmKGNbdV0mJmNb
dV0uc2hvdyl7ZT0hMTticmVha31pZihlKWMubGluZXMuc2hvdz0hMH1jLnhheGlzPVEoQSxQKGMs
IngiKSk7Yy55YXhpcz1RKEYsUChjLCJ5IikpfXooKX1mdW5jdGlvbiBQKGEsZCl7dmFyIGI9YVtk
KyJheGlzIl07IGlmKHR5cGVvZiBiPT0ib2JqZWN0IiliPWIubjt0eXBlb2YgYiE9Im51bWJlciIm
JihiPTEpO3JldHVybiBifWZ1bmN0aW9uIEMoKXtyZXR1cm4gbi5ncmVwKEEuY29uY2F0KEYpLGZ1
bmN0aW9uKGEpe3JldHVybiBhfSl9ZnVuY3Rpb24gVShhKXt2YXIgZD17fSxiLGM7Zm9yKGI9MDti
PEEubGVuZ3RoOysrYikoYz1BW2JdKSYmYy51c2VkJiYoZFsieCIrYy5uXT1jLmMycChhLmxlZnQp
KTtmb3IoYj0wO2I8Ri5sZW5ndGg7KytiKShjPUZbYl0pJiZjLnVzZWQmJihkWyJ5IitjLm5dPWMu
YzJwKGEudG9wKSk7aWYoZC54MSE9PXZvaWQgMClkLng9ZC54MTtpZihkLnkxIT09dm9pZCAwKWQu
eT1kLnkxO3JldHVybiBkfWZ1bmN0aW9uIFEoYSxkKXthW2QtMV18fChhW2QtMV09e246ZCxkaXJl
Y3Rpb246YT09QT8ieCI6InkiLG9wdGlvbnM6bi5leHRlbmQoITAse30sYT09QT9mLnhheGlzOmYu
eWF4aXMpfSk7cmV0dXJuIGFbZC0xXX1mdW5jdGlvbiB6KCl7ZnVuY3Rpb24gYShhLGIsZSl7aWYo
YjwgYS5kYXRhbWluJiZiIT0tYylhLmRhdGFtaW49YjtpZihlPmEuZGF0YW1heCYmZSE9YylhLmRh
dGFtYXg9ZX12YXIgZD1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksYj1OdW1iZXIuTkVHQVRJVkVf
SU5GSU5JVFksYz1OdW1iZXIuTUFYX1ZBTFVFLGUsdSxxLHQsbSxrLHksZixoLGc7bi5lYWNoKEMo
KSxmdW5jdGlvbihhLGUpe2UuZGF0YW1pbj1kO2UuZGF0YW1heD1iO2UudXNlZD0hMX0pO2Zvcihl
PTA7ZTx3Lmxlbmd0aDsrK2UpbT13W2VdLG0uZGF0YXBvaW50cz17cG9pbnRzOltdfSxJKEoucHJv
Y2Vzc1Jhd0RhdGEsW20sbS5kYXRhLG0uZGF0YXBvaW50c10pO2ZvcihlPTA7ZTx3Lmxlbmd0aDsr
K2Upe209d1tlXTt2YXIgRD1tLmRhdGEscj1tLmRhdGFwb2ludHMuZm9ybWF0O2lmKCFyKXtyPVtd
O3IucHVzaCh7eDohMCxudW1iZXI6ITAscmVxdWlyZWQ6ITB9KTtyLnB1c2goe3k6ITAsbnVtYmVy
OiEwLHJlcXVpcmVkOiEwfSk7aWYobS5iYXJzLnNob3d8fG0ubGluZXMuc2hvdyYmIG0ubGluZXMu
ZmlsbClpZihyLnB1c2goe3k6ITAsbnVtYmVyOiEwLHJlcXVpcmVkOiExLGRlZmF1bHRWYWx1ZTow
fSksbS5iYXJzLmhvcml6b250YWwpZGVsZXRlIHJbci5sZW5ndGgtMV0ueSxyW3IubGVuZ3RoLTFd
Lng9ITA7bS5kYXRhcG9pbnRzLmZvcm1hdD1yfWlmKG0uZGF0YXBvaW50cy5wb2ludHNpemU9PW51
bGwpe20uZGF0YXBvaW50cy5wb2ludHNpemU9ci5sZW5ndGg7eT1tLmRhdGFwb2ludHMucG9pbnRz
aXplO2s9bS5kYXRhcG9pbnRzLnBvaW50cztpbnNlcnRTdGVwcz1tLmxpbmVzLnNob3cmJm0ubGlu
ZXMuc3RlcHM7bS54YXhpcy51c2VkPW0ueWF4aXMudXNlZD0hMDtmb3IodT1xPTA7dTxELmxlbmd0
aDsrK3UscSs9eSl7Zz1EW3VdO3ZhciBvPWc9PW51bGw7aWYoIW8pZm9yKHQ9MDt0PHk7Kyt0KXtm
PWdbdF07aWYoaD1yW3RdKWlmKGgubnVtYmVyJiZmIT1udWxsJiYoZj0rZixpc05hTihmKT9mPW51
bGw6Zj09SW5maW5pdHk/Zj1jOmY9PS1JbmZpbml0eSYmKGY9LWMpKSwgZj09bnVsbCYmKGgucmVx
dWlyZWQmJihvPSEwKSxoLmRlZmF1bHRWYWx1ZSE9bnVsbCkpZj1oLmRlZmF1bHRWYWx1ZTtrW3Er
dF09Zn1pZihvKWZvcih0PTA7dDx5OysrdClmPWtbcSt0XSxmIT1udWxsJiYoaD1yW3RdLGgueCYm
YShtLnhheGlzLGYsZiksaC55JiZhKG0ueWF4aXMsZixmKSksa1txK3RdPW51bGw7ZWxzZSBpZihp
bnNlcnRTdGVwcyYmcT4wJiZrW3EteV0hPW51bGwmJmtbcS15XSE9a1txXSYma1txLXkrMV0hPWtb
cSsxXSl7Zm9yKHQ9MDt0PHk7Kyt0KWtbcSt5K3RdPWtbcSt0XTtrW3ErMV09a1txLXkrMV07cSs9
eX19fX1mb3IoZT0wO2U8dy5sZW5ndGg7KytlKW09d1tlXSxJKEoucHJvY2Vzc0RhdGFwb2ludHMs
W20sbS5kYXRhcG9pbnRzXSk7Zm9yKGU9MDtlPHcubGVuZ3RoOysrZSl7bT13W2VdO2s9bS5kYXRh
cG9pbnRzLnBvaW50czt5PW0uZGF0YXBvaW50cy5wb2ludHNpemU7Zz1xPWQ7bz1EPWI7Zm9yKHU9
MDt1PGsubGVuZ3RoO3UrPXkpaWYoa1t1XSE9bnVsbClmb3IodD0gMDt0PHk7Kyt0KWlmKGY9a1t1
K3RdLChoPXJbdF0pJiYhKGY9PWN8fGY9PS1jKSloLngmJihmPHEmJihxPWYpLGY+RCYmKEQ9Zikp
LGgueSYmKGY8ZyYmKGc9ZiksZj5vJiYobz1mKSk7bS5iYXJzLnNob3cmJih1PW0uYmFycy5hbGln
bj09ImxlZnQiPzA6LW0uYmFycy5iYXJXaWR0aC8yLG0uYmFycy5ob3Jpem9udGFsPyhnKz11LG8r
PXUrbS5iYXJzLmJhcldpZHRoKToocSs9dSxEKz11K20uYmFycy5iYXJXaWR0aCkpO2EobS54YXhp
cyxxLEQpO2EobS55YXhpcyxnLG8pfW4uZWFjaChDKCksZnVuY3Rpb24oYSxlKXtpZihlLmRhdGFt
aW49PWQpZS5kYXRhbWluPW51bGw7aWYoZS5kYXRhbWF4PT1iKWUuZGF0YW1heD1udWxsfSl9ZnVu
Y3Rpb24gYWEoYSxkKXt2YXIgYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJjYW52YXMiKTtiLmNs
YXNzTmFtZT1kO2Iud2lkdGg9RztiLmhlaWdodD1IO2F8fG4oYikuY3NzKHtwb3NpdGlvbjoiYWJz
b2x1dGUiLGxlZnQ6MCx0b3A6MH0pO24oYikuYXBwZW5kVG8oZyk7IGIuZ2V0Q29udGV4dHx8KGI9
d2luZG93Lkdfdm1sQ2FudmFzTWFuYWdlci5pbml0RWxlbWVudChiKSk7Yi5nZXRDb250ZXh0KCIy
ZCIpLnNhdmUoKTtyZXR1cm4gYn1mdW5jdGlvbiBNKCl7Rz1nLndpZHRoKCk7SD1nLmhlaWdodCgp
O2lmKEc8PTB8fEg8PTApdGhyb3ciSW52YWxpZCBkaW1lbnNpb25zIGZvciBwbG90LCB3aWR0aCA9
ICIrRysiLCBoZWlnaHQgPSAiK0g7fWZ1bmN0aW9uIGJhKGEpe2lmKGEud2lkdGghPUcpYS53aWR0
aD1HO2lmKGEuaGVpZ2h0IT1IKWEuaGVpZ2h0PUg7YT1hLmdldENvbnRleHQoIjJkIik7YS5yZXN0
b3JlKCk7YS5zYXZlKCl9ZnVuY3Rpb24gcWEoYSl7ZnVuY3Rpb24gZChhKXtyZXR1cm4gYX12YXIg
YixjLGU9YS5vcHRpb25zLnRyYW5zZm9ybXx8ZCx1PWEub3B0aW9ucy5pbnZlcnNlVHJhbnNmb3Jt
O2EuZGlyZWN0aW9uPT0ieCI/KGI9YS5zY2FsZT1SL01hdGguYWJzKGUoYS5tYXgpLWUoYS5taW4p
KSxjPU1hdGgubWluKGUoYS5tYXgpLGUoYS5taW4pKSk6IChiPWEuc2NhbGU9Ti9NYXRoLmFicyhl
KGEubWF4KS1lKGEubWluKSksYj0tYixjPU1hdGgubWF4KGUoYS5tYXgpLGUoYS5taW4pKSk7YS5w
MmM9ZT09ZD9mdW5jdGlvbihhKXtyZXR1cm4oYS1jKSpifTpmdW5jdGlvbihhKXtyZXR1cm4oZShh
KS1jKSpifTthLmMycD11P2Z1bmN0aW9uKGEpe3JldHVybiB1KGMrYS9iKX06ZnVuY3Rpb24oYSl7
cmV0dXJuIGMrYS9ifX1mdW5jdGlvbiByYShhKXt2YXIgZD1hLmxhYmVsV2lkdGgsYj1hLmxhYmVs
SGVpZ2h0LGM9YS5vcHRpb25zLnBvc2l0aW9uLGU9YS5vcHRpb25zLnRpY2tMZW5ndGgsdT1mLmdy
aWQuYXhpc01hcmdpbixxPWYuZ3JpZC5sYWJlbE1hcmdpbix0PWEuZGlyZWN0aW9uPT0ieCI/QTpG
LG09bi5ncmVwKHQsZnVuY3Rpb24oYSl7cmV0dXJuIGEmJmEub3B0aW9ucy5wb3NpdGlvbj09YyYm
YS5yZXNlcnZlU3BhY2V9KTtuLmluQXJyYXkoYSxtKT09bS5sZW5ndGgtMSYmKHU9MCk7aWYoZT09
bnVsbCl2YXIgZT1uLmdyZXAodCxmdW5jdGlvbihhKXtyZXR1cm4gYSYmIGEucmVzZXJ2ZVNwYWNl
fSksaz1uLmluQXJyYXkoYSxlKT09MCxlPWs/ImZ1bGwiOjU7aXNOYU4oK2UpfHwocSs9K2UpO2Eu
ZGlyZWN0aW9uPT0ieCI/KGIrPXEsYz09ImJvdHRvbSI/KGouYm90dG9tKz1iK3UsYS5ib3g9e3Rv
cDpILWouYm90dG9tLGhlaWdodDpifSk6KGEuYm94PXt0b3A6ai50b3ArdSxoZWlnaHQ6Yn0sai50
b3ArPWIrdSkpOihkKz1xLGM9PSJsZWZ0Ij8oYS5ib3g9e2xlZnQ6ai5sZWZ0K3Usd2lkdGg6ZH0s
ai5sZWZ0Kz1kK3UpOihqLnJpZ2h0Kz1kK3UsYS5ib3g9e2xlZnQ6Ry1qLnJpZ2h0LHdpZHRoOmR9
KSk7YS5wb3NpdGlvbj1jO2EudGlja0xlbmd0aD1lO2EuYm94LnBhZGRpbmc9cTthLmlubmVybW9z
dD1rfWZ1bmN0aW9uIHNhKCl7dmFyIGE9Zi5ncmlkLm1pbkJvcmRlck1hcmdpbixkPXt4OjAseTow
fSxiO2lmKGE9PW51bGwpZm9yKGI9YT0wO2I8dy5sZW5ndGg7KytiKWE9TWF0aC5tYXgoYSwyKih3
W2JdLnBvaW50cy5yYWRpdXMrd1tiXS5wb2ludHMubGluZVdpZHRoLyAyKSk7ZC54PWQueT1NYXRo
LmNlaWwoYSk7bi5lYWNoKEMoKSxmdW5jdGlvbihhLGIpe3ZhciB1PWIuZGlyZWN0aW9uO2IucmVz
ZXJ2ZVNwYWNlJiYoZFt1XT1NYXRoLmNlaWwoTWF0aC5tYXgoZFt1XSwodT09IngiP2IubGFiZWxX
aWR0aDpiLmxhYmVsSGVpZ2h0KS8yKSkpfSk7ai5sZWZ0PU1hdGgubWF4KGQueCxqLmxlZnQpO2ou
cmlnaHQ9TWF0aC5tYXgoZC54LGoucmlnaHQpO2oudG9wPU1hdGgubWF4KGQueSxqLnRvcCk7ai5i
b3R0b209TWF0aC5tYXgoZC55LGouYm90dG9tKX1mdW5jdGlvbiBjYSgpe3ZhciBhLGQ9QygpO2E9
Zi5ncmlkLnNob3c7Zm9yKHZhciBiIGluIGopaltiXT1hP2YuZ3JpZC5ib3JkZXJXaWR0aDowO24u
ZWFjaChkLGZ1bmN0aW9uKGEsYil7Yi5zaG93PWIub3B0aW9ucy5zaG93O2lmKGIuc2hvdz09bnVs
bCliLnNob3c9Yi51c2VkO2IucmVzZXJ2ZVNwYWNlPWIuc2hvd3x8Yi5vcHRpb25zLnJlc2VydmVT
cGFjZTt2YXIgZD1iLm9wdGlvbnMsYz0rKGQubWluIT0gbnVsbD9kLm1pbjpiLmRhdGFtaW4pLGY9
KyhkLm1heCE9bnVsbD9kLm1heDpiLmRhdGFtYXgpLGs9Zi1jO2lmKGs9PTApe2lmKGs9Zj09MD8x
OjAuMDEsZC5taW49PW51bGwmJihjLT1rKSxkLm1heD09bnVsbHx8ZC5taW4hPW51bGwpZis9a31l
bHNle3ZhciB5PWQuYXV0b3NjYWxlTWFyZ2luO3khPW51bGwmJihkLm1pbj09bnVsbCYmKGMtPWsq
eSxjPDAmJmIuZGF0YW1pbiE9bnVsbCYmYi5kYXRhbWluPj0wJiYoYz0wKSksZC5tYXg9PW51bGwm
JihmKz1rKnksZj4wJiZiLmRhdGFtYXghPW51bGwmJmIuZGF0YW1heDw9MCYmKGY9MCkpKX1iLm1p
bj1jO2IubWF4PWZ9KTtpZihhKXt2YXIgYz17c3R5bGU6Zy5jc3MoImZvbnQtc3R5bGUiKSxzaXpl
Ok1hdGgucm91bmQoMC44KigrZy5jc3MoImZvbnQtc2l6ZSIpLnJlcGxhY2UoInB4IiwiIil8fDEz
KSksdmFyaWFudDpnLmNzcygiZm9udC12YXJpYW50Iiksd2VpZ2h0OmcuY3NzKCJmb250LXdlaWdo
dCIpLGZhbWlseTpnLmNzcygiZm9udC1mYW1pbHkiKX07IGI9bi5ncmVwKGQsZnVuY3Rpb24oYSl7
cmV0dXJuIGEucmVzZXJ2ZVNwYWNlfSk7bi5lYWNoKGIsZnVuY3Rpb24oYSxiKXt0YShiKTt2YXIg
ZD1iLm9wdGlvbnMudGlja3MsZj1bXTtkPT1udWxsfHx0eXBlb2YgZD09Im51bWJlciImJmQ+MD9m
PWIudGlja0dlbmVyYXRvcihiKTpkJiYoZj1uLmlzRnVuY3Rpb24oZCk/ZCh7bWluOmIubWluLG1h
eDpiLm1heH0pOmQpO3ZhciBtO2IudGlja3M9W107Zm9yKGQ9MDtkPGYubGVuZ3RoOysrZCl7dmFy
IGs9bnVsbCx5PWZbZF07dHlwZW9mIHk9PSJvYmplY3QiPyhtPSt5WzBdLHkubGVuZ3RoPjEmJihr
PXlbMV0pKTptPSt5O2s9PW51bGwmJihrPWIudGlja0Zvcm1hdHRlcihtLGIpKTtpc05hTihtKXx8
Yi50aWNrcy5wdXNoKHt2Om0sbGFiZWw6a30pfWY9Yi50aWNrcztpZihiLm9wdGlvbnMuYXV0b3Nj
YWxlTWFyZ2luJiZmLmxlbmd0aD4wKXtpZihiLm9wdGlvbnMubWluPT1udWxsKWIubWluPU1hdGgu
bWluKGIubWluLGZbMF0udik7aWYoYi5vcHRpb25zLm1heD09IG51bGwmJmYubGVuZ3RoPjEpYi5t
YXg9TWF0aC5tYXgoYi5tYXgsZltmLmxlbmd0aC0xXS52KX1iLmZvbnQ9bi5leHRlbmQoe30sYyxi
Lm9wdGlvbnMuZm9udCk7Zj1iLm9wdGlvbnM7ZD1iLnRpY2tzfHxbXTttPWYubGFiZWxXaWR0aHx8
MDtrPWYubGFiZWxIZWlnaHR8fDA7eT1iLmZvbnQ7aWYoZi5sYWJlbFdpZHRoPT1udWxsfHxmLmxh
YmVsSGVpZ2h0PT1udWxsKXtoLnNhdmUoKTtoLmZvbnQ9eS5zdHlsZSsiICIreS52YXJpYW50KyIg
Iit5LndlaWdodCsiICIreS5zaXplKyJweCAnIit5LmZhbWlseSsiJyI7Zm9yKHZhciBnPTA7Zzxk
Lmxlbmd0aDsrK2cpe3ZhciBMPWRbZ107TC5saW5lcz1bXTtMLndpZHRoPUwuaGVpZ2h0PTA7aWYo
TC5sYWJlbCl7Zm9yKHZhciBqPUwubGFiZWwucmVwbGFjZSgvPGJyID9cLz8+fFxyXG58XHIvZywi
XG4iKS5zcGxpdCgiXG4iKSxEPTA7RDxqLmxlbmd0aDsrK0Qpe3ZhciByPXt0ZXh0OmpbRF19LG89
aC5tZWFzdXJlVGV4dChyLnRleHQpO3Iud2lkdGg9IG8ud2lkdGg7ci5oZWlnaHQ9by5oZWlnaHQh
PW51bGw/by5oZWlnaHQ6eS5zaXplO3IuaGVpZ2h0Kz1NYXRoLnJvdW5kKHkuc2l6ZSowLjE1KTtM
LndpZHRoPU1hdGgubWF4KHIud2lkdGgsTC53aWR0aCk7TC5oZWlnaHQrPXIuaGVpZ2h0O0wubGlu
ZXMucHVzaChyKX1mLmxhYmVsV2lkdGg9PW51bGwmJihtPU1hdGgubWF4KG0sTC53aWR0aCkpO2Yu
bGFiZWxIZWlnaHQ9PW51bGwmJihrPU1hdGgubWF4KGssTC5oZWlnaHQpKX19aC5yZXN0b3JlKCl9
Yi5sYWJlbFdpZHRoPU1hdGguY2VpbChtKTtiLmxhYmVsSGVpZ2h0PU1hdGguY2VpbChrKX0pO2Zv
cihhPWIubGVuZ3RoLTE7YT49MDstLWEpcmEoYlthXSk7c2EoKTtuLmVhY2goYixmdW5jdGlvbihh
LGIpe2IuZGlyZWN0aW9uPT0ieCI/KGIuYm94LmxlZnQ9ai5sZWZ0LWIubGFiZWxXaWR0aC8yLGIu
Ym94LndpZHRoPUctai5sZWZ0LWoucmlnaHQrYi5sYWJlbFdpZHRoKTooYi5ib3gudG9wPWoudG9w
LWIubGFiZWxIZWlnaHQvMixiLmJveC5oZWlnaHQ9IEgtai5ib3R0b20tai50b3ArYi5sYWJlbEhl
aWdodCl9KX1SPUctai5sZWZ0LWoucmlnaHQ7Tj1ILWouYm90dG9tLWoudG9wO24uZWFjaChkLGZ1
bmN0aW9uKGEsYil7cWEoYil9KTt1YSgpfWZ1bmN0aW9uIHRhKGEpe3ZhciBkPWEub3B0aW9ucyxi
PShhLm1heC1hLm1pbikvKHR5cGVvZiBkLnRpY2tzPT0ibnVtYmVyIiYmZC50aWNrcz4wP2QudGlj
a3M6MC4zKk1hdGguc3FydChhLmRpcmVjdGlvbj09IngiP0c6SCkpLGMsZSxmLHE7aWYoZC5tb2Rl
PT0idGltZSIpe3ZhciB0PXtzZWNvbmQ6MUUzLG1pbnV0ZTo2RTQsaG91cjozNkU1LGRheTo4NjRF
NSxtb250aDoyNTkyRTYseWVhcjo1MjU5NDkuMio2RTR9O3E9W1sxLCJzZWNvbmQiXSxbMiwic2Vj
b25kIl0sWzUsInNlY29uZCJdLFsxMCwic2Vjb25kIl0sWzMwLCJzZWNvbmQiXSxbMSwibWludXRl
Il0sWzIsIm1pbnV0ZSJdLFs1LCJtaW51dGUiXSxbMTAsIm1pbnV0ZSJdLFszMCwibWludXRlIl0s
WzEsImhvdXIiXSxbMiwiaG91ciJdLCBbNCwiaG91ciJdLFs4LCJob3VyIl0sWzEyLCJob3VyIl0s
WzEsImRheSJdLFsyLCJkYXkiXSxbMywiZGF5Il0sWzAuMjUsIm1vbnRoIl0sWzAuNSwibW9udGgi
XSxbMSwibW9udGgiXSxbMiwibW9udGgiXSxbMywibW9udGgiXSxbNiwibW9udGgiXSxbMSwieWVh
ciJdXTtjPTA7ZC5taW5UaWNrU2l6ZSE9bnVsbCYmKGM9dHlwZW9mIGQudGlja1NpemU9PSJudW1i
ZXIiP2QudGlja1NpemU6ZC5taW5UaWNrU2l6ZVswXSp0W2QubWluVGlja1NpemVbMV1dKTtmb3Io
ZT0wO2U8cS5sZW5ndGgtMTsrK2UpaWYoYjwocVtlXVswXSp0W3FbZV1bMV1dK3FbZSsxXVswXSp0
W3FbZSsxXVsxXV0pLzImJnFbZV1bMF0qdFtxW2VdWzFdXT49YylicmVhaztjPXFbZV1bMF07Zj1x
W2VdWzFdO2Y9PSJ5ZWFyIiYmKGU9TWF0aC5wb3coMTAsTWF0aC5mbG9vcihNYXRoLmxvZyhiL3Qu
eWVhcikvTWF0aC5MTjEwKSkscT1iL3QueWVhci9lLGM9cTwxLjU/MTpxPDM/MjpxPDcuNT81OjEw
LGMqPWUpO2EudGlja1NpemU9IGQudGlja1NpemV8fFtjLGZdO2U9ZnVuY3Rpb24oYSl7dmFyIGI9
W10sZD1hLnRpY2tTaXplWzBdLGU9YS50aWNrU2l6ZVsxXSxjPW5ldyBEYXRlKGEubWluKSxmPWQq
dFtlXTtlPT0ic2Vjb25kIiYmYy5zZXRVVENTZWNvbmRzKHgoYy5nZXRVVENTZWNvbmRzKCksZCkp
O2U9PSJtaW51dGUiJiZjLnNldFVUQ01pbnV0ZXMoeChjLmdldFVUQ01pbnV0ZXMoKSxkKSk7ZT09
ImhvdXIiJiZjLnNldFVUQ0hvdXJzKHgoYy5nZXRVVENIb3VycygpLGQpKTtlPT0ibW9udGgiJiZj
LnNldFVUQ01vbnRoKHgoYy5nZXRVVENNb250aCgpLGQpKTtlPT0ieWVhciImJmMuc2V0VVRDRnVs
bFllYXIoeChjLmdldFVUQ0Z1bGxZZWFyKCksZCkpO2Muc2V0VVRDTWlsbGlzZWNvbmRzKDApO2Y+
PXQubWludXRlJiZjLnNldFVUQ1NlY29uZHMoMCk7Zj49dC5ob3VyJiZjLnNldFVUQ01pbnV0ZXMo
MCk7Zj49dC5kYXkmJmMuc2V0VVRDSG91cnMoMCk7Zj49dC5kYXkqNCYmYy5zZXRVVENEYXRlKDEp
O2Y+PXQueWVhciYmIGMuc2V0VVRDTW9udGgoMCk7dmFyIG09MCxrPU51bWJlci5OYU4scTtkbyBp
ZihxPWssaz1jLmdldFRpbWUoKSxiLnB1c2goayksZT09Im1vbnRoIilpZihkPDEpe2Muc2V0VVRD
RGF0ZSgxKTt2YXIgaD1jLmdldFRpbWUoKTtjLnNldFVUQ01vbnRoKGMuZ2V0VVRDTW9udGgoKSsx
KTt2YXIgdT1jLmdldFRpbWUoKTtjLnNldFRpbWUoayttKnQuaG91cisodS1oKSpkKTttPWMuZ2V0
VVRDSG91cnMoKTtjLnNldFVUQ0hvdXJzKDApfWVsc2UgYy5zZXRVVENNb250aChjLmdldFVUQ01v
bnRoKCkrZCk7ZWxzZSBlPT0ieWVhciI/Yy5zZXRVVENGdWxsWWVhcihjLmdldFVUQ0Z1bGxZZWFy
KCkrZCk6Yy5zZXRUaW1lKGsrZik7d2hpbGUoazxhLm1heCYmayE9cSk7cmV0dXJuIGJ9O2M9ZnVu
Y3Rpb24oYSxiKXt2YXIgYz1uZXcgRGF0ZShhKTtpZihkLnRpbWVmb3JtYXQhPW51bGwpcmV0dXJu
IG4ucGxvdC5mb3JtYXREYXRlKGMsZC50aW1lZm9ybWF0LGQubW9udGhOYW1lcyk7dmFyIGU9Yi50
aWNrU2l6ZVswXSogdFtiLnRpY2tTaXplWzFdXSxmPWIubWF4LWIubWluLG09ZC50d2VsdmVIb3Vy
Q2xvY2s/IiAlcCI6IiI7Zm10PWU8dC5taW51dGU/IiVoOiVNOiVTIittOmU8dC5kYXk/ZjwyKnQu
ZGF5PyIlaDolTSIrbToiJWIgJWQgJWg6JU0iK206ZTx0Lm1vbnRoPyIlYiAlZCI6ZTx0LnllYXI/
Zjx0LnllYXI/IiViIjoiJWIgJXkiOiIleSI7cmV0dXJuIG4ucGxvdC5mb3JtYXREYXRlKGMsZm10
LGQubW9udGhOYW1lcyl9fWVsc2V7Zj1kLnRpY2tEZWNpbWFsczt2YXIgbT0tTWF0aC5mbG9vcihN
YXRoLmxvZyhiKS9NYXRoLkxOMTApO2YhPW51bGwmJm0+ZiYmKG09Zik7ZT1NYXRoLnBvdygxMCwt
bSk7cT1iL2U7aWYocTwxLjUpYz0xO2Vsc2UgaWYocTwzKXtpZihjPTIscT4yLjI1JiYoZj09bnVs
bHx8bSsxPD1mKSljPTIuNSwrK219ZWxzZSBjPXE8Ny41PzU6MTA7Yyo9ZTtpZihkLm1pblRpY2tT
aXplIT1udWxsJiZjPGQubWluVGlja1NpemUpYz1kLm1pblRpY2tTaXplO2EudGlja0RlY2ltYWxz
PSBNYXRoLm1heCgwLGYhPW51bGw/ZjptKTthLnRpY2tTaXplPWQudGlja1NpemV8fGM7ZT1mdW5j
dGlvbihhKXt2YXIgYj1bXSxkPXgoYS5taW4sYS50aWNrU2l6ZSksYz0wLGU9TnVtYmVyLk5hTixm
O2RvIGY9ZSxlPWQrYyphLnRpY2tTaXplLGIucHVzaChlKSwrK2M7d2hpbGUoZTxhLm1heCYmZSE9
Zik7cmV0dXJuIGJ9O2M9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS50b0ZpeGVkKGIudGlja0RlY2lt
YWxzKX19aWYoZC5hbGlnblRpY2tzV2l0aEF4aXMhPW51bGwpe3ZhciBrPShhLmRpcmVjdGlvbj09
IngiP0E6RilbZC5hbGlnblRpY2tzV2l0aEF4aXMtMV07aWYoayYmay51c2VkJiZrIT1hKXtlPWUo
YSk7aWYoZS5sZW5ndGg+MCl7aWYoZC5taW49PW51bGwpYS5taW49TWF0aC5taW4oYS5taW4sZVsw
XSk7aWYoZC5tYXg9PW51bGwmJmUubGVuZ3RoPjEpYS5tYXg9TWF0aC5tYXgoYS5tYXgsZVtlLmxl
bmd0aC0xXSl9ZT1mdW5jdGlvbihhKXt2YXIgYj1bXSxkLGM7Zm9yKGM9MDtjPGsudGlja3MubGVu
Z3RoOysrYylkPSAoay50aWNrc1tjXS52LWsubWluKS8oay5tYXgtay5taW4pLGQ9YS5taW4rZCoo
YS5tYXgtYS5taW4pLGIucHVzaChkKTtyZXR1cm4gYn07aWYoYS5tb2RlIT0idGltZSImJmQudGlj
a0RlY2ltYWxzPT1udWxsJiYoYj1NYXRoLm1heCgwLC1NYXRoLmZsb29yKE1hdGgubG9nKGIpL01h
dGguTE4xMCkrMSkscT1lKGEpLCEocS5sZW5ndGg+MSYmL1wuLiowJC8udGVzdCgocVsxXS1xWzBd
KS50b0ZpeGVkKGIpKSkpKWEudGlja0RlY2ltYWxzPWJ9fWEudGlja0dlbmVyYXRvcj1lO2EudGlj
a0Zvcm1hdHRlcj1uLmlzRnVuY3Rpb24oZC50aWNrRm9ybWF0dGVyKT9mdW5jdGlvbihhLGIpe3Jl
dHVybiIiK2QudGlja0Zvcm1hdHRlcihhLGIpfTpjfWZ1bmN0aW9uIGRhKCl7aC5jbGVhclJlY3Qo
MCwwLEcsSCk7dmFyIGE9Zi5ncmlkO2lmKGEuc2hvdyYmYS5iYWNrZ3JvdW5kQ29sb3IpaC5zYXZl
KCksaC50cmFuc2xhdGUoai5sZWZ0LGoudG9wKSxoLmZpbGxTdHlsZT1lYShmLmdyaWQuYmFja2dy
b3VuZENvbG9yLCBOLDAsInJnYmEoMjU1LCAyNTUsIDI1NSwgMCkiKSxoLmZpbGxSZWN0KDAsMCxS
LE4pLGgucmVzdG9yZSgpO2Euc2hvdyYmIWEuYWJvdmVEYXRhJiYoZmEoKSxnYSgpKTtmb3IodmFy
IGQ9MDtkPHcubGVuZ3RoOysrZCl7SShKLmRyYXdTZXJpZXMsW2gsd1tkXV0pO3ZhciBiPXdbZF07
Yi5saW5lcy5zaG93JiZ2YShiKTtiLmJhcnMuc2hvdyYmd2EoYik7Yi5wb2ludHMuc2hvdyYmeGEo
Yil9SShKLmRyYXcsW2hdKTthLnNob3cmJmEuYWJvdmVEYXRhJiYoZmEoKSxnYSgpKX1mdW5jdGlv
biBoYShhLGQpe3ZhciBiLGMsZSxmLHE9QygpO2ZvcihpPTA7aTxxLmxlbmd0aDsrK2kpaWYoYj1x
W2ldLGIuZGlyZWN0aW9uPT1kJiYoZj1kK2IubisiYXhpcyIsIWFbZl0mJmIubj09MSYmKGY9ZCsi
YXhpcyIpLGFbZl0pKXtjPWFbZl0uZnJvbTtlPWFbZl0udG87YnJlYWt9YVtmXXx8KGI9ZD09Ingi
P0FbMF06RlswXSxjPWFbZCsiMSJdLGU9YVtkKyIyIl0pO2MhPW51bGwmJmUhPW51bGwmJmM+ZSYm
IChmPWMsYz1lLGU9Zik7cmV0dXJue2Zyb206Yyx0bzplLGF4aXM6Yn19ZnVuY3Rpb24gZmEoKXt2
YXIgYTtoLnNhdmUoKTtoLnRyYW5zbGF0ZShqLmxlZnQsai50b3ApO3ZhciBkPWYuZ3JpZC5tYXJr
aW5ncztpZihkKXtpZihuLmlzRnVuY3Rpb24oZCkpe3ZhciBiPXYuZ2V0QXhlcygpO2IueG1pbj1i
LnhheGlzLm1pbjtiLnhtYXg9Yi54YXhpcy5tYXg7Yi55bWluPWIueWF4aXMubWluO2IueW1heD1i
LnlheGlzLm1heDtkPWQoYil9Zm9yKGE9MDthPGQubGVuZ3RoOysrYSl7dmFyIGI9ZFthXSxjPWhh
KGIsIngiKSxlPWhhKGIsInkiKTtpZihjLmZyb209PW51bGwpYy5mcm9tPWMuYXhpcy5taW47aWYo
Yy50bz09bnVsbCljLnRvPWMuYXhpcy5tYXg7aWYoZS5mcm9tPT1udWxsKWUuZnJvbT1lLmF4aXMu
bWluO2lmKGUudG89PW51bGwpZS50bz1lLmF4aXMubWF4O2lmKCEoYy50bzxjLmF4aXMubWlufHxj
LmZyb20+Yy5heGlzLm1heHx8ZS50bzxlLmF4aXMubWlufHxlLmZyb20+ZS5heGlzLm1heCkpaWYo
Yy5mcm9tPSBNYXRoLm1heChjLmZyb20sYy5heGlzLm1pbiksYy50bz1NYXRoLm1pbihjLnRvLGMu
YXhpcy5tYXgpLGUuZnJvbT1NYXRoLm1heChlLmZyb20sZS5heGlzLm1pbiksZS50bz1NYXRoLm1p
bihlLnRvLGUuYXhpcy5tYXgpLCEoYy5mcm9tPT1jLnRvJiZlLmZyb209PWUudG8pKWMuZnJvbT1j
LmF4aXMucDJjKGMuZnJvbSksYy50bz1jLmF4aXMucDJjKGMudG8pLGUuZnJvbT1lLmF4aXMucDJj
KGUuZnJvbSksZS50bz1lLmF4aXMucDJjKGUudG8pLGMuZnJvbT09Yy50b3x8ZS5mcm9tPT1lLnRv
PyhoLmJlZ2luUGF0aCgpLGguc3Ryb2tlU3R5bGU9Yi5jb2xvcnx8Zi5ncmlkLm1hcmtpbmdzQ29s
b3IsaC5saW5lV2lkdGg9Yi5saW5lV2lkdGh8fGYuZ3JpZC5tYXJraW5nc0xpbmVXaWR0aCxoLm1v
dmVUbyhjLmZyb20sZS5mcm9tKSxoLmxpbmVUbyhjLnRvLGUudG8pLGguc3Ryb2tlKCkpOihoLmZp
bGxTdHlsZT1iLmNvbG9yfHxmLmdyaWQubWFya2luZ3NDb2xvcixoLmZpbGxSZWN0KGMuZnJvbSwg
ZS50byxjLnRvLWMuZnJvbSxlLmZyb20tZS50bykpfX1iPUMoKTtkPWYuZ3JpZC5ib3JkZXJXaWR0
aDtmb3IoYz0wO2M8Yi5sZW5ndGg7KytjKXtlPWJbY107YT1lLmJveDt2YXIgZz1lLnRpY2tMZW5n
dGgscSx0LG0saztpZihlLnNob3cmJmUudGlja3MubGVuZ3RoIT0wKXtoLnN0cm9rZVN0eWxlPWUu
b3B0aW9ucy50aWNrQ29sb3J8fG4uY29sb3IucGFyc2UoZS5vcHRpb25zLmNvbG9yKS5zY2FsZSgi
YSIsMC4yMikudG9TdHJpbmcoKTtoLmxpbmVXaWR0aD0xO2UuZGlyZWN0aW9uPT0ieCI/KHE9MCx0
PWc9PSJmdWxsIj9lLnBvc2l0aW9uPT0idG9wIj8wOk46YS50b3Atai50b3ArKGUucG9zaXRpb249
PSJ0b3AiP2EuaGVpZ2h0OjApKToodD0wLHE9Zz09ImZ1bGwiP2UucG9zaXRpb249PSJsZWZ0Ij8w
OlI6YS5sZWZ0LWoubGVmdCsoZS5wb3NpdGlvbj09ImxlZnQiP2Eud2lkdGg6MCkpO2UuaW5uZXJt
b3N0fHwoaC5iZWdpblBhdGgoKSxtPWs9MCxlLmRpcmVjdGlvbj09IngiP209IFI6az1OLGgubGlu
ZVdpZHRoPT0xJiYocT1NYXRoLmZsb29yKHEpKzAuNSx0PU1hdGguZmxvb3IodCkrMC41KSxoLm1v
dmVUbyhxLHQpLGgubGluZVRvKHErbSx0K2spLGguc3Ryb2tlKCkpO2guYmVnaW5QYXRoKCk7Zm9y
KGE9MDthPGUudGlja3MubGVuZ3RoOysrYSl7dmFyIHk9ZS50aWNrc1thXS52O209az0wO3k8ZS5t
aW58fHk+ZS5tYXh8fGc9PSJmdWxsIiYmZD4wJiYoeT09ZS5taW58fHk9PWUubWF4KXx8KGUuZGly
ZWN0aW9uPT0ieCI/KHE9ZS5wMmMoeSksaz1nPT0iZnVsbCI/LU46ZyxlLnBvc2l0aW9uPT0idG9w
IiYmKGs9LWspKToodD1lLnAyYyh5KSxtPWc9PSJmdWxsIj8tUjpnLGUucG9zaXRpb249PSJsZWZ0
IiYmKG09LW0pKSxoLmxpbmVXaWR0aD09MSYmKGUuZGlyZWN0aW9uPT0ieCI/cT1NYXRoLmZsb29y
KHEpKzAuNTp0PU1hdGguZmxvb3IodCkrMC41KSxoLm1vdmVUbyhxLHQpLGgubGluZVRvKHErbSx0
K2spKX1oLnN0cm9rZSgpfX1pZihkKWgubGluZVdpZHRoPSBkLGguc3Ryb2tlU3R5bGU9Zi5ncmlk
LmJvcmRlckNvbG9yLGguc3Ryb2tlUmVjdCgtZC8yLC1kLzIsUitkLE4rZCk7aC5yZXN0b3JlKCl9
ZnVuY3Rpb24gZ2EoKXtoLnNhdmUoKTtuLmVhY2goQygpLGZ1bmN0aW9uKGEsZCl7aWYoZC5zaG93
JiZkLnRpY2tzLmxlbmd0aCE9MCl7dmFyIGI9ZC5ib3gsYz1kLmZvbnQ7aC5maWxsU3R5bGU9ZC5v
cHRpb25zLmNvbG9yO2guZm9udD1jLnN0eWxlKyIgIitjLnZhcmlhbnQrIiAiK2Mud2VpZ2h0KyIg
IitjLnNpemUrInB4ICciK2MuZmFtaWx5KyInIjtoLnRleHRBbGlnbj0ic3RhcnQiO2gudGV4dEJh
c2VsaW5lPSJtaWRkbGUiO2ZvcihjPTA7YzxkLnRpY2tzLmxlbmd0aDsrK2Mpe3ZhciBlPWQudGlj
a3NbY107aWYoZS5sYWJlbCYmIShlLnY8ZC5taW58fGUudj5kLm1heCkpZm9yKHZhciBmLHEsdD0w
LG0saz0wO2s8ZS5saW5lcy5sZW5ndGg7KytrKW09ZS5saW5lc1trXSxkLmRpcmVjdGlvbj09Ingi
PyhmPWoubGVmdCtkLnAyYyhlLnYpLW0ud2lkdGgvIDIscT1kLnBvc2l0aW9uPT0iYm90dG9tIj9i
LnRvcCtiLnBhZGRpbmc6Yi50b3ArYi5oZWlnaHQtYi5wYWRkaW5nLWUuaGVpZ2h0KToocT1qLnRv
cCtkLnAyYyhlLnYpLWUuaGVpZ2h0LzIsZj1kLnBvc2l0aW9uPT0ibGVmdCI/Yi5sZWZ0K2Iud2lk
dGgtYi5wYWRkaW5nLW0ud2lkdGg6Yi5sZWZ0K2IucGFkZGluZykscSs9bS5oZWlnaHQvMit0LHQr
PW0uaGVpZ2h0LG4uYnJvd3Nlci5vcGVyYSYmKGY9TWF0aC5mbG9vcihmKSxxPU1hdGguY2VpbChx
LTIpKSxoLmZpbGxUZXh0KG0udGV4dCxmLHEpfX19KTtoLnJlc3RvcmUoKX1mdW5jdGlvbiB2YShh
KXtmdW5jdGlvbiBkKGEsYixkLGMsZSl7dmFyIGY9YS5wb2ludHMsYT1hLnBvaW50c2l6ZSxnPW51
bGwsbj1udWxsO2guYmVnaW5QYXRoKCk7Zm9yKHZhciB1PWE7dTxmLmxlbmd0aDt1Kz1hKXt2YXIg
cj1mW3UtYV0sbz1mW3UtYSsxXSxzPWZbdV0saj1mW3UrMV07aWYoIShyPT1udWxsfHxzPT1udWxs
KSl7aWYobzw9aiYmbzxlLm1pbil7aWYoajwgZS5taW4pY29udGludWU7cj0oZS5taW4tbykvKGot
bykqKHMtcikrcjtvPWUubWlufWVsc2UgaWYoajw9byYmajxlLm1pbil7aWYobzxlLm1pbiljb250
aW51ZTtzPShlLm1pbi1vKS8oai1vKSoocy1yKStyO2o9ZS5taW59aWYobz49aiYmbz5lLm1heCl7
aWYoaj5lLm1heCljb250aW51ZTtyPShlLm1heC1vKS8oai1vKSoocy1yKStyO289ZS5tYXh9ZWxz
ZSBpZihqPj1vJiZqPmUubWF4KXtpZihvPmUubWF4KWNvbnRpbnVlO3M9KGUubWF4LW8pLyhqLW8p
KihzLXIpK3I7aj1lLm1heH1pZihyPD1zJiZyPGMubWluKXtpZihzPGMubWluKWNvbnRpbnVlO289
KGMubWluLXIpLyhzLXIpKihqLW8pK287cj1jLm1pbn1lbHNlIGlmKHM8PXImJnM8Yy5taW4pe2lm
KHI8Yy5taW4pY29udGludWU7aj0oYy5taW4tcikvKHMtcikqKGotbykrbztzPWMubWlufWlmKHI+
PXMmJnI+Yy5tYXgpe2lmKHM+Yy5tYXgpY29udGludWU7bz0oYy5tYXgtcikvKHMtcikqKGotbykr
bztyPWMubWF4fWVsc2UgaWYocz49IHImJnM+Yy5tYXgpe2lmKHI+Yy5tYXgpY29udGludWU7aj0o
Yy5tYXgtcikvKHMtcikqKGotbykrbztzPWMubWF4fShyIT1nfHxvIT1uKSYmaC5tb3ZlVG8oYy5w
MmMocikrYixlLnAyYyhvKStkKTtnPXM7bj1qO2gubGluZVRvKGMucDJjKHMpK2IsZS5wMmMoaikr
ZCl9fWguc3Ryb2tlKCl9ZnVuY3Rpb24gYihhLGIsYyl7Zm9yKHZhciBkPWEucG9pbnRzLGE9YS5w
b2ludHNpemUsZT1NYXRoLm1pbihNYXRoLm1heCgwLGMubWluKSxjLm1heCksZj0wLGc9ITEsaj0x
LHU9MCxuPTA7Oyl7aWYoYT4wJiZmPmQubGVuZ3RoK2EpYnJlYWs7Zis9YTt2YXIgbz1kW2YtYV0s
cz1kW2YtYStqXSxsPWRbZl0scD1kW2Yral07aWYoZyl7aWYoYT4wJiZvIT1udWxsJiZsPT1udWxs
KXtuPWY7YT0tYTtqPTI7Y29udGludWV9aWYoYTwwJiZmPT11K2Epe2guZmlsbCgpO2c9ITE7YT0t
YTtqPTE7Zj11PW4rYTtjb250aW51ZX19aWYoIShvPT1udWxsfHxsPT1udWxsKSl7aWYobzw9bCYm
bzxiLm1pbil7aWYobDwgYi5taW4pY29udGludWU7cz0oYi5taW4tbykvKGwtbykqKHAtcykrcztv
PWIubWlufWVsc2UgaWYobDw9byYmbDxiLm1pbil7aWYobzxiLm1pbiljb250aW51ZTtwPShiLm1p
bi1vKS8obC1vKSoocC1zKStzO2w9Yi5taW59aWYobz49bCYmbz5iLm1heCl7aWYobD5iLm1heClj
b250aW51ZTtzPShiLm1heC1vKS8obC1vKSoocC1zKStzO289Yi5tYXh9ZWxzZSBpZihsPj1vJiZs
PmIubWF4KXtpZihvPmIubWF4KWNvbnRpbnVlO3A9KGIubWF4LW8pLyhsLW8pKihwLXMpK3M7bD1i
Lm1heH1nfHwoaC5iZWdpblBhdGgoKSxoLm1vdmVUbyhiLnAyYyhvKSxjLnAyYyhlKSksZz0hMCk7
aWYocz49Yy5tYXgmJnA+PWMubWF4KWgubGluZVRvKGIucDJjKG8pLGMucDJjKGMubWF4KSksaC5s
aW5lVG8oYi5wMmMobCksYy5wMmMoYy5tYXgpKTtlbHNlIGlmKHM8PWMubWluJiZwPD1jLm1pbilo
LmxpbmVUbyhiLnAyYyhvKSxjLnAyYyhjLm1pbikpLGgubGluZVRvKGIucDJjKGwpLGMucDJjKGMu
bWluKSk7IGVsc2V7dmFyIHc9byx2PWw7aWYoczw9cCYmczxjLm1pbiYmcD49Yy5taW4pbz0oYy5t
aW4tcykvKHAtcykqKGwtbykrbyxzPWMubWluO2Vsc2UgaWYocDw9cyYmcDxjLm1pbiYmcz49Yy5t
aW4pbD0oYy5taW4tcykvKHAtcykqKGwtbykrbyxwPWMubWluO2lmKHM+PXAmJnM+Yy5tYXgmJnA8
PWMubWF4KW89KGMubWF4LXMpLyhwLXMpKihsLW8pK28scz1jLm1heDtlbHNlIGlmKHA+PXMmJnA+
Yy5tYXgmJnM8PWMubWF4KWw9KGMubWF4LXMpLyhwLXMpKihsLW8pK28scD1jLm1heDtvIT13JiZo
LmxpbmVUbyhiLnAyYyh3KSxjLnAyYyhzKSk7aC5saW5lVG8oYi5wMmMobyksYy5wMmMocykpO2gu
bGluZVRvKGIucDJjKGwpLGMucDJjKHApKTtsIT12JiYoaC5saW5lVG8oYi5wMmMobCksYy5wMmMo
cCkpLGgubGluZVRvKGIucDJjKHYpLGMucDJjKHApKSl9fX19aC5zYXZlKCk7aC50cmFuc2xhdGUo
ai5sZWZ0LGoudG9wKTtoLmxpbmVKb2luPSJyb3VuZCI7dmFyIGM9YS5saW5lcy5saW5lV2lkdGgs
IGU9YS5zaGFkb3dTaXplO2lmKGM+MCYmZT4wKXtoLmxpbmVXaWR0aD1lO2guc3Ryb2tlU3R5bGU9
InJnYmEoMCwwLDAsMC4xKSI7dmFyIGY9TWF0aC5QSS8xODtkKGEuZGF0YXBvaW50cyxNYXRoLnNp
bihmKSooYy8yK2UvMiksTWF0aC5jb3MoZikqKGMvMitlLzIpLGEueGF4aXMsYS55YXhpcyk7aC5s
aW5lV2lkdGg9ZS8yO2QoYS5kYXRhcG9pbnRzLE1hdGguc2luKGYpKihjLzIrZS80KSxNYXRoLmNv
cyhmKSooYy8yK2UvNCksYS54YXhpcyxhLnlheGlzKX1oLmxpbmVXaWR0aD1jO2guc3Ryb2tlU3R5
bGU9YS5jb2xvcjtpZihlPVkoYS5saW5lcyxhLmNvbG9yLDAsTikpaC5maWxsU3R5bGU9ZSxiKGEu
ZGF0YXBvaW50cyxhLnhheGlzLGEueWF4aXMpO2M+MCYmZChhLmRhdGFwb2ludHMsMCwwLGEueGF4
aXMsYS55YXhpcyk7aC5yZXN0b3JlKCl9ZnVuY3Rpb24geGEoYSl7ZnVuY3Rpb24gZChhLGIsYyxk
LGUsZixnLGope2Zvcih2YXIgbj1hLnBvaW50cyxhPWEucG9pbnRzaXplLHU9MDt1PCBuLmxlbmd0
aDt1Kz1hKXt2YXIgbz1uW3VdLGw9blt1KzFdO2lmKCEobz09bnVsbHx8bzxmLm1pbnx8bz5mLm1h
eHx8bDxnLm1pbnx8bD5nLm1heCkpe2guYmVnaW5QYXRoKCk7bz1mLnAyYyhvKTtsPWcucDJjKGwp
K2Q7aj09ImNpcmNsZSI/aC5hcmMobyxsLGIsMCxlP01hdGguUEk6TWF0aC5QSSoyLCExKTpqKGgs
byxsLGIsZSk7aC5jbG9zZVBhdGgoKTtpZihjKWguZmlsbFN0eWxlPWMsaC5maWxsKCk7aC5zdHJv
a2UoKX19fWguc2F2ZSgpO2gudHJhbnNsYXRlKGoubGVmdCxqLnRvcCk7dmFyIGI9YS5wb2ludHMu
bGluZVdpZHRoLGM9YS5zaGFkb3dTaXplLGU9YS5wb2ludHMucmFkaXVzLGY9YS5wb2ludHMuc3lt
Ym9sO2lmKGI+MCYmYz4wKWMvPTIsaC5saW5lV2lkdGg9YyxoLnN0cm9rZVN0eWxlPSJyZ2JhKDAs
MCwwLDAuMSkiLGQoYS5kYXRhcG9pbnRzLGUsbnVsbCxjK2MvMiwhMCxhLnhheGlzLGEueWF4aXMs
ZiksaC5zdHJva2VTdHlsZT0icmdiYSgwLDAsMCwwLjIpIixkKGEuZGF0YXBvaW50cywgZSxudWxs
LGMvMiwhMCxhLnhheGlzLGEueWF4aXMsZik7aC5saW5lV2lkdGg9YjtoLnN0cm9rZVN0eWxlPWEu
Y29sb3I7ZChhLmRhdGFwb2ludHMsZSxZKGEucG9pbnRzLGEuY29sb3IpLDAsITEsYS54YXhpcyxh
LnlheGlzLGYpO2gucmVzdG9yZSgpfWZ1bmN0aW9uIGlhKGEsZCxiLGMsZSxmLGcsaCxtLGssaixu
KXt2YXIgbCxwLHcscjtqPyhyPXA9dz0hMCxsPSExLGo9YixiPWQrYyxlPWQrZSxhPGomJihkPWEs
YT1qLGo9ZCxsPSEwLHA9ITEpKToobD1wPXc9ITAscj0hMSxqPWErYyxhKz1lLGU9YixiPWQsYjxl
JiYoZD1iLGI9ZSxlPWQscj0hMCx3PSExKSk7aWYoIShhPGgubWlufHxqPmgubWF4fHxiPG0ubWlu
fHxlPm0ubWF4KSl7aWYoajxoLm1pbilqPWgubWluLGw9ITE7aWYoYT5oLm1heClhPWgubWF4LHA9
ITE7aWYoZTxtLm1pbillPW0ubWluLHI9ITE7aWYoYj5tLm1heCliPW0ubWF4LHc9ITE7aj1oLnAy
YyhqKTtlPW0ucDJjKGUpO2E9aC5wMmMoYSk7Yj1tLnAyYyhiKTtpZihnKWsuYmVnaW5QYXRoKCks
IGsubW92ZVRvKGosZSksay5saW5lVG8oaixiKSxrLmxpbmVUbyhhLGIpLGsubGluZVRvKGEsZSks
ay5maWxsU3R5bGU9ZyhlLGIpLGsuZmlsbCgpO2lmKG4+MCYmKGx8fHB8fHd8fHIpKWsuYmVnaW5Q
YXRoKCksay5tb3ZlVG8oaixlK2YpLGw/ay5saW5lVG8oaixiK2YpOmsubW92ZVRvKGosYitmKSx3
P2subGluZVRvKGEsYitmKTprLm1vdmVUbyhhLGIrZikscD9rLmxpbmVUbyhhLGUrZik6ay5tb3Zl
VG8oYSxlK2YpLHI/ay5saW5lVG8oaixlK2YpOmsubW92ZVRvKGosZStmKSxrLnN0cm9rZSgpfX1m
dW5jdGlvbiB3YShhKXtoLnNhdmUoKTtoLnRyYW5zbGF0ZShqLmxlZnQsai50b3ApO2gubGluZVdp
ZHRoPWEuYmFycy5saW5lV2lkdGg7aC5zdHJva2VTdHlsZT1hLmNvbG9yO3ZhciBkPWEuYmFycy5h
bGlnbj09ImxlZnQiPzA6LWEuYmFycy5iYXJXaWR0aC8yOyhmdW5jdGlvbihiLGMsZCxmLGcsaixt
KXtmb3IodmFyIGs9Yi5wb2ludHMsYj1iLnBvaW50c2l6ZSxsPTA7bDxrLmxlbmd0aDtsKz0gYilr
W2xdIT1udWxsJiZpYShrW2xdLGtbbCsxXSxrW2wrMl0sYyxkLGYsZyxqLG0saCxhLmJhcnMuaG9y
aXpvbnRhbCxhLmJhcnMubGluZVdpZHRoKX0pKGEuZGF0YXBvaW50cyxkLGQrYS5iYXJzLmJhcldp
ZHRoLDAsYS5iYXJzLmZpbGw/ZnVuY3Rpb24oYixjKXtyZXR1cm4gWShhLmJhcnMsYS5jb2xvcixi
LGMpfTpudWxsLGEueGF4aXMsYS55YXhpcyk7aC5yZXN0b3JlKCl9ZnVuY3Rpb24gWShhLGQsYixj
KXt2YXIgZT1hLmZpbGw7aWYoIWUpcmV0dXJuIG51bGw7aWYoYS5maWxsQ29sb3IpcmV0dXJuIGVh
KGEuZmlsbENvbG9yLGIsYyxkKTthPW4uY29sb3IucGFyc2UoZCk7YS5hPXR5cGVvZiBlPT0ibnVt
YmVyIj9lOjAuNDthLm5vcm1hbGl6ZSgpO3JldHVybiBhLnRvU3RyaW5nKCl9ZnVuY3Rpb24gdWEo
KXtnLmZpbmQoIi5sZWdlbmQiKS5yZW1vdmUoKTtpZihmLmxlZ2VuZC5zaG93KXtmb3IodmFyIGE9
W10sZD0hMSxiPWYubGVnZW5kLmxhYmVsRm9ybWF0dGVyLGMsZSxoPTA7aDwgdy5sZW5ndGg7Kyto
KWlmKGM9d1toXSxlPWMubGFiZWwpaCVmLmxlZ2VuZC5ub0NvbHVtbnM9PTAmJihkJiZhLnB1c2go
IjwvdHI+IiksYS5wdXNoKCI8dHI+IiksZD0hMCksYiYmKGU9YihlLGMpKSxhLnB1c2goJzx0ZCBj
bGFzcz0ibGVnZW5kQ29sb3JCb3giPjxkaXYgc3R5bGU9ImJvcmRlcjoxcHggc29saWQgJytmLmxl
Z2VuZC5sYWJlbEJveEJvcmRlckNvbG9yKyc7cGFkZGluZzoxcHgiPjxkaXYgc3R5bGU9IndpZHRo
OjRweDtoZWlnaHQ6MDtib3JkZXI6NXB4IHNvbGlkICcrYy5jb2xvcisnO292ZXJmbG93OmhpZGRl
biI+PC9kaXY+PC9kaXY+PC90ZD48dGQgY2xhc3M9ImxlZ2VuZExhYmVsIj4nK2UrIjwvdGQ+Iik7
ZCYmYS5wdXNoKCI8L3RyPiIpO2lmKGEubGVuZ3RoIT0wKWlmKGQ9Jzx0YWJsZSBzdHlsZT0iZm9u
dC1zaXplOnNtYWxsZXI7Y29sb3I6JytmLmdyaWQuY29sb3IrJyI+JythLmpvaW4oIiIpKyI8L3Rh
YmxlPiIsZi5sZWdlbmQuY29udGFpbmVyIT1udWxsKW4oZi5sZWdlbmQuY29udGFpbmVyKS5odG1s
KGQpOyBlbHNlIGlmKGE9IiIsYj1mLmxlZ2VuZC5wb3NpdGlvbixjPWYubGVnZW5kLm1hcmdpbixj
WzBdPT1udWxsJiYoYz1bYyxjXSksYi5jaGFyQXQoMCk9PSJuIj9hKz0idG9wOiIrKGNbMV0rai50
b3ApKyJweDsiOmIuY2hhckF0KDApPT0icyImJihhKz0iYm90dG9tOiIrKGNbMV0rai5ib3R0b20p
KyJweDsiKSxiLmNoYXJBdCgxKT09ImUiP2ErPSJyaWdodDoiKyhjWzBdK2oucmlnaHQpKyJweDsi
OmIuY2hhckF0KDEpPT0idyImJihhKz0ibGVmdDoiKyhjWzBdK2oubGVmdCkrInB4OyIpLGQ9bign
PGRpdiBjbGFzcz0ibGVnZW5kIj4nK2QucmVwbGFjZSgnc3R5bGU9IicsJ3N0eWxlPSJwb3NpdGlv
bjphYnNvbHV0ZTsnK2ErIjsiKSsiPC9kaXY+IikuYXBwZW5kVG8oZyksZi5sZWdlbmQuYmFja2dy
b3VuZE9wYWNpdHkhPTApe2I9Zi5sZWdlbmQuYmFja2dyb3VuZENvbG9yO2lmKGI9PW51bGwpYj0o
Yj1mLmdyaWQuYmFja2dyb3VuZENvbG9yKSYmdHlwZW9mIGI9PSJzdHJpbmciP24uY29sb3IucGFy
c2UoYik6IG4uY29sb3IuZXh0cmFjdChkLCJiYWNrZ3JvdW5kLWNvbG9yIiksYi5hPTEsYj1iLnRv
U3RyaW5nKCk7Yz1kLmNoaWxkcmVuKCk7bignPGRpdiBzdHlsZT0icG9zaXRpb246YWJzb2x1dGU7
d2lkdGg6JytjLndpZHRoKCkrInB4O2hlaWdodDoiK2MuaGVpZ2h0KCkrInB4OyIrYSsiYmFja2dy
b3VuZC1jb2xvcjoiK2IrJzsiPiA8L2Rpdj4nKS5wcmVwZW5kVG8oZCkuY3NzKCJvcGFjaXR5Iixm
LmxlZ2VuZC5iYWNrZ3JvdW5kT3BhY2l0eSl9fX1mdW5jdGlvbiBqYShhKXtmLmdyaWQuaG92ZXJh
YmxlJiZaKCJwbG90aG92ZXIiLGEsZnVuY3Rpb24oYSl7cmV0dXJuIGEuaG92ZXJhYmxlIT0hMX0p
fWZ1bmN0aW9uIGthKGEpe2YuZ3JpZC5ob3ZlcmFibGUmJlooInBsb3Rob3ZlciIsYSxmdW5jdGlv
bigpe3JldHVybiExfSl9ZnVuY3Rpb24gbGEoYSl7WigicGxvdGNsaWNrIixhLGZ1bmN0aW9uKGEp
e3JldHVybiBhLmNsaWNrYWJsZSE9ITF9KX1mdW5jdGlvbiBaKGEsZCxiKXt2YXIgYz1LLm9mZnNl
dCgpLCBlPWQucGFnZVgtYy5sZWZ0LWoubGVmdCxoPWQucGFnZVktYy50b3Atai50b3AsbD1VKHts
ZWZ0OmUsdG9wOmh9KTtsLnBhZ2VYPWQucGFnZVg7bC5wYWdlWT1kLnBhZ2VZO3ZhciBkPWYuZ3Jp
ZC5tb3VzZUFjdGl2ZVJhZGl1cyxuPWQqZCsxLG09bnVsbCxrLHA7Zm9yKGs9dy5sZW5ndGgtMTtr
Pj0wOy0taylpZihiKHdba10pKXt2YXIgdj13W2tdLHg9di54YXhpcyx6PXYueWF4aXMsRD12LmRh
dGFwb2ludHMucG9pbnRzLHI9di5kYXRhcG9pbnRzLnBvaW50c2l6ZSxvPXguYzJwKGUpLHM9ei5j
MnAoaCksQj1kL3guc2NhbGUsQz1kL3ouc2NhbGU7aWYoeC5vcHRpb25zLmludmVyc2VUcmFuc2Zv
cm0pQj1OdW1iZXIuTUFYX1ZBTFVFO2lmKHoub3B0aW9ucy5pbnZlcnNlVHJhbnNmb3JtKUM9TnVt
YmVyLk1BWF9WQUxVRTtpZih2LmxpbmVzLnNob3d8fHYucG9pbnRzLnNob3cpZm9yKHA9MDtwPEQu
bGVuZ3RoO3ArPXIpe3ZhciBBPURbcF0sRT1EW3ArMV07aWYoQSE9bnVsbCYmIShBLW8+IEJ8fEEt
bzwtQnx8RS1zPkN8fEUtczwtQykpQT1NYXRoLmFicyh4LnAyYyhBKS1lKSxFPU1hdGguYWJzKHou
cDJjKEUpLWgpLEU9QSpBK0UqRSxFPG4mJihuPUUsbT1bayxwL3JdKX1pZih2LmJhcnMuc2hvdyYm
IW0pe3g9di5iYXJzLmFsaWduPT0ibGVmdCI/MDotdi5iYXJzLmJhcldpZHRoLzI7dj14K3YuYmFy
cy5iYXJXaWR0aDtmb3IocD0wO3A8RC5sZW5ndGg7cCs9cilpZihBPURbcF0sRT1EW3ArMV0sej1E
W3ArMl0sQSE9bnVsbCYmKHdba10uYmFycy5ob3Jpem9udGFsP288PU1hdGgubWF4KHosQSkmJm8+
PU1hdGgubWluKHosQSkmJnM+PUUreCYmczw9RSt2Om8+PUEreCYmbzw9QSt2JiZzPj1NYXRoLm1p
bih6LEUpJiZzPD1NYXRoLm1heCh6LEUpKSltPVtrLHAvcl19fW0/KGs9bVswXSxwPW1bMV0scj13
W2tdLmRhdGFwb2ludHMucG9pbnRzaXplLGI9e2RhdGFwb2ludDp3W2tdLmRhdGFwb2ludHMucG9p
bnRzLnNsaWNlKHAqciwocCsxKSpyKSxkYXRhSW5kZXg6cCxzZXJpZXM6d1trXSwgc2VyaWVzSW5k
ZXg6a30pOmI9bnVsbDtpZihiKWIucGFnZVg9cGFyc2VJbnQoYi5zZXJpZXMueGF4aXMucDJjKGIu
ZGF0YXBvaW50WzBdKStjLmxlZnQrai5sZWZ0KSxiLnBhZ2VZPXBhcnNlSW50KGIuc2VyaWVzLnlh
eGlzLnAyYyhiLmRhdGFwb2ludFsxXSkrYy50b3Arai50b3ApO2lmKGYuZ3JpZC5hdXRvSGlnaGxp
Z2h0KXtmb3IoYz0wO2M8Ty5sZW5ndGg7KytjKWU9T1tjXSxlLmF1dG89PWEmJighYnx8IShlLnNl
cmllcz09Yi5zZXJpZXMmJmUucG9pbnRbMF09PWIuZGF0YXBvaW50WzBdJiZlLnBvaW50WzFdPT1i
LmRhdGFwb2ludFsxXSkpJiZtYShlLnNlcmllcyxlLnBvaW50KTtiJiZuYShiLnNlcmllcyxiLmRh
dGFwb2ludCxhKX1nLnRyaWdnZXIoYSxbbCxiXSl9ZnVuY3Rpb24gWCgpe3ZhciBhPWYuaW50ZXJh
Y3Rpb24ucmVkcmF3T3ZlcmxheUludGVydmFsO2E9PS0xP29hKCk6Vnx8KFY9c2V0VGltZW91dChv
YSxhKSl9ZnVuY3Rpb24gb2EoKXtWPW51bGw7Qi5zYXZlKCk7IEIuY2xlYXJSZWN0KDAsMCxHLEgp
O0IudHJhbnNsYXRlKGoubGVmdCxqLnRvcCk7dmFyIGEsZDtmb3IoYT0wO2E8Ty5sZW5ndGg7Kyth
KWlmKGQ9T1thXSxkLnNlcmllcy5iYXJzLnNob3cpeWEoZC5zZXJpZXMsZC5wb2ludCk7ZWxzZXt2
YXIgYj1kLnNlcmllcyxjPWQucG9pbnQ7ZD1jWzBdO3ZhciBjPWNbMV0sZT1iLnhheGlzLGY9Yi55
YXhpcztpZighKGQ8ZS5taW58fGQ+ZS5tYXh8fGM8Zi5taW58fGM+Zi5tYXgpKXt2YXIgaD1iLnBv
aW50cy5yYWRpdXMrYi5wb2ludHMubGluZVdpZHRoLzI7Qi5saW5lV2lkdGg9aDtCLnN0cm9rZVN0
eWxlPW4uY29sb3IucGFyc2UoYi5jb2xvcikuc2NhbGUoImEiLDAuNSkudG9TdHJpbmcoKTtoKj0x
LjU7ZD1lLnAyYyhkKTtjPWYucDJjKGMpO0IuYmVnaW5QYXRoKCk7Yi5wb2ludHMuc3ltYm9sPT0i
Y2lyY2xlIj9CLmFyYyhkLGMsaCwwLDIqTWF0aC5QSSwhMSk6Yi5wb2ludHMuc3ltYm9sKEIsZCxj
LGgsITEpO0IuY2xvc2VQYXRoKCk7Qi5zdHJva2UoKX19Qi5yZXN0b3JlKCk7IEkoSi5kcmF3T3Zl
cmxheSxbQl0pfWZ1bmN0aW9uIG5hKGEsZCxiKXt0eXBlb2YgYT09Im51bWJlciImJihhPXdbYV0p
O2lmKHR5cGVvZiBkPT0ibnVtYmVyIil2YXIgYz1hLmRhdGFwb2ludHMucG9pbnRzaXplLGQ9YS5k
YXRhcG9pbnRzLnBvaW50cy5zbGljZShjKmQsYyooZCsxKSk7Yz1wYShhLGQpO2lmKGM9PS0xKU8u
cHVzaCh7c2VyaWVzOmEscG9pbnQ6ZCxhdXRvOmJ9KSxYKCk7ZWxzZSBpZighYilPW2NdLmF1dG89
ITF9ZnVuY3Rpb24gbWEoYSxkKXthPT1udWxsJiZkPT1udWxsJiYoTz1bXSxYKCkpO3R5cGVvZiBh
PT0ibnVtYmVyIiYmKGE9d1thXSk7dHlwZW9mIGQ9PSJudW1iZXIiJiYoZD1hLmRhdGFbZF0pO3Zh
ciBiPXBhKGEsZCk7YiE9LTEmJihPLnNwbGljZShiLDEpLFgoKSl9ZnVuY3Rpb24gcGEoYSxkKXtm
b3IodmFyIGI9MDtiPE8ubGVuZ3RoOysrYil7dmFyIGM9T1tiXTtpZihjLnNlcmllcz09YSYmYy5w
b2ludFswXT09ZFswXSYmYy5wb2ludFsxXT09ZFsxXSlyZXR1cm4gYn1yZXR1cm4tMX0gZnVuY3Rp
b24geWEoYSxkKXtCLmxpbmVXaWR0aD1hLmJhcnMubGluZVdpZHRoO0Iuc3Ryb2tlU3R5bGU9bi5j
b2xvci5wYXJzZShhLmNvbG9yKS5zY2FsZSgiYSIsMC41KS50b1N0cmluZygpO3ZhciBiPW4uY29s
b3IucGFyc2UoYS5jb2xvcikuc2NhbGUoImEiLDAuNSkudG9TdHJpbmcoKSxjPWEuYmFycy5hbGln
bj09ImxlZnQiPzA6LWEuYmFycy5iYXJXaWR0aC8yO2lhKGRbMF0sZFsxXSxkWzJdfHwwLGMsYyth
LmJhcnMuYmFyV2lkdGgsMCxmdW5jdGlvbigpe3JldHVybiBifSxhLnhheGlzLGEueWF4aXMsQixh
LmJhcnMuaG9yaXpvbnRhbCxhLmJhcnMubGluZVdpZHRoKX1mdW5jdGlvbiBlYShhLGQsYixjKXtp
Zih0eXBlb2YgYT09InN0cmluZyIpcmV0dXJuIGE7ZWxzZXtmb3IodmFyIGQ9aC5jcmVhdGVMaW5l
YXJHcmFkaWVudCgwLGIsMCxkKSxiPTAsZT1hLmNvbG9ycy5sZW5ndGg7YjxlOysrYil7dmFyIGY9
YS5jb2xvcnNbYl07aWYodHlwZW9mIGYhPSJzdHJpbmciKXt2YXIgZz0gbi5jb2xvci5wYXJzZShj
KTtmLmJyaWdodG5lc3MhPW51bGwmJihnPWcuc2NhbGUoInJnYiIsZi5icmlnaHRuZXNzKSk7Zi5v
cGFjaXR5IT1udWxsJiYoZy5hKj1mLm9wYWNpdHkpO2Y9Zy50b1N0cmluZygpfWQuYWRkQ29sb3JT
dG9wKGIvKGUtMSksZil9cmV0dXJuIGR9fXZhciB3PVtdLGY9e2NvbG9yczpbIiNlZGMyNDAiLCIj
YWZkOGY4IiwiI2NiNGI0YiIsIiM0ZGE3NGQiLCIjOTQ0MGVkIl0sbGVnZW5kOntzaG93OiEwLG5v
Q29sdW1uczoxLGxhYmVsRm9ybWF0dGVyOm51bGwsbGFiZWxCb3hCb3JkZXJDb2xvcjoiI2NjYyIs
Y29udGFpbmVyOm51bGwscG9zaXRpb246Im5lIixtYXJnaW46NSxiYWNrZ3JvdW5kQ29sb3I6bnVs
bCxiYWNrZ3JvdW5kT3BhY2l0eTowLjg1fSx4YXhpczp7c2hvdzpudWxsLHBvc2l0aW9uOiJib3R0
b20iLG1vZGU6bnVsbCxmb250Om51bGwsY29sb3I6bnVsbCx0aWNrQ29sb3I6bnVsbCx0cmFuc2Zv
cm06bnVsbCxpbnZlcnNlVHJhbnNmb3JtOm51bGwsIG1pbjpudWxsLG1heDpudWxsLGF1dG9zY2Fs
ZU1hcmdpbjpudWxsLHRpY2tzOm51bGwsdGlja0Zvcm1hdHRlcjpudWxsLGxhYmVsV2lkdGg6bnVs
bCxsYWJlbEhlaWdodDpudWxsLHJlc2VydmVTcGFjZTpudWxsLHRpY2tMZW5ndGg6bnVsbCxhbGln
blRpY2tzV2l0aEF4aXM6bnVsbCx0aWNrRGVjaW1hbHM6bnVsbCx0aWNrU2l6ZTpudWxsLG1pblRp
Y2tTaXplOm51bGwsbW9udGhOYW1lczpudWxsLHRpbWVmb3JtYXQ6bnVsbCx0d2VsdmVIb3VyQ2xv
Y2s6ITF9LHlheGlzOnthdXRvc2NhbGVNYXJnaW46MC4wMixwb3NpdGlvbjoibGVmdCJ9LHhheGVz
OltdLHlheGVzOltdLHNlcmllczp7cG9pbnRzOntzaG93OiExLHJhZGl1czozLGxpbmVXaWR0aDoy
LGZpbGw6ITAsZmlsbENvbG9yOiIjZmZmZmZmIixzeW1ib2w6ImNpcmNsZSJ9LGxpbmVzOntsaW5l
V2lkdGg6MixmaWxsOiExLGZpbGxDb2xvcjpudWxsLHN0ZXBzOiExfSxiYXJzOntzaG93OiExLGxp
bmVXaWR0aDoyLGJhcldpZHRoOjEsIGZpbGw6ITAsZmlsbENvbG9yOm51bGwsYWxpZ246ImxlZnQi
LGhvcml6b250YWw6ITF9LHNoYWRvd1NpemU6M30sZ3JpZDp7c2hvdzohMCxhYm92ZURhdGE6ITEs
Y29sb3I6IiM1NDU0NTQiLGJhY2tncm91bmRDb2xvcjpudWxsLGJvcmRlckNvbG9yOm51bGwsdGlj
a0NvbG9yOm51bGwsbGFiZWxNYXJnaW46NSxheGlzTWFyZ2luOjgsYm9yZGVyV2lkdGg6MixtaW5C
b3JkZXJNYXJnaW46bnVsbCxtYXJraW5nczpudWxsLG1hcmtpbmdzQ29sb3I6IiNmNGY0ZjQiLG1h
cmtpbmdzTGluZVdpZHRoOjIsY2xpY2thYmxlOiExLGhvdmVyYWJsZTohMSxhdXRvSGlnaGxpZ2h0
OiEwLG1vdXNlQWN0aXZlUmFkaXVzOjEwfSxpbnRlcmFjdGlvbjp7cmVkcmF3T3ZlcmxheUludGVy
dmFsOjFFMy82MH0saG9va3M6e319LFM9bnVsbCxUPW51bGwsSz1udWxsLGg9bnVsbCxCPW51bGws
QT1bXSxGPVtdLGo9e2xlZnQ6MCxyaWdodDowLHRvcDowLGJvdHRvbTowfSxHPTAsSD0wLFI9MCxO
PTAsSj17cHJvY2Vzc09wdGlvbnM6W10sIHByb2Nlc3NSYXdEYXRhOltdLHByb2Nlc3NEYXRhcG9p
bnRzOltdLGRyYXdTZXJpZXM6W10sZHJhdzpbXSxiaW5kRXZlbnRzOltdLGRyYXdPdmVybGF5Oltd
LHNodXRkb3duOltdfSx2PXRoaXM7di5zZXREYXRhPSQ7di5zZXR1cEdyaWQ9Y2E7di5kcmF3PWRh
O3YuZ2V0UGxhY2Vob2xkZXI9ZnVuY3Rpb24oKXtyZXR1cm4gZ307di5nZXRDYW52YXM9ZnVuY3Rp
b24oKXtyZXR1cm4gU307di5nZXRQbG90T2Zmc2V0PWZ1bmN0aW9uKCl7cmV0dXJuIGp9O3Yud2lk
dGg9ZnVuY3Rpb24oKXtyZXR1cm4gUn07di5oZWlnaHQ9ZnVuY3Rpb24oKXtyZXR1cm4gTn07di5v
ZmZzZXQ9ZnVuY3Rpb24oKXt2YXIgYT1LLm9mZnNldCgpO2EubGVmdCs9ai5sZWZ0O2EudG9wKz1q
LnRvcDtyZXR1cm4gYX07di5nZXREYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIHd9O3YuZ2V0QXhlcz1m
dW5jdGlvbigpe3ZhciBhPXt9O24uZWFjaChBLmNvbmNhdChGKSxmdW5jdGlvbihkLGIpe2ImJihh
W2IuZGlyZWN0aW9uKyAoYi5uIT0xP2IubjoiIikrImF4aXMiXT1iKX0pO3JldHVybiBhfTt2Lmdl
dFhBeGVzPWZ1bmN0aW9uKCl7cmV0dXJuIEF9O3YuZ2V0WUF4ZXM9ZnVuY3Rpb24oKXtyZXR1cm4g
Rn07di5jMnA9VTt2LnAyYz1mdW5jdGlvbihhKXt2YXIgZD17fSxiLGMsZTtmb3IoYj0wO2I8QS5s
ZW5ndGg7KytiKWlmKChjPUFbYl0pJiZjLnVzZWQpaWYoZT0ieCIrYy5uLGFbZV09PW51bGwmJmMu
bj09MSYmKGU9IngiKSxhW2VdIT1udWxsKXtkLmxlZnQ9Yy5wMmMoYVtlXSk7YnJlYWt9Zm9yKGI9
MDtiPEYubGVuZ3RoOysrYilpZigoYz1GW2JdKSYmYy51c2VkKWlmKGU9InkiK2MubixhW2VdPT1u
dWxsJiZjLm49PTEmJihlPSJ5IiksYVtlXSE9bnVsbCl7ZC50b3A9Yy5wMmMoYVtlXSk7YnJlYWt9
cmV0dXJuIGR9O3YuZ2V0T3B0aW9ucz1mdW5jdGlvbigpe3JldHVybiBmfTt2LmhpZ2hsaWdodD1u
YTt2LnVuaGlnaGxpZ2h0PW1hO3YudHJpZ2dlclJlZHJhd092ZXJsYXk9WDt2LnBvaW50T2Zmc2V0
PWZ1bmN0aW9uKGEpe3JldHVybntsZWZ0OnBhcnNlSW50KEFbUChhLCAieCIpLTFdLnAyYygrYS54
KStqLmxlZnQpLHRvcDpwYXJzZUludChGW1AoYSwieSIpLTFdLnAyYygrYS55KStqLnRvcCl9fTt2
LnNodXRkb3duPWZ1bmN0aW9uKCl7ViYmY2xlYXJUaW1lb3V0KFYpO0sudW5iaW5kKCJtb3VzZW1v
dmUiLGphKTtLLnVuYmluZCgibW91c2VsZWF2ZSIsa2EpO0sudW5iaW5kKCJjbGljayIsbGEpO0ko
Si5zaHV0ZG93bixbS10pfTt2LnJlc2l6ZT1mdW5jdGlvbigpe00oKTtiYShTKTtiYShUKX07di5o
b29rcz1KOyhmdW5jdGlvbigpe2Zvcih2YXIgYT0wO2E8bC5sZW5ndGg7KythKXt2YXIgZD1sW2Fd
O2QuaW5pdCh2KTtkLm9wdGlvbnMmJm4uZXh0ZW5kKCEwLGYsZC5vcHRpb25zKX19KSh2KTsoZnVu
Y3Rpb24oYSl7bi5leHRlbmQoITAsZixhKTtpZihmLnhheGlzLmNvbG9yPT1udWxsKWYueGF4aXMu
Y29sb3I9Zi5ncmlkLmNvbG9yO2lmKGYueWF4aXMuY29sb3I9PW51bGwpZi55YXhpcy5jb2xvcj1m
LmdyaWQuY29sb3I7aWYoZi54YXhpcy50aWNrQ29sb3I9PSBudWxsKWYueGF4aXMudGlja0NvbG9y
PWYuZ3JpZC50aWNrQ29sb3I7aWYoZi55YXhpcy50aWNrQ29sb3I9PW51bGwpZi55YXhpcy50aWNr
Q29sb3I9Zi5ncmlkLnRpY2tDb2xvcjtpZihmLmdyaWQuYm9yZGVyQ29sb3I9PW51bGwpZi5ncmlk
LmJvcmRlckNvbG9yPWYuZ3JpZC5jb2xvcjtpZihmLmdyaWQudGlja0NvbG9yPT1udWxsKWYuZ3Jp
ZC50aWNrQ29sb3I9bi5jb2xvci5wYXJzZShmLmdyaWQuY29sb3IpLnNjYWxlKCJhIiwwLjIyKS50
b1N0cmluZygpO2ZvcihhPTA7YTxNYXRoLm1heCgxLGYueGF4ZXMubGVuZ3RoKTsrK2EpZi54YXhl
c1thXT1uLmV4dGVuZCghMCx7fSxmLnhheGlzLGYueGF4ZXNbYV0pO2ZvcihhPTA7YTxNYXRoLm1h
eCgxLGYueWF4ZXMubGVuZ3RoKTsrK2EpZi55YXhlc1thXT1uLmV4dGVuZCghMCx7fSxmLnlheGlz
LGYueWF4ZXNbYV0pO2lmKGYueGF4aXMubm9UaWNrcyYmZi54YXhpcy50aWNrcz09bnVsbClmLnhh
eGlzLnRpY2tzPWYueGF4aXMubm9UaWNrczsgaWYoZi55YXhpcy5ub1RpY2tzJiZmLnlheGlzLnRp
Y2tzPT1udWxsKWYueWF4aXMudGlja3M9Zi55YXhpcy5ub1RpY2tzO2lmKGYueDJheGlzKWYueGF4
ZXNbMV09bi5leHRlbmQoITAse30sZi54YXhpcyxmLngyYXhpcyksZi54YXhlc1sxXS5wb3NpdGlv
bj0idG9wIjtpZihmLnkyYXhpcylmLnlheGVzWzFdPW4uZXh0ZW5kKCEwLHt9LGYueWF4aXMsZi55
MmF4aXMpLGYueWF4ZXNbMV0ucG9zaXRpb249InJpZ2h0IjtpZihmLmdyaWQuY29sb3JlZEFyZWFz
KWYuZ3JpZC5tYXJraW5ncz1mLmdyaWQuY29sb3JlZEFyZWFzO2lmKGYuZ3JpZC5jb2xvcmVkQXJl
YXNDb2xvcilmLmdyaWQubWFya2luZ3NDb2xvcj1mLmdyaWQuY29sb3JlZEFyZWFzQ29sb3I7Zi5s
aW5lcyYmbi5leHRlbmQoITAsZi5zZXJpZXMubGluZXMsZi5saW5lcyk7Zi5wb2ludHMmJm4uZXh0
ZW5kKCEwLGYuc2VyaWVzLnBvaW50cyxmLnBvaW50cyk7Zi5iYXJzJiZuLmV4dGVuZCghMCxmLnNl
cmllcy5iYXJzLGYuYmFycyk7IGlmKGYuc2hhZG93U2l6ZSE9bnVsbClmLnNlcmllcy5zaGFkb3dT
aXplPWYuc2hhZG93U2l6ZTtmb3IoYT0wO2E8Zi54YXhlcy5sZW5ndGg7KythKVEoQSxhKzEpLm9w
dGlvbnM9Zi54YXhlc1thXTtmb3IoYT0wO2E8Zi55YXhlcy5sZW5ndGg7KythKVEoRixhKzEpLm9w
dGlvbnM9Zi55YXhlc1thXTtmb3IodmFyIGQgaW4gSilmLmhvb2tzW2RdJiZmLmhvb2tzW2RdLmxl
bmd0aCYmKEpbZF09SltkXS5jb25jYXQoZi5ob29rc1tkXSkpO0koSi5wcm9jZXNzT3B0aW9ucyxb
Zl0pfSkoVyk7KGZ1bmN0aW9uKCl7dmFyIGE7YT1nLmNoaWxkcmVuKCJjYW52YXMuYmFzZSIpO3Zh
ciBkPWcuY2hpbGRyZW4oImNhbnZhcy5vdmVybGF5Iik7YS5sZW5ndGg9PTB8fGQ9PTA/KGcuaHRt
bCgiIiksZy5jc3Moe3BhZGRpbmc6MH0pLGcuY3NzKCJwb3NpdGlvbiIpPT0ic3RhdGljIiYmZy5j
c3MoInBvc2l0aW9uIiwicmVsYXRpdmUiKSxNKCksUz1hYSghMCwiYmFzZSIpLFQ9YWEoITEsIm92
ZXJsYXkiKSwgYT0hMSk6KFM9YS5nZXQoMCksVD1kLmdldCgwKSxhPSEwKTtoPVMuZ2V0Q29udGV4
dCgiMmQiKTtCPVQuZ2V0Q29udGV4dCgiMmQiKTtLPW4oVCk7YSYmKGcuZGF0YSgicGxvdCIpLnNo
dXRkb3duKCksdi5yZXNpemUoKSxCLmNsZWFyUmVjdCgwLDAsRyxIKSxLLnVuYmluZCgpLGcuY2hp
bGRyZW4oKS5ub3QoW1MsVF0pLnJlbW92ZSgpKTtnLmRhdGEoInBsb3QiLHYpfSkoKTskKHApO2Nh
KCk7ZGEoKTtmLmdyaWQuaG92ZXJhYmxlJiYoSy5tb3VzZW1vdmUoamEpLEsubW91c2VsZWF2ZShr
YSkpO2YuZ3JpZC5jbGlja2FibGUmJksuY2xpY2sobGEpO0koSi5iaW5kRXZlbnRzLFtLXSk7dmFy
IE89W10sVj1udWxsfWZ1bmN0aW9uIHgoZyxuKXtyZXR1cm4gbipNYXRoLmZsb29yKGcvbil9bi5w
bG90PWZ1bmN0aW9uKGcscCx4KXtyZXR1cm4gbmV3IE0obihnKSxwLHgsbi5wbG90LnBsdWdpbnMp
fTtuLnBsb3QudmVyc2lvbj0iMC43IjtuLnBsb3QucGx1Z2lucz1bXTtuLnBsb3QuZm9ybWF0RGF0
ZT0gZnVuY3Rpb24oZyxuLHgpe3ZhciBsPWZ1bmN0aW9uKGcpe2c9IiIrZztyZXR1cm4gZy5sZW5n
dGg9PTE/IjAiK2c6Z30sST1bXSxNPSExLFA9ITEsQz1nLmdldFVUQ0hvdXJzKCksVT1DPDEyO3g9
PW51bGwmJih4PVsiSmFuIiwiRmViIiwiTWFyIiwiQXByIiwiTWF5IiwiSnVuIiwiSnVsIiwiQXVn
IiwiU2VwIiwiT2N0IiwiTm92IiwiRGVjIl0pO24uc2VhcmNoKC8lcHwlUC8pIT0tMSYmKEM+MTI/
Qy09MTI6Qz09MCYmKEM9MTIpKTtmb3IodmFyIFE9MDtRPG4ubGVuZ3RoOysrUSl7dmFyIHo9bi5j
aGFyQXQoUSk7aWYoTSl7c3dpdGNoKHope2Nhc2UgImgiOno9IiIrQzticmVhaztjYXNlICJIIjp6
PWwoQyk7YnJlYWs7Y2FzZSAiTSI6ej1sKGcuZ2V0VVRDTWludXRlcygpKTticmVhaztjYXNlICJT
Ijp6PWwoZy5nZXRVVENTZWNvbmRzKCkpO2JyZWFrO2Nhc2UgImQiOno9IiIrZy5nZXRVVENEYXRl
KCk7YnJlYWs7Y2FzZSAibSI6ej0iIisoZy5nZXRVVENNb250aCgpKzEpO2JyZWFrOyBjYXNlICJ5
Ijp6PSIiK2cuZ2V0VVRDRnVsbFllYXIoKTticmVhaztjYXNlICJiIjp6PSIiK3hbZy5nZXRVVENN
b250aCgpXTticmVhaztjYXNlICJwIjp6PVU/ImFtIjoicG0iO2JyZWFrO2Nhc2UgIlAiOno9VT8i
QU0iOiJQTSI7YnJlYWs7Y2FzZSAiMCI6ej0iIixQPSEwfXomJlAmJih6PWwoeiksUD0hMSk7SS5w
dXNoKHopO1B8fChNPSExKX1lbHNlIHo9PSIlIj9NPSEwOkkucHVzaCh6KX1yZXR1cm4gSS5qb2lu
KCIiKX19KShqUXVlcnkpOw0KCTwvc2NyaXB0Pg0KCTxzdHlsZSBtZWRpYT0ic2NyZWVuIj4NCi5j
b2wgew0KICAgIG1hcmdpbi1yaWdodDogMS4yZW07DQogICAgZmxvYXQ6IGxlZnQ7DQp9DQoNCi5s
YXN0IHsNCiAgICBtYXJnaW4tcmlnaHQ6IDA7DQp9DQoNCi5zcGFuLTEgew0KICAgIHdpZHRoOiA2
LjRlbTsNCn0NCg0KLm51ZGdlLTEgew0KICAgIHBhZGRpbmctbGVmdDogNy42ZW07DQp9DQoNCi5z
cGFuLTIgew0KICAgIHdpZHRoOiAxNGVtOw0KfQ0KDQovKiBMYSB1bHRpbWEgY29sdW1hbmEgc2Ug
dGllbmUgcXVlIG51ZGdlYXIgMSBndXR0ZXIgbWVub3MgKDEuMiBlbSBtZW5vcykgKi8NCg0KLm51
ZGdlLTIgew0KICAgIHBhZGRpbmctbGVmdDogMTUuMmVtOw0KfQ0KDQouc3Bhbi0zIHsNCiAgICB3
aWR0aDogMjEuNmVtOw0KfQ0KDQoubnVkZ2UtMyB7DQogICAgcGFkZGluZy1sZWZ0OiAyMi44ZW07
DQp9DQoNCi5zcGFuLTQgew0KICAgIHdpZHRoOiAyOS4yZW07DQp9DQoNCi5udWRnZS00IHsNCiAg
ICBwYWRkaW5nLWxlZnQ6IDMwLjRlbTsNCn0NCg0KLnNwYW4tNSB7DQogICAgd2lkdGg6IDM2Ljhl
bTsNCn0NCg0KLm51ZGdlLTUgew0KICAgIHBhZGRpbmctbGVmdDogMzhlbTsNCn0NCg0KLnNwYW4t
NiB7DQogICAgd2lkdGg6IDQ0LjRlbTsNCn0NCg0KLm51ZGdlLTYgew0KICAgIHBhZGRpbmctbGVm
dDogNDUuNmVtOw0KfQ0KDQouc3Bhbi03IHsNCiAgICB3aWR0aDogNTJlbTsNCn0NCg0KLm51ZGdl
LTcgew0KICAgIHBhZGRpbmctbGVmdDogNTMuMmVtOw0KfQ0KDQouc3Bhbi04IHsNCiAgICB3aWR0
aDogNTkuNmVtOw0KfQ0KDQoubnVkZ2UtOCB7DQogICAgcGFkZGluZy1sZWZ0OiA2MC44ZW07DQp9
DQoNCi5zcGFuLTkgew0KICAgIHdpZHRoOiA2Ny4yZW07DQp9DQoNCi5udWRnZS05IHsNCiAgICBw
YWRkaW5nLWxlZnQ6IDY4LjRlbTsNCn0NCg0KLnNwYW4tMTAgew0KICAgIHdpZHRoOiA3NC44ZW07
DQp9DQoNCi5udWRnZS0xMCB7DQogICAgcGFkZGluZy1sZWZ0OiA3NmVtOw0KfQ0KDQouc3Bhbi0x
MSB7DQogICAgd2lkdGg6IDcxLjRlbTsNCn0NCg0KLm51ZGdlLTExIHsNCiAgICBwYWRkaW5nLWxl
ZnQ6IDgzLjZlbTsNCn0NCg0KLnNwYW4tMTIgew0KICAgIHdpZHRoOiA5MGVtOw0KfQ0KDQovKiAt
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBbICogXSAqLw0K
DQoqIHsNCgltYXJnaW46IDA7DQoJcGFkZGluZzogMDsNCn0NCg0KLyogLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0gWyBHZW5lcmFsIEVsZW1lbnRzIF0gKi8NCg0KYm9keSB7DQoJZm9u
dC1mYW1pbHk6IEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmOw0KCWZvbnQtc2l6ZTogNjIuNSU7
DQoJYmFja2dyb3VuZDogI2VlZTsNCgljb2xvcjogIzExMTsNCn0NCg0KaHIgew0KCWRpc3BsYXk6
IG5vbmU7DQp9DQoNCmltZyB7DQoJdmVydGljYWwtYWxpZ246IG1pZGRsZTsNCglib3JkZXI6IDA7
DQp9DQoNCmgxLCBoMiwgaDMsIGg0IHsNCglwYWRkaW5nLWxlZnQ6IDhweDsNCglwYWRkaW5nLXJp
Z2h0OiA4cHg7DQoJY29sb3I6ICMwMDA7DQp9DQoNCmgxIHsNCgltYXJnaW4tYm90dG9tOiAuM2Vt
Ow0KCWZvbnQtc2l6ZTogMi44ZW07DQoJbGluZS1oZWlnaHQ6IC45NWVtOw0KfQ0KDQpoMiB7DQoJ
bWFyZ2luLWJvdHRvbTogMC4zZW07DQoJZm9udC1zaXplOiAxLjhlbTsNCglsaW5lLWhlaWdodDog
MS4zOw0KfQ0KDQpoMyB7DQoJbWFyZ2luLWJvdHRvbTogMC4zZW07DQoJZm9udC1zaXplOiAxLjhl
bTsNCglsaW5lLWhlaWdodDogMS4zOw0KfQ0KDQpoNCB7DQoJbWFyZ2luLWJvdHRvbTogLjNlbTsN
Cglmb250LXNpemU6IDEuM2VtOw0KCWxpbmUtaGVpZ2h0OiAxLjY7DQp9DQoNCmg1IHsNCgltYXJn
aW4tYm90dG9tOiAwLjNlbTsNCglmb250LXNpemU6IDEuMmVtOw0KCWxpbmUtaGVpZ2h0OiAxLjY7
DQp9DQoNCnAgew0KCW1hcmdpbi1ib3R0b206IDFlbTsNCglwYWRkaW5nLWxlZnQ6IDhweDsNCglw
YWRkaW5nLXJpZ2h0OiA4cHg7DQoJZm9udC1zaXplOiAxLjJlbTsNCglsaW5lLWhlaWdodDogMS42
Ow0KfQ0KDQphIHsNCgl0ZXh0LWRlY29yYXRpb246IG5vbmU7DQoJZm9udC13ZWlnaHQ6IGJvbGQ7
DQoJY29sb3I6ICMwMDA7DQp9DQoNCmE6aG92ZXIgew0KCWNvbG9yOiAjMEY4M0RCOw0KfQ0KDQph
Y3JvbnltIHsNCglib3JkZXItYm90dG9tOiAxcHggZG90dGVkICNlZWU7DQp9DQoNCmtiZCB7DQoJ
Zm9udC1mYW1pbHk6ICJNb25hY28iLCAiQ291cmllciBOZXciLCBmaXhlZDsNCglmb250LXNpemU6
IDFlbTsNCgl0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlOw0KfQ0KDQovKiAtLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBbIFdyYXBwZXIgXSAqLw0KDQojd3JhcHBlciB7
DQoJd2lkdGg6IDkwZW07DQoJbWFyZ2luOiAwIGF1dG87DQoJbWFyZ2luLXRvcDogNGVtOw0KCW1h
cmdpbi1ib3R0b206IDFlbTsNCglvdmVyZmxvdzogaGlkZGVuOw0KCWJvcmRlcjogMXB4IHNvbGlk
IGJsYWNrOw0KCWJhY2tncm91bmQ6IHdoaXRlOw0KfQ0KDQovKiAtLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tIFsgTWFpbiBOYXYgXSAqLw0KDQojbWFpbi1uYXYgew0KCXBh
ZGRpbmc6IC41ZW07DQoJb3ZlcmZsb3c6IGhpZGRlbjsNCgliYWNrZ3JvdW5kOiAjYTQxZjAwOw0K
fQ0KDQojbWFpbi1uYXYgdWwgew0KCWxpc3Qtc3R5bGUtdHlwZTogbm9uZTsNCn0NCg0KI21haW4t
bmF2IGxpLnBhZ2VfaXRlbSB7DQoJbWFyZ2luLXJpZ2h0OiAyLjJlbTsNCglmbG9hdDogbGVmdDsN
Cn0NCg0KI21haW4tbmF2IGxpIGEgew0KCWZvbnQtc2l6ZTogMS4yZW07DQoJbGluZS1oZWlnaHQ6
IDEuNjsNCglwYWRkaW5nLWxlZnQ6IDhweDsNCgljb2xvcjogd2hpdGU7DQp9DQoNCi8qIC0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBbIEhlYWRlciBdICovDQoNCiNo
ZWFkZXIgew0KCWhlaWdodDogMTBlbTsNCglib3JkZXItdG9wOiAxcHggc29saWQgIzMzMzsNCglv
dmVyZmxvdzogaGlkZGVuOw0KfQ0KDQojaGVhZGVyIGgxIHsNCgltYXJnaW4tdG9wOiAuNDVlbTsN
Cn0NCg0KI2hlYWRlciBoMSBhLCAjaGVhZGVyIGgyIHsNCgljb2xvcjogIzAwMDsNCn0NCg0KLyog
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFsgQ29udGVudCBdICov
DQoNCiNjb250ZW50IHsNCglwYWRkaW5nLXRvcDogMWVtOw0KCW92ZXJmbG93OiBoaWRkZW47DQp9
DQoNCnVsLm5hdiB7DQoJbWFyZ2luOiAwIDAgMmVtIDA7DQoJbGlzdC1zdHlsZS10eXBlOiBub25l
Ow0KfQ0KDQoubmF2IGxpIHsNCgltYXJnaW46IDA7DQoJcGFkZGluZzogLjRlbSA4cHggLjVlbSA4
cHg7DQoJZm9udC1zaXplOiAxLjJlbTsNCglsaW5lLWhlaWdodDogMS42Ow0KCWJvcmRlci1ib3R0
b206IDFweCBzb2xpZCAjYmJiOw0KfQ0KDQoubmF2IGxpLmxhc3Qgew0KCWJvcmRlci1ib3R0b206
IDA7DQp9DQoNCnVsLm5hdmxpbmtzIHsNCglwb3NpdGlvbjogYWJzb2x1dGU7DQoJdG9wOiAzNi40
ZW07DQoJbGlzdC1zdHlsZS10eXBlOiBub25lOw0KCW92ZXJmbG93OiBoaWRkZW47DQp9DQoNCi5u
YXZsaW5rcyBsaSB7DQoJZm9udC1zaXplOiAxLjJlbTsNCglsaW5lLWhlaWdodDogMS42Ow0KfQ0K
DQoubmF2bGlua3MgbGkgYSB7DQoJZGlzcGxheTogYmxvY2s7DQoJcGFkZGluZzogLjRlbSA4cHgg
LjVlbSA4cHg7DQp9DQoNCi5uYXZsaW5rcyBsaSBhOmhvdmVyIHsNCgliYWNrZ3JvdW5kOiAjMDAw
Ow0KCWNvbG9yOiAjZmZmOw0KfQ0KDQovKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLSBbIFBvc3QgXSAqLw0KDQoucG9zdCB7DQoJcGFkZGluZzogMWVtIDAgMmVt
IDA7DQoJYm9yZGVyLXRvcDogMXB4IHNvbGlkICNiYmI7DQoJb3ZlcmZsb3c6IGhpZGRlbjsNCglj
bGVhcjogYm90aDsNCn0NCg0KLnBvc3QtY29udGVudCBwLCAucG9zdC1jb250ZW50IGg1LCAucG9z
dC1jb250ZW50IGNvZGUgew0KCXdpZHRoOiA1NS43ZW07DQogICAgbWFyZ2luOiAwcHg7DQp9DQoN
Ci5wb3N0LWNvbnRlbnQgaDMgew0KCWxpbmUtaGVpZ2h0OiAuOTsNCn0NCg0KLnBvc3QtY29udGVu
dCBoNSB7DQoJbWFyZ2luLXRvcDogMi41ZW07DQoJbWFyZ2luLWJvdHRvbTogLjVlbTsNCglwYWRk
aW5nLWxlZnQ6IDhweDsNCglwYWRkaW5nLXJpZ2h0OiA4cHg7DQoJdGV4dC10cmFuc2Zvcm06IHVw
cGVyY2FzZTsNCn0NCg0KLnBvc3QtY29udGVudCBibG9ja3F1b3RlIHsNCgltYXJnaW46IDAgMy4y
ZW0gMCAzLjJlbTsNCn0NCg0KLnBvc3QtY29udGVudCBibG9ja3F1b3RlIHAgew0KCXdpZHRoOiAz
MGVtOw0KCXBhZGRpbmc6IDA7DQp9DQoNCi5wb3N0LWNvbnRlbnQgYmxvY2txdW90ZSB1bCB7DQoJ
d2lkdGg6IDMwZW07DQp9DQoNCi5wb3N0LWNvbnRlbnQgZGwgew0KCW1hcmdpbjogMCAwIDFlbSAw
Ow0KCXBhZGRpbmctbGVmdDogOHB4Ow0KCXBhZGRpbmctcmlnaHQ6IDhweDsNCglmb250LXNpemU6
IDEuMmVtOw0KfQ0KDQoucG9zdC1jb250ZW50IGR0IHsNCgltYXJnaW46IDAgMCAuNWVtIDA7DQoJ
Zm9udC13ZWlnaHQ6IGJvbGQ7DQoJZm9udC1zaXplOiAxZW07DQp9DQoNCi5wb3N0LWNvbnRlbnQg
ZGQgew0KCXdpZHRoOiAzMGVtOw0KCW1hcmdpbjogMCAwIDFlbSAyZW07DQoJbGluZS1oZWlnaHQ6
IDEuNjsNCn0NCg0KLnBvc3QtY29udGVudCB1bCwgLnBvc3QtY29udGVudCBvbCB7DQoJbWFyZ2lu
LWxlZnQ6IC0xMnB4Ow0KCXBhZGRpbmctcmlnaHQ6IDhweDsNCglsaXN0LXN0eWxlLXR5cGU6IG5v
bmU7DQp9DQoNCi5wb3N0LWNvbnRlbnQgbGkgew0KCW1hcmdpbjogMCAwIDAuNWVtIDA7DQoJcGFk
ZGluZy1sZWZ0OiAyMHB4Ow0KCWZvbnQtc2l6ZTogMS4yZW07DQoJbGluZS1oZWlnaHQ6IDEuNjsN
Cn0NCg0KLnBvc3QtY29udGVudCBvbCB7DQoJbWFyZ2luLWxlZnQ6IDhweCAhaW1wb3J0YW50Ow0K
fQ0KDQoucG9zdC1jb250ZW50IG9sIGxpIHsNCglwYWRkaW5nLWxlZnQ6IDA7DQoJbGlzdC1zdHls
ZS10eXBlOiBkZWNpbWFsOw0KCWJhY2tncm91bmQ6IG5vbmU7DQp9DQoNCi5wb3N0LWNvbnRlbnQg
Y29kZSB7DQoJZm9udC1mYW1pbHk6ICJNb25hY28iLCAiQ291cmllciBOZXciLCBmaXhlZDsNCglm
b250LXNpemU6IC45ZW07DQp9DQoNCi5wb3N0LWNvbnRlbnQgcHJlIHsNCgltYXJnaW46IDJlbSAw
IDJlbSAwOw0KCXBhZGRpbmc6IDJlbTsNCglmb250LXNpemU6IDEuMmVtOw0KCWJhY2tncm91bmQ6
ICNlZWU7DQoJb3ZlcmZsb3c6IGF1dG87DQp9DQoNCi5wb3N0LWNvbnRlbnQgcHJlIGNvZGUgew0K
CWNvbG9yOiAjMjIyOw0KfQ0KDQoucG9zdC1jb250ZW50IC5xdW90ZS1hdXRob3Igew0KCWZsb2F0
OiByaWdodDsNCn0NCg0KLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0g
WyBDb21tZW50YXJ5IF0gKi8NCg0KI2NvbW1lbnRhcnkgew0KCWJvcmRlci10b3A6IDFweCBzb2xp
ZCAjMTExOw0KCXBhZGRpbmc6IDFlbSAwIDAgMDsNCglvdmVyZmxvdzogaGlkZGVuOw0KCWNsZWFy
OiBib3RoOw0KfQ0KDQouY29tbWVudCB7DQoJbWFyZ2luOiAwIDAgM2VtIDA7DQoJcGFkZGluZzog
MWVtIDAgMCAwOw0KCWJvcmRlci10b3A6IDFweCBkb3R0ZWQgI2JiYjsNCgljbGVhcjogYm90aDsN
CglvdmVyZmxvdzogaGlkZGVuOw0KfQ0KDQouY29tbWVudCBkdCB7DQoJbWFyZ2luOiAwIDAgLjVl
bSAwOw0KCWZvbnQtc2l6ZTogMS4yZW07DQoJbGluZS1oZWlnaHQ6IDEuNjsNCn0NCg0KI2xlYXZl
LWNvbW1lbnQgew0KCWJvcmRlci10b3A6IDFweCBzb2xpZCAjMTExOw0KCXBhZGRpbmc6IDEuMmVt
IDAgMCAwOw0KCW92ZXJmbG93OiBoaWRkZW47DQoJY2xlYXI6IGJvdGg7CQ0KfQ0KDQojbGVhdmUt
Y29tbWVudCBjb2RlIHsNCglmb250LWZhbWlseTogIk1vbmFjbyIsICJDb3VyaWVyIE5ldyIsIGZp
eGVkOw0KCWZvbnQtc2l6ZTogLjllbTsNCn0NCg0KLmNvbW1lbnQtZmllbGQgew0KCXBhZGRpbmct
dG9wOiAxLjJlbTsNCglwYWRkaW5nLWJvdHRvbTogMS4yZW07DQoJYm9yZGVyLWJvdHRvbTogMXB4
IGRvdHRlZCAjYmJiOw0KCWNsZWFyOiBib3RoOw0KCW92ZXJmbG93OiBoaWRkZW47CQ0KfQ0KDQps
YWJlbCB7DQoJZGlzcGxheTogYmxvY2s7DQoJcGFkZGluZy10b3A6IDdweDsNCglmb250LXNpemU6
IDEuMmVtOw0KCWxpbmUtaGVpZ2h0OiAxLjY7DQoJZm9udC13ZWlnaHQ6IGJvbGQ7DQp9DQoNCmlu
cHV0LCB0ZXh0YXJlYSB7DQoJd2lkdGg6IDk0JTsNCglwYWRkaW5nOiA4cHg7DQoJZm9udC1mYW1p
bHk6IEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmOw0KCWZvbnQtc2l6ZTogMS4yZW07DQoJYm9y
ZGVyOiAxcHggc29saWQgI2NjYzsNCn0NCg0KdGV4dGFyZWEgew0KCWhlaWdodDogMTBlbTsNCn0N
Cg0KLnNlY3Rpb24gew0KCW1hcmdpbjogMCAwIDFlbSAwOw0KCWNsZWFyOiBib3RoOw0KCW92ZXJm
bG93OiBoaWRkZW47DQp9DQoNCi5zZWN0aW9uIC5jb2wgew0KCW92ZXJmbG93OiBoaWRkZW47DQp9
DQoNCiNjb250ZW50IC5zZWN0aW9uIHsNCgltYXJnaW46IDAgMCAyZW0gMDsNCglwYWRkaW5nOiAx
ZW0gMCAwIDA7DQoJYm9yZGVyLXRvcDogMXB4IGRvdHRlZCAjYmJiOw0KfQ0KDQojY29udGVudCAu
Zmlyc3Qgew0KCWJvcmRlcjogMDsNCn0NCg0KLnN1Ym1pdCB7DQoJd2lkdGg6IGF1dG87DQoJcGFk
ZGluZzogMDsNCglib3JkZXI6IDA7DQp9DQoNCi5uYXZpZ2F0aW9uIHsNCgltYXJnaW46IDAgMCAx
ZW0gMDsNCglwYWRkaW5nOiAxZW0gMCAwIDA7DQoJbGlzdC1zdHlsZS10eXBlOiBub25lOw0KCW92
ZXJmbG93OiBoaWRkZW47DQoJY2xlYXI6IGJvdGg7DQp9DQoNCi5uYXZpZ2F0aW9uIGxpIHsNCglm
b250LXNpemU6IDEuMmVtOw0KfQ0KDQovKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0gWyBGb290bm90ZXMgXSAqLw0KDQojZm9vdG5vdGVzIHsNCglib3JkZXItdG9wOiAx
cHggc29saWQgIzMzMzsNCglwYWRkaW5nOiAxZW0gMCAwIDA7DQoJb3ZlcmZsb3c6IGhpZGRlbjsN
CgljbGVhcjogYm90aDsNCn0NCg0KI2Zvb3Rub3RlcyBwIHsNCgltYXJnaW4tYm90dG9tOiAuMmVt
Ow0KCWZvbnQtc2l6ZTogMS4xZW07DQp9DQoNCiNmb290bm90ZXMgLnJzcyB7DQoJbWFyZ2luLWxl
ZnQ6IDhweDsNCglwYWRkaW5nLWxlZnQ6IDE2cHg7DQp9DQoNCi8qIC0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLSBbIEdlbmVyYWwgQ2xhc3NlcyBdICovDQoNCi5zbWFsbCB7DQoJZm9u
dC1zaXplOiAxZW07DQoJbGluZS1oZWlnaHQ6IDEuNjsNCn0NCg0KLyogSWYgeW91IHdhbnQgYSB0
ZXh0IGluIEFMTCBDQVBTICovDQoNCi52ZXIgew0KCXRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7
DQp9DQoNCi5yb3doZHIgew0KCWNvbG9yOiB3aGl0ZTsNCglmb250LXdlaWdodDogYm9sZDsNCgli
YWNrZ3JvdW5kOiAjMDU4ZkNGOw0KCXBhZGRpbmc6IDVweCAxMHB4IDVweCAyMHB4Ow0KCWZvbnQt
c2l6ZTogMS41ZW07DQp9DQoNCi5zdWJzZWN0aXRsZSB7DQoJcGFkZGluZzogNXB4IDE1cHggNXB4
IDE1cHg7DQoJbWFyZ2luLWxlZnQ6IC0xMHB4Ow0KCWZvbnQtd2VpZ2h0OiBib2xkOw0KCWZvbnQt
c2l6ZTogMmVtOw0KfQ0KDQovKiBGb3IgYnktbGluZXMgKi8NCg0KLmxvdyB7DQoJZm9udC1mYW1p
bHk6IFBhbGF0aW5vLCBHZW9yZ2lhLCAiVGltZXMgTmV3IFJvbWFuIiwgc2Fucy1zZXJpZjsNCglm
b250LXN0eWxlOiBpdGFsaWM7DQoJZm9udC13ZWlnaHQ6IG5vcm1hbDsNCgl0ZXh0LXRyYW5zZm9y
bTogbG93ZXJjYXNlOw0KCWNvbG9yOiAjNjY2Ow0KfQ0KDQovKiBBIG5pY2UgYW1wZXJzYW5kICov
DQoNCi5hbXAgew0KCWZvbnQtZmFtaWx5OiBCYXNrZXJ2aWxsZSwgR2VvcmdpYSwgIlRpbWVzIE5l
dyBSb21hbiIsIHNhbnMtc2VyaWY7DQoJZm9udC1zdHlsZTogaXRhbGljOw0KCWZvbnQtd2VpZ2h0
OiBub3JtYWw7DQoJY29sb3I6ICM2NjY7DQp9DQoNCi8qIEZvciBpbWFnZSBjYXB0aW9ucyAqLw0K
DQoudG9vbHRpcCB7DQoJZGlzcGxheTogYmxvY2s7DQoJcGFkZGluZy10b3A6IDhweDsNCglmb250
LXNpemU6IC45ZW07DQp9DQoNCi5sZWZ0IHsNCglmbG9hdDogbGVmdDsNCn0NCg0KLnJpZ2h0IHsN
CglmbG9hdDogcmlnaHQ7DQp9DQoNCi5hbGlnbi1yaWdodCB7DQoJZGlzcGxheTogYmxvY2s7DQoJ
dGV4dC1hbGlnbjogcmlnaHQ7DQp9DQoNCi5hbGlnbi1jZW50ZXIgew0KCWRpc3BsYXk6IGJsb2Nr
Ow0KCXRleHQtYWxpZ246IGNlbnRlcjsNCn0NCg0KLmJvdGggew0KCWNsZWFyOiBib3RoOw0KfQ0K
DQouaW1hZ2Ugew0KCWJhY2tncm91bmQtY29sb3I6ICNmOWY5Zjk7DQoJYm9yZGVyOiAxcHggc29s
aWQgI2VlZTsNCglib3JkZXItYm90dG9tOiAxcHggc29saWQgI2VlZTsNCglkaXNwbGF5OiBibG9j
azsNCglwYWRkaW5nOiA3cHg7DQp9DQoNCi5udWRnZWQgew0KCW1hcmdpbi1yaWdodDogOHB4Ow0K
fQ0KDQoubnVkZ2VkLWxlZnQgew0KCXBhZGRpbmctbGVmdDogOHB4Ow0KfQ0KDQoubnVkZ2UtYm90
dG9tIHsNCgltYXJnaW4tYm90dG9tOiAxLjVlbTsNCn0NCg0KLmxhc3QtZmllbGQsIC5maXJzdC1w
b3N0IHsNCglib3JkZXI6IDA7DQp9DQoNCi50aXRsZS1ub3Qgew0KCXdpZHRoOiAzM3B4Ow0KCWhl
aWdodDogMjVweDsNCgltYXJnaW46IDAgNnB4IDAgMDsNCglkaXNwbGF5OiBibG9jazsNCgl0ZXh0
LWluZGVudDogLTEwMDBlbTsNCglmbG9hdDogbGVmdDsNCn0NCg0KLnNlYXJjaC1maWVsZCB7DQoJ
cGFkZGluZzogMDsNCn0NCg0KLyogVXNlIGZvciBmdWxsIHdpZHRoIGltYWdlcyAoNTk2cHgpICov
DQoNCi5mdWxsLWltYWdlIHsNCgltYXJnaW4tbGVmdDogLTE1LjJlbTsNCn0NCg0KLyogQ2VudGVy
aW5nIGZvciBvbGRlciBwb3N0cyAqLyANCg0KLmNlbnRlcmVkIHsNCglkaXNwbGF5OiBibG9jazsN
CgltYXJnaW46IDAgYXV0bzsNCn0NCi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LSBbIFZBRGVidWcgZXh0ZW5zaW9ucyBdICovDQouZXJyb3Igew0KICAgIGJvcmRlcjogMXB4IHNv
bGlkICNDMDA7DQogICAgYmFja2dyb3VuZDogI0ZGNDUwMDsNCn0NCi53YXJuIHsNCiAgICBib3Jk
ZXI6IDFweCBzb2xpZCAjRTZEQjU1Ow0KICAgIGJhY2tncm91bmQ6ICNGRkZCQkM7DQp9DQouaW5m
byB7DQogICAgYmFja2dyb3VuZDogI0VFRTsNCiAgICBib3JkZXI6IDFweCBzb2xpZCAjQ0NDOw0K
fQ0KLmxpc3ROYXYgeyBtYXJnaW46MCAwIDEwcHg7IHBvc2l0aW9uOiByZWxhdGl2ZTsgcGFkZGlu
Zy10b3A6IDE1cHg7fQ0KLmxuLWxldHRlcnMgeyBvdmVyZmxvdzpoaWRkZW47IH0NCi5sbi1sZXR0
ZXJzIGEgeyBmb250LXNpemU6MC45ZW07IGRpc3BsYXk6YmxvY2s7IGZsb2F0OmxlZnQ7IHBhZGRp
bmc6MnB4IDZweDsgYm9yZGVyOjFweCBzb2xpZCBzaWx2ZXI7IGJvcmRlci1yaWdodDpub25lOyB0
ZXh0LWRlY29yYXRpb246bm9uZTsgfQ0KLmxuLWxldHRlcnMgYS5sbi1sYXN0IHsgYm9yZGVyLXJp
Z2h0OjFweCBzb2xpZCBzaWx2ZXI7IH0NCi5sbi1sZXR0ZXJzIGE6aG92ZXIsDQoubG4tbGV0dGVy
cyBhLmxuLXNlbGVjdGVkIHsgYmFja2dyb3VuZC1jb2xvcjojZWFlYWVhOyB9DQoubG4tbGV0dGVy
cyBhLmxuLWRpc2FibGVkIHsgY29sb3I6I2NjYzsgfQ0KLmxuLWxldHRlci1jb3VudCB7IHRleHQt
YWxpZ246Y2VudGVyOyBmb250LXNpemU6MS4wZW07IGxpbmUtaGVpZ2h0OjE7IG1hcmdpbi1ib3R0
b206M3B4OyBjb2xvcjojMzM2Njk5OyB9DQoJPC9zdHlsZT4NCgk8IS0tW2lmIElFIDZdPg0KCQk8
c3R5bGUgbWVkaWE9InNjcmVlbiI+DQoJCWgxe2xpbmUtaGVpZ2h0OjFlbX11bC5uYXZsaW5rc3t6
b29tOjF9aW5wdXQsdGV4dGFyZWF7d2lkdGg6ODklfS5uYXZsaW5rcyBsaXtmb250LXNpemU6MS4z
ZW19LmNvbW1lbnQtZmllbGR7em9vbToxfS5wb3N0e3pvb206MX0ucG9zdC1tZXRhe3pvb206MX0u
cG9zdC1jb250ZW50e3dpZHRoOjQzLjZlbSAhaW1wb3J0YW50O3BhZGRpbmctbGVmdDowcHh9LmZ1
bGwtaW1hZ2V7bWFyZ2luOjA7d2lkdGg6NDM4cHggIWltcG9ydGFudDtvdmVyZmxvdzpoaWRkZW59
LnBvc3QtY29udGVudCBwLC5wb3N0LWNvbnRlbnQgaDUsLnBvc3QtY29udGVudCBjb2Rle3dpZHRo
OmF1dG99LnBvc3QtY29udGVudCB1bCwucG9zdC1jb250ZW50IG9se3dpZHRoOmF1dG99LnN1Ym1p
dHt3aWR0aDoxMDAlfS5jb21tZW50e3pvb206MX0jc2lkZWJhcnttYXJnaW4tcmlnaHQ6LTNweH0j
Zm9vdG5vdGVze21hcmdpbi1yaWdodDotM3B4fQ0KCQk8L3N0eWxlPg0KCTwhW2VuZGlmXS0tPiAN
CjwvaGVhZD4gDQogDQo8Ym9keT4gDQoJPGRpdiBpZD0id3JhcHBlciI+IA0KCQk8ZGl2IGlkPSJt
YWluLW5hdiIgY2xhc3M9ImNvbCBzcGFuLTEyIj4gDQoJCQk8dWw+IA0KCQkJCUBATkFWQEANCgkJ
CTwvdWw+CQkJDQoJCTwvZGl2PgkJDQoJCQ0KCQk8ZGl2IGlkPSJoZWFkZXIiIGNsYXNzPSJjb2wg
bGFzdCBzcGFuLTEyIj4gDQoJCQk8aDE+VkEgRGVidWcgUmVwb3J0PC9oMT4NCgkJCTxoMj48c3Bh
biBjbGFzcz0ibG93Ij5AQFRJTUVAQDwvc3Bhbj48L2gyPiANCgkJPC9kaXY+IA0KIA0KCQk8aHIg
Lz4gDQogDQoJPGRpdiBpZD0iY29udGVudCIgY2xhc3M9ImNvbCBzcGFuLTEyIj4NCgkJQEBDT05U
RU5UQEANCjwhLS0gU0VDVElPTl9CTE9DSw0KCTxkaXYgY2xhc3M9ImNvbCByb3doZHIiPg0KCQk8
YSBuYW1lPSJAQFNFQ1RJT05USVRMRUBAIj48L2E+DQoJCTxzcGFuIGNsYXNzPSIiPkBAU0VDVElP
TlRJVExFQEA8c3Bhbj4NCgk8L2Rpdj4gDQpTRUNUSU9OX0JMT0NLIC0tPgkJDQo8IS0tIEVOVFJZ
X0JMT0NLDQoJCTxkaXYgY2xhc3M9InBvc3QiPiANCgkJCTxkaXYgY2xhc3M9InBvc3QtbWV0YSBj
b2wgc3Bhbi0yIj4NCgkJCQk8cCBjbGFzcz0idmVyIHN1YnNlY3RpdGxlIj5AQEVOVFJZVElUTEVA
QDwvcD4NCgkJCQk8dWwgY2xhc3M9Im5hdiI+DQoJCQkJCUBARU5UUllNRVRBQEANCgkJCQk8L3Vs
PiANCgkJCTwvZGl2PiANCg0KCQkJPGRpdiBjbGFzcz0icG9zdC1jb250ZW50IHNwYW4tOCBudWRn
ZS0yIj4gDQoJCQkJQEBFTlRSWUNPTlRFTlRAQA0KCQkJPC9kaXY+IA0KCQk8L2Rpdj4NCkVOVFJZ
X0JMT0NLIC0tPg0KCQkNCjwhLS0gUG9zdGluZyBmdWxsIGltYWdlcyANCjxkaXYgY2xhc3M9ImZ1
bGwtaW1hZ2UiPiANCjxwPjxzbWFsbCBjbGFzcz0idG9vbHRpcCI+PGVtPkNoYXJseSBHYXJj7WEg
YW5kIHRoZSBNb2Rlcm4gQ2xpeC48L2VtPjwvc21hbGw+PC9wPiANCjwvZGl2Pg0KCQ0KCTxjb2Rl
PkJMT0NLUVVPVEU8L2NvZGU+DQoNCgk8YmxvY2txdW90ZT48cD48YSBocmVmPSJodHRwOi8vd3d3
LnRoZWdyaWRzeXN0ZW0ub3JnLyI+VGhlIEdyaWQgU3lzdGVtPC9hPiBpcyBhIG5ldyBzaWRlIHBy
b2plY3Qgb2YgQW50b25pbyBDYXJ1c29uZSwgZmVhdHVyaW5nIGFsbCB0aGluZ3MgZGVhbGluZyB3
aXRoLCB3ZWxsLCB0eXBvZ3JhcGhpYyBncmlkcy4gRXhjZWxsZW50IHJlc291cmNlLjwvcD4gDQo8
L2Jsb2NrcXVvdGU+IA0KDQo8ZGw+IA0KPGR0PldvcmRQcmVzczwvZHQ+IA0KPGRkPldvcmRQcmVz
cyBpcyBhbiBvcGVuIHNvdXJjZSBibG9nIHB1Ymxpc2hpbmcgYXBwbGljYXRpb24uIEl0IGlzIHRo
ZSBvZmZpY2lhbCBzdWNjZXNzb3Igb2YgYjJcY2FmZWxvZywgZGV2ZWxvcGVkIGJ5IE1pY2hlbCBW
YWxkcmlnaGkuIFRoZSBuYW1lIFdvcmRQcmVzcyB3YXMgc3VnZ2VzdGVkIGJ5IENocmlzdGluZSBT
ZWxsZWNrLCBhIGZyaWVuZCBvZiBsZWFkIGRldmVsb3BlciBNYXR0IE11bGxlbndlZy48L2RkPiAN
CjxkdD5NT0R4PC9kdD4gDQo8ZGQ+TU9EeCBpcyBhIGZyZWUsIG9wZW4gc291cmNlIGNvbnRlbnQg
bWFuYWdlbWVudCBzeXN0ZW0gYW5kIGFwcGxpY2F0aW9uIGZyYW1ld29yayBmb3IgcHVibGlzaGlu
ZyBjb250ZW50IG9uIHRoZSB3b3JsZCB3aWRlIHdlYiBhbmQgaW50cmFuZXRzLiBNT0R4IGlzIGxp
Y2Vuc2VkIHVuZGVyIHRoZSBHUEwuPC9kZD4gDQo8L2RsPiANCi0tPgkJCQ0KCTwvZGl2PgkJDQoJ
PGhyIC8+IA0KIA0KIDxkaXYgaWQ9ImZvb3Rub3RlcyIgY2xhc3M9ImNvbCI+IA0KCQk8cD5WQURl
YnVnIEBAVkVSU0lPTkBALiBDb3B5cmlnaHQgJmNvcHk7IDIwMTEuIEFsbCByaWdodHMgcmVzZXJ2
ZWQuIDxhIGhyZWY9Imh0dHA6Ly93d3cucml2ZXJiZWQuY29tIj5SaXZlcmJlZCBUZWNobm9sb2d5
LCBJbmMuPC9hPi48L3A+IA0KCTwvZGl2Pg0KPC9ib2R5PiANCjwvaHRtbD4=
"""
# -*- python -*-
#
# (C) Copyright 2003-2009 Riverbed Technology, Inc.  
# All rights reserved. Confidential.
#
# ------------ graph_stats ------------------------
def get_stat_for_graphing(is_core, statname, idx1 = 0, idx2 = -1):
    global _all_core_stat_descriptors
    global _all_edge_stat_descriptors
    global _corestats
    global _edgestats
    global _debug
    times = []
    values = []
    if (_debug & 16384) != 0:
        message = "False"
        if is_core:
            message = "True"
        print "get_stat_for_graphing(%s, %s, %d, %d)" % ( message, statname, idx1, idx2 )
    if is_core:
        descriptors = _all_core_stat_descriptors
        stat_len = len(_corestats)
    else:
        descriptors = _all_edge_stat_descriptors
        stat_len = len(_edgestats)
    descriptor = find_descriptor_full_path(descriptors, statname)
    if descriptor == None:
        if (_debug & 16384) != 0:
            print "Descriptor not found: Skipping:", statname
        return times, values
    else:
        stat_type = abs(descriptor[4])
        if (_debug & 16384) != 0:
            print "Descriptor found:", statname, stat_type
        if stat_type == BKT:
            statname += "/average"
            stat_type = FLOAT
        elif stat_type not in [ INT, FLOAT ]:
            if (_debug & 16384) != 0:
                print "Wrong type: Skipping:", statname
            return times, values
    if idx1 < 0:
        idx1 += stat_len
    if idx2 < 0:
        idx2 += stat_len
    for idx in range(idx1, idx2 + 1):
        if is_core:
            stat = get_core_stat(statname, stat_type, idx, True)
            time = list_get_or_default(_corestats, idx)
        else:
            stat = get_edge_stat(statname, stat_type, idx, True)
            time = list_get_or_default(_edgestats, idx)
        if time:
            time = list_get_or_default(time, 3) # datetime
        if (stat == None) or (time == None):
            continue
        values.append(stat)
        times.append(time)
    return times, values

#------------------------------------------------------------------------------
def statname_to_basename(statname):
    basename = statname.replace('/', '-')
    basename = basename.replace(" ", "")
    if len(basename) == 0:
        return None
    if basename[0:1] == '-':
        basename = basename[1:]
    if len(basename) == 0:
        return None
    return basename

#------------------------------------------------------------------------------
def statname_to_short_name(statname):
    slash_index = statname.rfind("/")
    stat_short_name = statname[slash_index + 1:]
    return stat_short_name

#------------------------------------------------------------------------------
def graph_one_stat(statname, times, values, deploy_path = ""):
    global _debug
    if (_debug & 16384) != 0:
        print "graph_one_stat", statname, times, values
    max_len = max(len(values), len(times))
    if max_len == 0:
        return None
    basename = statname_to_basename(statname)
    if basename == None:
        return None
    filename = "%s.csv" % basename
    csv_path = os.path.join(deploy_path, "csv")
    pathname = os.path.join(csv_path, filename)
    fd = open(pathname, "w")
    if fd == None:
        print "ERROR: Cannot open: ", pathname
        return None
    if (_debug & 16384) != 0:
        print "Writing to file:", pathname
    # Write heading
    stat_short_name = statname_to_short_name(statname)
    fd.write('time, %s\n' % statname)
#    fd.write('time, %s\n' % basename)
#    fd.write('time, %s\n' % stat_short_name)
    # Write each row
    for idx in range(0, max_len):
        time = times[idx]
        if (_debug & 16384) != 0:
            print "[%d]" % idx, times[idx], "->", values[idx]
        fd.write("%s, %s\n" % ( str(time), str(values[idx]) ))
    fd.close()
    return pathname

#------------------------------------------------------------------------------
# marble has python 2.3 which does not have sets.
def list_remove_duplicates(with_dups):
    with_dups = with_dups[:]
    with_dups.sort()
    without_dups = []
    previous_set = False
    for element in with_dups:
        if not previous_set:
            without_dups.append(element)
            previous_set = True
            previous = element
        elif element != previous:
            without_dups.append(element)
            previous = element
    return without_dups

#------------------------------------------------------------------------------
# marble has python 2.3 which does not have sets.
def list_intersect(list_a, list_b):
    list_a = list_a[:]
    list_a.sort()
    list_b = list_b[:]
    list_b.sort()
    list_both = []
    idx_a = 0
    idx_b = 0
    len_a = len(list_a)
    len_b = len(list_b)
    while (idx_a < len_a) and (idx_b < len_b):
        elem_a = list_a[idx_a]
        elem_b = list_b[idx_b]
        if elem_a == elem_b:
            list_both.append(elem_a)
            idx_a += 1
            idx_b += 1
        elif elem_a < elem_b:
            idx_a += 1
        else:
            idx_b += 1
    return list_both

#------------------------------------------------------------------------------
def graph_all_stats(all_times, all_values, deploy_path = ""):
    global _debug
    # Get times of all stats.
    combined_times = []
    for times in all_times.values():
        combined_times.extend(times)
    combined_times = list_remove_duplicates(combined_times)
    len_combined_times = len(combined_times)
    # Get names of stats in both all_values and all_times
    all_values_stats = all_values.keys()
    all_times_stats = all_times.keys()
    both_stats = list_intersect(all_values_stats, all_times_stats)
    # Get stats that have values for all times
    statnames = []
    for statname in both_stats:
        stat_times = list_remove_duplicates(all_times[statname])
        both_times = list_intersect(stat_times, combined_times)
        if len(both_times) == len_combined_times:
            statnames.append(statname)
        else:
            print "Some time values missing: Skipping:", statname
    statnames.sort()
    # Open file
    basename = "combined"
    filename = "%s.csv" % basename
    csv_path = os.path.join(deploy_path, "csv")
    pathname = os.path.join(csv_path, filename)
    fd = open(pathname, "w")
    if fd == None:
        print "ERROR: Cannot open: ", pathname
        return None
    if (_debug & 16384) != 0:
        print "Writing to file:", pathname
    # Write heading
    fd.write('time')
    for statname in statnames:
        stat_basename = statname_to_basename(statname)
        stat_short_name = statname_to_short_name(statname)
        fd.write(', %s' % statname)
#        fd.write(', %s' % stat_basename)
#        fd.write(', %s' % stat_short_name)
    fd.write("\n")
    # Write each row
    start_time = None
    for combined_idx in range(0, len_combined_times):
        time = combined_times[combined_idx]
        fd.write(str(time))
        for statname in statnames:
            stat_times = all_times[statname]
            stat_values = all_values[statname]
            stat_idx = stat_times.index(time)
            stat_value = stat_values[stat_idx]
            fd.write(", %s" % str(stat_value))
        fd.write("\n")
    fd.close()
    return pathname

#------------------------------------------------------------------------------
# 0 - CORE True, EDGE False, 1 - Directory that contains csv files, 2 - Graph output file name
def graph_stats(is_core, deploy_path = "", output_name = "stats_graphs"):
    global _graph_core_stats
    global _graph_edge_stats
    global _debug
    if is_core:
        patterns = _graph_core_stats
    else:
        patterns = _graph_edge_stats
    if (_debug & 16384) != 0:
        print "graph_stats:", "is_core", is_core, "patterns", patterns, \
              "deploy_path", deploy_path
    # Create directory deploy_path
    if not deploy_path:
        deploy_path = "."
    csv_path = os.path.join(deploy_path, "csv")
    if not os.path.isdir(csv_path):
        try:
            os.mkdir(csv_path)
        except OSError:
            pass
    if not os.path.isdir(csv_path):
        print "ERROR: Not a directory:", csv_path
        return None
    values = {}
    times = {}
    paths = []
    for stat_pattern in patterns:
        if is_core:
            statnames = get_core_stat(stat_pattern, KEYS, 0, True)
        else:
            statnames = get_edge_stat(stat_pattern, KEYS, 0, True)
        if (_debug & 16384) != 0:
            print "graph_stats:", "stat_pattern", stat_pattern, "statnames", statnames
        if statnames == None:
            print "graph_stats: No stats found for pattern:", stat_pattern
            continue
        for statname in statnames:
            if (_debug & 16384) != 0:
                print "graph_stats:", "statname", statname
            times[statname], values[statname] = get_stat_for_graphing(is_core, statname)
            if values[statname] and (len(values[statname]) > 0):
                path = graph_one_stat(statname, times[statname], values[statname], deploy_path)
                if path:
                    paths.append(path)
        path = graph_all_stats(times, values, deploy_path)
        if path:
            paths.append(path)
    if (_debug & 16384) != 0:
        print "Calling: gen_graph(deploy_path, output_name)"
    gen_graph(deploy_path, output_name)

#------------------------------------------------------------------------------
def graph_core_stats(deploy_path = "", output_name = "stats_graphs.core"):
    graph_stats(True, deploy_path, output_name)

def graph_edge_stats(deploy_path = "", output_name = "stats_graphs.edge"):
    graph_stats(False, deploy_path, output_name)
# -*- python -*-
#
# (C) Copyright 2003-2009 Riverbed Technology, Inc.
# All rights reserved. Confidential.
#
"""Generate the graphs given the directory containing csv files"""
#------------------------------------------------------------------------------
import sys, os
import re

def print_message(message):
    print "[gen-graph-html] %s" % message

#------------------------------------------------------------------------------
# List of stat groups to be separated by tabs, pages
# The csv filenames should contain their stats group

core_stats_groups = [ 'eventthread', 'HinterTable', 'hinter_bucket', 'iscsi',
                     'prefetch', 'rdiskdc', 'simpleworker', 'timerep', 'unset'
                     ]
    
edge_stats_groups = [ 'blockstore', 'disk',
                     #'eventthread', 'iscsi',
                     'rdedge', 'rdiskedge', 'timerep', 'wbc_processor' ]

stats_groups = []
stats_groups.extend(core_stats_groups)
stats_groups.extend(edge_stats_groups)
stats_groups.append('combined')

# List of ignore strings based on stat name
ignores = []

# Initialize the lists of files for each group
csv_files_grouped = {}
for group in stats_groups:
    if group == '^\d':
        csv_files_grouped['rbt_seeks'] = []
    else:
        csv_files_grouped[group] = []

#------------------------------------------------------------------------------
html_header = """<html>
<head> 
<script type="text/javascript"
   src="http://homedirs/~dknupp/lib/dygraph/dygraph-combined.js"></script> 
   </head>
   <body bgcolor="#FFFFFF">

"""

# 0 h2 - Group, 1 h3 - Statistic, 2 div id - Graph ID, 3 - Dygraph - Graph ID,
# 4 getElement - Graph ID, 5 CSV values
html_graph = """<p><hr size="1" width="1000px" align="left"></p>
<h2>%s</h2>
<h3>%s</h3>
<div id="%s" 
   style="width:1000px; height:200px; background-color:#FFFFFF;"></div>

<script type="text/javascript"> 
   %s = new Dygraph(
      document.getElementById("%s"),
      %s,
      {
         yAxisLabelWidth: 100,
         rollPeriod: 1,
         showRoller: true,
         drawPoints: true,
         connectSeparatedPoints: true,
         xlabel: 'Date/Time',
         ylabel: 'Statistic value',
         colors: ["#FF9900", "#000099", "#009900", "#CC0000"]
      }
   );
</script>

"""

html_footer = """</body>
</html>
"""

#------------------------------------------------------------------------------
# 0 - Directory that contains csv files, 1 - Graph output file name
def gen_graph(deploy_path = "", output_name = "stats_graphs"):
    global csv_files_grouped
    global ignores
    global stats_groups
    global html_header
    global html_graph
    global html_footer
    global _debug
    csv_dir = os.path.join(deploy_path, "csv")

    # Get the list of files for given directory
    print_message("Processing csv files in: '%s' producing '%s'" % (csv_dir, output_name))
    files = os.listdir(csv_dir)

    # Get the root dir for the csv files relative to the html page
    csv_match = False
    for file in files:
        file = file.rstrip()
        if (_debug & 16384) != 0:
            print_message("Processing file: '%s'" % file)
        mcsv = re.match('^(.+)\.csv$', file)

        # Is it a csv file?
        if mcsv:
            if (_debug & 16384) != 0:
                print_message("Processing csv file: '%s'" % file)
            csv_match = True
            group_match = False

            # Does the filename match any of the stats groups?
            # If so, add it to the csv file group list
            # but only if it wasn't in the ignore list
            for group in stats_groups:
                mgroup = re.search(group, mcsv.group(1))
                throw_away = False
                for ignore in ignores:
                    if re.search(ignore, mcsv.group(1)):
                        print_message("Igoring: '%s' for ignore '%s'" %
                                      ( mcsv.group(1), ignore ))
                        throw_away = True
                if mgroup and not throw_away:
                    if (_debug & 16384) != 0:
                        print_message("Append: '%s' to group '%s'" %
                                      ( mcsv.group(1), group ))
                    group_match = True
                    if group == '^\d':
                        csv_files_grouped['rbt_seeks'].append(mcsv.group(1))
                    else:
                        csv_files_grouped[group].append(mcsv.group(1))
                    break
            if not group_match:
                print_message("WARN: The csv file: '%s' did not match any groups or was in the ignore list." % file)

    if not csv_match:
        print_message("ERROR: This directory '%s' does not contain any csv files!" % csv_dir)

    #
    # Create the html
    #
    FH = open(os.path.join(deploy_path, output_name + ".html"), "w")

    FH.write(html_header)

    index = 1
    for group in csv_files_grouped.keys():
        if (_debug & 16384) != 0:
            print_message("Graphing group '%s'" % group)
        start_index = index
        for csv_file in csv_files_grouped[group]:
            csv_fd = open(os.path.join(csv_dir, csv_file + ".csv"), "r")
            csv_content = '"'
            csv_line = csv_fd.readline()
            line_no = 0
            while (csv_line != ""):
                if (_debug & 16384) != 0:
                    print "%d. After readline: '%s'" % ( line_no, csv_line )
                csv_line = csv_line.strip()
                if line_no != 0:
                    csv_line = '\\n" +\n"' + csv_line
                if (_debug & 16384) != 0:
                    print "%d. Final: '%s'" % ( line_no, csv_line )
                csv_content += csv_line
                csv_line = csv_fd.readline()
                line_no += 1
            csv_content += '"'
            csv_fd.close()
            if (_debug & 16384) != 0:
                print_message("%d. Graphing csv_file '%s' in group '%s'" %
                              ( index, csv_file, group ))
            graph_id = "g%s" % index
            FH.write(html_graph % (group, csv_file,
                                   graph_id, graph_id, graph_id, csv_content))
            index+=1
        if index != start_index:
            print_message("Graphed group '%s' %d csv files" %
                          (group, index - start_index ))

    FH.write(html_footer)
    FH.close()
# -*- python -*-
#
# (C) Copyright 2003-2009 Riverbed Technology, Inc.  
# All rights reserved. Confidential.
#
# ------------ main ------------------------
import time
#------------------------------------------------------------------------------
# Returns time as string, datetime
def get_now():
    time_stamp = datetime.datetime.now()
    # %a = Abbreviated weekday name
    # %b = Abbrevieated month name
    # %d = Day of the month
    # %H = Hour (24-hour clock)
    # %M = Minute
    # %S = Second
    # %Y = Year with century
    time_str = time_stamp.strftime("%a %b %d %H:%M:%S %Y")
    return time_str, time_stamp

def disconnect_from_core_or_edge(sock, files, msg):
    global _debug
    if (_debug & 256) != 0:
        print "disconnect_from_core_or_edge(%s, %s, %s)" % (
            str(sock), str(files), msg)
    if sock != None:
        print "Disconnecting socket from %s ..." % msg
        sock.close()
    if files != None:
        print "Disconnecting ssh from %s ..." %msg
        close_ssh(files)

def disconnect_from_core():
    global _core_sock                    # In/Out
    global _core_files                   # In/Out
    disconnect_from_core_or_edge(_core_sock, _core_files, "CORE")
    _core_sock = None
    _core_files = None

def disconnect_from_edge():
    global _edge_sock                   # In/Out
    global _edge_files                  # In/Out
    disconnect_from_core_or_edge(_edge_sock, _edge_files, "EDGE")
    _edge_sock = None
    _edge_files = None

# Get stats from IP:Port
# Returns ( statistics set, timestamp )
def get_stats_from_ip_port(ip_port, login="admin", password="",
                           command_svr_port=7980,
                           timeout=10, remove_prompt=True, msg=""):
    global _debug
    if (_debug & 256) != 0:
        print "get_stats_from_ip_port(ip_port='%s', login='%s'," \
              " command_svr_port=%d, timeout=%d, remove_prompt=%s, msg=%s)" % (
            ip_port, login, command_svr_port, timeout, remove_prompt, msg)
    global _cmd_options_set             # In
    global _save_prefix                 # In
    global CMD_OPTION_SAVE              # In
    # Fetch stats
    stat = do_cmd("rbcmd", "/stat", ip_port, login, password, command_svr_port,
                  timeout, remove_prompt, msg)
    # Save stats
    time_str, time_stamp = get_now()
    if (_cmd_options_set & CMD_OPTION_SAVE) != 0:
        lower_msg = msg.lower()
        file = _save_prefix + lower_msg + ".log"
        if save_stats_to_file(stat, file, time_str):
            print "Saved %s %s stats %s to %s" % (
                msg, ip_port, time_str, file)
    return ( stat, time_str )

# Get stats from CORE IP:Port
# Returns ( statistics set, timestamp )
def get_stats_from_core(ip_port, login="admin", password="",
                       command_svr_port=7980,
                       timeout=10, remove_prompt=True):
    global _core                         # Out
    disconnect_from_core()
    stat, time_str = get_stats_from_ip_port(ip_port, login, password,
                                            command_svr_port, timeout,
                                            remove_prompt, msg="CORE")
    _core = ip_port
    return (stat, time_str)

# Get stats from EDGE IP:Port
# Returns ( statistics set, timestamp )
def get_stats_from_edge(ip_port, login="admin", password="",
                       command_svr_port=7980,
                       timeout=10, remove_prompt=True):
    global _edge                        # Out
    disconnect_from_edge()
    stat, time_str = get_stats_from_ip_port(ip_port, login, password,
                                            command_svr_port, timeout,
                                            remove_prompt, msg="EDGE")
    _edge = ip_port
    return (stat, time_str)

#------------------------------------------------------------------------------
# Get all matching stats from file containing CORE /var/log/dc.stats
# Returns [ ( statistics set, timestamp ), ... ]
def get_stats_from_core_log(file_time):
    global _core_stats_log_file         # In/Out
    global _core                        # Out
    log_file, log_time = parse_log_file_time(file_time, _core_stats_log_file)
    stat_sets = get_stats_from_file(log_file, log_time)
    if len(stat_sets) != 0:
        _core_stats_log_file = log_file
        _core = log_time
    return stat_sets

# Get all matching stats from file containing EDGE /var/log/dc.stats
# Returns [ ( statistics set, timestamp ), ... ]
def get_stats_from_edge_log(file_time):
    global _edge_stats_log_file         # In/Out
    global _edge                        # Out
    log_file, log_time = parse_log_file_time(file_time, _edge_stats_log_file)
    stat_sets = get_stats_from_file(log_file, log_time)
    if len(stat_sets) != 0:
        _edge_stats_log_file = log_file
        _edge = log_time
    return stat_sets
        
#------------------------------------------------------------------------------
def evaluate_file(file_name):
    fd = open(file_name, "r")
    if fd == None:
        print "Warning: Could not open -x file for reading: %s" % file_name
        return
    print "Executing file: %s" % file_name
    exec fd
    fd.close()
    
#------------------------------------------------------------------------------
# Get all stats
def get_all_stats(is_core, password=""):
    global _debug
    if is_core:
        stat_options = _cores
    else:
        stat_options = _edges
    for net_file, value in stat_options:
        if net_file == 'net':
            if is_core:
                stat = get_stats_from_core(value, password=password)
            else:
                stat = get_stats_from_edge(value, password=password)
            if stat:
                stat_sets = [ stat ]
            else:
                stat_sets = [ ]
        elif net_file == 'file':
            stat_sets = get_stats_from_file(value)
        elif net_file == 'log':
            if is_core:
                stat_sets = get_stats_from_core_log(value)
            else:
                stat_sets = get_stats_from_edge_log(value)
        else:
            print "Invalid type:", net_file
            continue
        for stat in stat_sets:
            if (_debug & 256) != 0:
                print "stat:", stat[1:]
            timestamp = stat[1]
            if timestamp == None:
                timestamp, datetime_stamp = get_now()
            else:
                # Equivalent to datetime_stamp = datetime.strptime(timestamp, format)
                datetime_stamp = datetime.datetime(*(time.strptime(
                    timestamp, "%a %b %d %H:%M:%S %Y")[0:6]))
            if (_debug & 256) != 0:
                print "timestamp", timestamp
            stat = stat[0]
            if stat == None:
                continue
            lines = stat.splitlines()
            lines_with_use_count = []
            for one_line in lines:
                one_line = one_line.rstrip(" \t\n\r")
                # Skip short lines
                if len(one_line) < 1:
                    continue
                lines_with_use_count.append([ one_line, 0 ])
            if is_core:
                append_to_stats(_corestats,
                                (lines_with_use_count, value,
                                 timestamp, datetime_stamp), "CORE")
            else:
                append_to_stats(_edgestats,
                                (lines_with_use_count, value,
                                 timestamp, datetime_stamp), "EDGE")

#------------------------------------------------------------------------------
_cores = []                             # -c/-C options
_core_sock = None                       # Open network connection to CORE
_core_files = None                     # Open subprocess ssh connection to CORE
_core_stats_log_file = None             # -C option
#
_edges = []                             # -e/-E options
_edge_sock = None                       # Open network connection to EDGE
_edge_files = None                     # Open subprocess ssh connection to EDGE
_edge_stats_log_file = None             # -E option
#
CMD_OPTION_CORE = 1                     # -C/-c CORE options
CMD_OPTION_EDGE = 2                     # -E/-e EDGE options
CMD_OPTION_GRAPH = 4                    # -g/-r Graph options
CMD_OPTION_SAVE = 8                     # -s Save statistics option
CMD_OPTION_NO_ANALYSIS = 16             # -A Do not analyze statistics
CMD_OPTION_EDGE_SSH_PASSWORD = 32       # -B EDGE only ssh password
CMD_OPTION_CORE_SSH_PASSWORD = 64       # -C CORE only ssh password
CMD_OPTION_BOTH_SSH_PASSWORD = 128      # -S Both CORE and EDGE ssh password
_cmd_options_set = 0
_skip_iscsi = False                     # -I iSCSI option
_graph_core_stats = []                  # -g Graph core stats option
_graph_edge_stats = []                  # -r Graph edge stats option
_edge_ssh_password = ""                 # -B ssh password option only EDGE
_core_ssh_password = ""                 # -C ssh password option only CORE
_graph_file_name = "stats_graphs"       # -G Graph file option
_ssh_password = ""                      # -S ssh password option both CORE and EDGE
_save_prefix = None                     # -s save option
_verbosity = 0                          # -v verbosity level option
_x_file_name = None                     # -x File to evaluate option

#------------------------------------------------------------------------------
import base64

def _vadebug_main():
    global _debug
    global _cores
    global _core_sock
    global _core_stats_log_file
    global _edges
    global _edge_sock
    global _edge_stats_log_file
    global _outfile
    global CMD_OPTION_CORE
    global CMD_OPTION_EDGE
    global CMD_OPTION_GRAPH
    global CMD_OPTION_SAVE
    global CMD_OPTION_NO_ANALYSIS
    global _cmd_options_set
    global _core_ssh_password
    global _edge_ssh_password
    global _skip_iscsi
    global _graph_core_stats
    global _graph_edge_stats
    global _graph_file_name
    global _save_prefix
    global _ssh_password
    global _verbosity
    global _x_file_name

    try:                                
        opts, args = getopt.getopt(sys.argv[1:],
                                   "AC:E:G:IO:S:T:U:c:e:g:ho:r:s:v:x:", [])
    except getopt.GetoptError:           
        usage()                          
        print "Invalid option"
        sys.exit(-1)

    for opt, arg in opts:
        if opt == "-c": 
            _cores.append( ('net', arg) )
            _cmd_options_set |= CMD_OPTION_CORE
        elif opt == "-e": 
            _edges.append( ('net', arg) )
            _cmd_options_set |= CMD_OPTION_EDGE
        elif opt == "-g":
            _graph_core_stats.append(arg)
            _cmd_options_set |= CMD_OPTION_GRAPH
        elif opt == "-h": 
            usage()
            sys.exit(0)
        elif opt == "-o": 
            _outfile = arg
        elif opt == "-r":
            _graph_edge_stats.append(arg)
            _cmd_options_set |= CMD_OPTION_GRAPH
        elif opt == "-s": 
            _cmd_options_set |= CMD_OPTION_SAVE
            _save_prefix = arg
        elif opt == "-v":
            _verbosity = int(arg)
        elif opt == "-x": 
            _x_file_name = arg
        elif opt == "-A": 
            _cmd_options_set |= CMD_OPTION_NO_ANALYSIS
        elif opt == "-C": 
            if arg.find(":") == -1:
                _cores.append( ('file', arg) )
            else:
                _cores.append( ('log', arg) )
            _cmd_options_set |= CMD_OPTION_CORE
        elif opt == "-E": 
            if arg.find(":") == -1:
                _edges.append( ('file', arg) )
            else:
                _edges.append( ('log', arg) )
            _cmd_options_set |= CMD_OPTION_EDGE
        elif opt == "-G": 
            _graph_file_name = arg
        elif opt == "-I":
            _skip_iscsi = True
        elif opt == "-O":
            _debug = int(arg)
        elif opt == "-S": 
            _cmd_options_set |= CMD_OPTION_BOTH_SSH_PASSWORD
            _ssh_password = arg
        elif opt == "-T": 
            _cmd_options_set |= CMD_OPTION_CORE_SSH_PASSWORD
            _core_ssh_password = arg
        elif opt == "-U": 
            _cmd_options_set |= CMD_OPTION_EDGE_SSH_PASSWORD
            _edge_ssh_password = arg
        
    if ((_cmd_options_set &
         (CMD_OPTION_CORE_SSH_PASSWORD|CMD_OPTION_BOTH_SSH_PASSWORD)) ==
        (CMD_OPTION_CORE_SSH_PASSWORD|CMD_OPTION_BOTH_SSH_PASSWORD)):
        usage()
        print "Cannot specify both -C and -S"
        sys.exit(-1)
        
    if ((_cmd_options_set &
         (CMD_OPTION_EDGE_SSH_PASSWORD|CMD_OPTION_BOTH_SSH_PASSWORD)) ==
        (CMD_OPTION_EDGE_SSH_PASSWORD|CMD_OPTION_BOTH_SSH_PASSWORD)):
        usage()
        print "Cannot specify both -B and -S"
        sys.exit(-1)

    if (_cmd_options_set &
        (CMD_OPTION_CORE|CMD_OPTION_EDGE|CMD_OPTION_GRAPH)) == 0:
        usage()
        print "Must specify CORE, EDGE, or graph option."
        sys.exit(-1)

    print "[ vadebug v%s ]" % _version

    _debug_bit_names = [ "graph_stats,", "prefetch - BKT,",
                         "prefetch - Verbose,",
                         "prefetch - Basic,", "iSCSI,", "hinter,",
                         "main or routines,",
                         "Other ui,", "ui_log,", "Log full path,",
                         "Log stat_path,",
                         "Log not used,", "Log: All stat sets,",
                         "Log: value/diff,",
                         "Log: All stats," ];
    if _debug != 0:
        print "-O is %d:" % _debug,
        mask = 16384
        idx = 0
        while (mask > 0):
            if (_debug & mask) != 0:
                print "%d %s" % ( mask, _debug_bit_names[idx]),
            mask = mask / 2
            idx += 1
        print ""

    if __debug__ != 0:
        print "__debug__ is", __debug__

    # Get all EDGE stats
    if (_cmd_options_set & CMD_OPTION_EDGE) != 0:
        if _edge_ssh_password != "":
            _ssh_password = _edge_ssh_password
        get_all_stats(False, _ssh_password)
    if (len(_edgestats) == 0) and False:
        empty_entry = ( (["", 0]), "", None, None)
        append_to_stats(_edgestats, empty_entry, "EDGE")

    # Get all CORE stats
    if (_cmd_options_set & CMD_OPTION_CORE) != 0:
        if _core_ssh_password != "":
            _ssh_password = _core_ssh_password
        get_all_stats(True, _ssh_password)
    if (len(_corestats) == 0) and False:
        empty_entry = ( (["", 0]), "", None, None)
        append_to_stats(_corestats, empty_entry, "EDGE")

    if (_debug & 256) != 0:
        print "len(_cores) %d, len(_corestats) %d, _cores '%s'," \
              " len(_edges) %d, len(_edgestats) %d, _edges '%s'" % (
            len(_cores), len(_corestats), str(_cores),
            len(_edges), len(_edgestats), str(_edges) )

    # Load the UI
    print "SETUP: Loading UI ..."
    ui_init()

    # Evaluate a file to modify the rules
    if _x_file_name != None:
        evaluate_file(_x_file_name)

    # The debugging part of it ...
    total = 6
    if (_debug & 8) != 0:
        total += 1
    i = 1;

    #ui_section('global')
    #global_debug()

    if ((_cmd_options_set & CMD_OPTION_NO_ANALYSIS) == 0):
        if _skip_iscsi or ((_cmd_options_set & CMD_OPTION_EDGE) == 0):
            print "%d/%d: Skip -- Analyzing iSCSI..." % (i, total)
        else:
            print "%d/%d: Analyzing iSCSI..." % (i, total)
            ui_section('iscsi')
            iscsi_debug()
        i += 1

        if (_cmd_options_set & CMD_OPTION_CORE) == 0:
            print "%d/%d: Skip -- Analyzing Prefetch..." % (i, total)
        else:
            print "%d/%d: Analyzing Prefetch..." % (i, total)
            ui_section('prefetch')
            prefetch_debug()
        i += 1

        if (_cmd_options_set & CMD_OPTION_CORE) == 0:
            print "%d/%d: Skip -- Analyzing VMFS..." % (i, total)
        else:
            print "%d/%d: Analyzing VMFS..." % (i, total)
            ui_section('vmfs')
            vmfs_debug()
        i += 1

        if (_cmd_options_set & CMD_OPTION_CORE) == 0:
            print "%d/%d: Skip -- Analyzing Hinter..." % (i, total)
        else:
            print "%d/%d: Analyzing Hinter..." % (i, total)
            ui_section('hinter')
            hinter_debug()
        i += 1

        print "%d/%d: Analyzing raw stats..." % (i, total)
        ui_section('raw')
        raw_debug()
        i += 1

        # Report unused stats
        if (_debug & 8) != 0:
            print "%d/%d: Reporting unused stats..." % (i, total)
            ui_section('unused')
            unused_debug()
            i += 1
    else:
        print "1-%d/%d: Skip -- Analyzing stats..." % (total - 1, total)
        i = total

    # Graph statistics
    if (len(_graph_core_stats) + len(_graph_edge_stats)) == 0:
        print "%d/%d: Skip -- Graphing stats..." % (i, total)
    else:
        if len(_graph_edge_stats) != 0:
            print "%d/%d: Graphing EDGE stats..." % (i, total)
            graph_edge_stats("", _graph_file_name + ".edge")
        if len(_graph_core_stats) != 0:
            print "%d/%d: Graphing CORE stats..." % (i, total)
            graph_core_stats("", _graph_file_name + ".core")
    i += 1

    # Finalize
    if ((_cmd_options_set & CMD_OPTION_NO_ANALYSIS) == 0):
        print "FINISH: Saving result to %s.html ..." % _outfile
        ui_done()

    # Done
    print "FINISH: Disconnecting from EDGE/CORE ..."
    disconnect_from_edge()
    disconnect_from_core()

    print "All Done!"
    return 0

#------------------------------------------------------------------------------
if ((__name__ == "__main__") and
    (sys.argv[0].endswith("vadebug.py") or sys.argv[0].endswith("vadebug"))):
    exit_status = _vadebug_main()
    sys.exit(exit_status)
