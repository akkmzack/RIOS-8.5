#!/usr/bin/env python
#  Filename:  $Source$
#  Revision:  $Revision: 51619 $
#  Date:      $Date: 2009-05-14 00:51:19 -0700 (Thu, 14 May 2009) $
#  Author:    $Author: jshilkaitis $
# 
#  (C) Copyright 2003-2008 Riverbed Technology, Inc.  
#  All rights reserved.

from os.path import exists
from os import popen, remove, mkdir
from rrdm_util import get_hwtool_motherboard, run_shell_cmd, rrdm_error
from xml.dom.minidom import parse
# import the invalid xml exception
from xml.parsers.expat import ExpatError
from DiskFwLib import *
import sys


###############################################################################
# DiskLib
#
# General Python utilities for disk and disk firmware upgrade management
#
###############################################################################

# Exception Classes 
#
class SmartInfoException(Exception):
    pass

class DiskConfigException(Exception):
    pass

class FirmwareUpdateException(Exception):
    pass

###############################################################################
# GLOBALS
###############################################################################

# location we'll use to store update information regarding our previous drive 
# firmware update attempts
disk_state_cache_dir='/config/disk'

# disk config and firmware file directory.
disk_lib_dir='/opt/hal/lib/disk'

# default location for the configuration file
disk_fw_cfg_file='%s/fw_cfg.xml' % disk_lib_dir

###############################################################################
# SmartDiskInfo
#
# Wrapper around smartctl -d <> -i, which gives basic model, firmware,
# and other disk params.
#
# At the moment, we're only using the model, serial and firmware fields.
#
# We should use diskinfo, but that would require an API change at the moment
# which we won't do at this time.  All the info is available from smart info
#
###############################################################################
class SmartDiskInfo:
    ###########################################################################
    # raises:
    # SmartInfoException : for invalid device_name param
    # rrdm_error         : for a hwtool error.
    #
    ###########################################################################
    def __init__(self, device_name):
        if device_name == '':
            raise SmartInfoException('Invalid Device %s' % device_name)
        if not exists (device_name):
            raise SmartInfoException('Device %s does not exist' % device_name)

        self.__device_name = device_name

        self.__fields       = None

        mobo = get_hwtool_motherboard()
        if mobo[0:9] == "400-00300":
            self.__cmd_method   = 'sat'
        else:
            self.__cmd_method   = 'ata'

    ###########################################################################
    # internal.
    #
    # fetch smart info and return in a dictionary
    # raises : 
    # SmartInfoException : for errors returned from smart command or no output
    #                      returned 
    #
    ###########################################################################
    def __get_smart_info(self):
        smart_cmd = 'smartctl -d %s -i %s' % (self.__cmd_method, self.__device_name)

        try:
            output = run_shell_cmd (smart_cmd, True)
        except rrdm_error:
            raise SmartInfoException('Smart command failed [%s]' % smart_cmd)

        if output == '':
            raise SmartInfoException('Smart command failed [%s]' % smart_cmd)

        fields = {}
        for line in output.split('\n'):
            parts = line.split(":")
            if len (parts) != 2:
                # a field whose format we don't understand, so skip
                continue
            fields[parts[0].strip()] = parts[1].strip()

        return fields

    ###########################################################################
    # internal.
    #
    # checks the fields dictionary for the key, name, and returns the associated 
    # value.
    #
    # returns the empty string if the key is not found.
    #
    ###########################################################################
    def __lookup_smart_field(self, name):
        if self.__fields == None:
            self.__fields = self.__get_smart_info()
        if self.__fields.has_key(name):
            return self.__fields[name]
        else:
            return ''

    ###########################################################################
    # External routines 
    # these do a lazy lookup on the smart data and return the associated 
    # data.
    #
    # raise:
    # SmartInfoException : on errors fetching the smart data.
    #
    ###########################################################################
    def get_model(self):
        return self.__lookup_smart_field('Device Model')

    def get_serial(self):
        return self.__lookup_smart_field('Serial Number')

    def get_firmware(self):
        return self.__lookup_smart_field('Firmware Version')



###############################################################################
# FirmwareConfigInfo
#
# Holds a configuration entry from the disk firmware xml file.
# thids represents the current firwmare revision and file for a 
# given model of disk.
#
# Each model of disk specified in the configuration fail MUST have
# an assocated firmware comparison function in DiskFwLib.
#
# thows:
# DiskConfigException - Drive model requested does not have a comparison 
#                       function registered.
#
###############################################################################
class FirmwareConfigInfo:
    def __init__(self, model, firmware, fw_file):
        self.__model    = model
        self.__firmware = firmware
        self.__get_fw_action = None
        self.__fw_file  = '%s/%s' % (disk_lib_dir, fw_file)

        if not fw_string_cmp_func_map.has_key(model):
            # the config specifies a drive that we don't understand.
            raise DiskConfigException('No comparison function registered for drive model %s' %
                                          model)
        self.__get_fw_action = fw_string_cmp_func_map[model]

    # External:
    ###########################################################################
    # get the model/firmware/fw file  information from the object
    #
    ###########################################################################
    def get_model(self):
        return self.__model

    def get_firmware(self):
        return self.__firmware

    def get_fw_file(self):
        return self.__fw_file

    ###########################################################################
    # get_fw_action
    # 
    # returns a string representing the action needed for the given operation
    # 'current'     : No changes needed
    # 'needsupdate' : The firmware revision specified by the configuraiton 
    #                 file is newer and should be updated.
    # 'unknown'     : The firmware version on the drive is unrecognized by this 
    #                 check.
    # 'configerror' : The configuration file specifies an invalid firmware format
    #
    ###########################################################################
    def get_fw_action(self, fw_str):
        if self.__get_fw_action != None:
            return self.__get_fw_action(self, fw_str)
        else:
            # if we don't have an action there was no function 
            # registered for this drive model
            return 'configerror'

###############################################################################
# DriveConfigMap
#
# Maintains a dictionary mapping the model of a disk as a key to the 
# appropriate drive firwmare and firwmare file associated to that drive model
#
# raises:
# DiskConfigException : error accessing the config file.
#
###############################################################################
class DriveConfigMap:
    def __init__(self, fw_cfg_file = disk_fw_cfg_file, verbose = False):
        self.__verbose = verbose
        self.__fw_cfg_file = fw_cfg_file

        if not exists(self.__fw_cfg_file):
            raise DiskConfigException('Unable to find disk firmware configuration file')

        self.__map = {}

        try:
            dom = parse (self.__fw_cfg_file)

            entries = dom.getElementsByTagName('entry')
            if entries:
                for entry in entries:
                    model    = entry.getAttribute('model')
                    firmware = entry.getAttribute('fw_ver')
                    fw_file  = entry.getAttribute('fw_file')

                    if self.__verbose:
                        print 'Read Config [%s:%s:%s]' % (model, firmware, fw_file)

                    fci = FirmwareConfigInfo(model, firmware, fw_file)
                    self.__map[model] = fci
        except ExpatError:
            raise DiskConfigException('Invalid XML in %s' % self.__fw_cfg_file)

    ###########################################################################
    # External methods for fetching/adding/checking entries in the 
    # disk configuration map.
    #
    ###########################################################################
    def has_entry(self, model):
        return self.__map.has_key(model)

    def get_entry(self, model):
        if self.has_entry(model):
            return self.__map[model]

###############################################################################
# Drive
#
# Global accessor for drive related info.  Holds the model/firmware/serial #
# into, but also is tied into the firwmare configuration for the appliance
# and can update the firmware on the drive.
#
# verbose sets the class to output debug info to stdout.
#
# Special restrictions on firmware updates:
# 1) Must be done when no other IO can occur to the drive
#    Non fw commands cause the firmware load to abort, and possibly the 
#    drive to reset.
#
# raises:
# SmartInfoException: on errors fetching model/firmware information
# DiskConfigException: Unsupported fw on drive, errors reading the configuration, 
#                      etc.
# 
###############################################################################
class Drive:
    def __init__(self, device_name, fw_cfg_list = None, verbose=False):
        self.__verbose      = verbose
        self.__device_name  = device_name

        if not exists(self.__device_name):
            return None

        self.__dsi      = SmartDiskInfo(self.__device_name)

        self.__model    = self.__dsi.get_model()
        self.__firmware = self.__dsi.get_firmware()
        self.__serial   = self.__dsi.get_serial()

        # keep a pointer to the config around
        self.__fw_cfg_list      = fw_cfg_list
        self.__fw_max_retries   = 2 

        # read the config entry for this disk
        if fw_cfg_list.has_entry(self.__model):
            self.__fw_cfg_entry = fw_cfg_list.get_entry(self.__model)
        else:
            self.__fw_cfg_entry = None

        if self.__verbose:
            print 'Dev Name: %s' % self.__device_name
            print 'Model   : %s' % self.__model
            print 'Firmware: %s' % self.__firmware
            print 'Serial  : %s' % self.__serial


    ###########################################################################
    # External routines for fetching info about the drive
    ###########################################################################
    def get_model(self):
        return self.__model

    def get_firmware(self):
        return self.__firmware

    def get_serial(self):
        return self.__serial

    ###########################################################################
    # needs_fw_update
    #
    # Check the firwmare on the drive and compare it against the revision
    # that is supported by this image. Uses the comparison function 
    # registered for the particular drive model.
    #
    ###########################################################################
    def needs_fw_update(self):
        if self.__fw_cfg_entry != None:
            action = self.__fw_cfg_entry.get_fw_action(self.__firmware)
            if action == 'needsupdate':
                return True
            elif action == 'current':
                return False
            else:
                # an error condition, either unknown, or config error.
                raise DiskConfigException('Unknown Disk Firwmare %s' %
                                          self.__firmware)
        else:
            if self.__verbose:
                print 'No firmware configuration for device [%s:%s]' % (
                        self.__device_name, self.__model)

            # if we don't have a config entry for this drive, then
            # everything is current.
            return False

    ###########################################################################
    # internal
    #
    # fw_util only fails on certain appliances when the fw update fails. You need
    # double check the update by reading back the new firmware version.
    #
    # If fw_util error occurs, the sense data is returned by fw_util,
    # and we print that code to stdout.
    #
    # The result of the update is printed to stdout.
    #
    ###########################################################################
    def __run_fw_util(self, cmdline):
        pf = popen ('%s 2>&1' % cmdline)
        output = pf.read()
        rcode = pf.close()

        # we've seen some irregularities in how drives report
        # failed upgrades, so upgrade success is determined by
        # verifying the readback of the appropriate firmware
        # version
        # 
        # when fw_util fails, it will return sense data if it has 
        # it (1UABA only returns sense data today)
        if rcode != None:
            # return code = bad status
            if output.strip() != '':
                print 'Scsi Sense Info[%s]: %s' % (self.__device_name, output)

        disk=Drive(self.__device_name, self.__fw_cfg_list, self.__verbose)
        if disk.needs_fw_update():
            str = 'Firmware Update [%s: upgrade %s to %s] failed' % (self.__device_name,
                                                            self.__firmware,
                                                            self.__fw_cfg_entry.get_firmware())
            raise FirmwareUpdateException(str)

    ###########################################################################
    # do_fw_update
    #
    # perform the firmware update, if needed.  If force is set fw_util is 
    # invoked regardless of the current fw version on the drive.
    #
    ###########################################################################
    def do_fw_update(self, fw_file = '', force = False):
        retries = 0
        cmdline = ''

        if force or self.needs_fw_update():
            if fw_file == '' and self.__fw_cfg_entry != None:
                fw_file = self.__fw_cfg_entry.get_fw_file()
            elif fw_file == '':
                raise DiskConfigException('A Firmware file must be specified')

            if not exists(fw_file):
                raise DiskConfigException('Firmware file %s does not exist' % fw_file)

            cmdline = '/opt/tms/bin/fw_util -f %s %s' % (fw_file,
                                                         self.__device_name)
            if self.__verbose:
                print 'Cmd : [%s]' % cmdline

            while retries < self.__fw_max_retries:
                try:
                    self.__run_fw_util(cmdline)
                    break
                except FirmwareUpdateException, what:
                    # when we finished our last retry, raise this exception
                    if retries == self.__fw_max_retries - 1:
                        raise FirmwareUpdateException(what)
                    else:
                        if self.__verbose:
                            print 'Update failed, retrying'
                        retries = retries + 1
                

###############################################################################
# DiskFwUpdateContext
#
# When performing drive firwmare updates, we need to know how many times
# we're tried to reflash the firmware on a given drive, and if we have attempted
# more the X number of retries, we should not proceed.
#
# Unfortunately, we can't have any raid arrays started when the disks are being 
# updated, so we don't have access to /var or any normal locations for tracking 
# firmware updates that have failed previously.  We're using a directory on /config
# for this purpose (/config/disk)
#
# In that directory we create a file disk_<serial>_<fw>, which contains the number
# of retries currently employed for that disk/fw combo.
#
#
#
###############################################################################
class DiskFwUpdateContext:
    def __init__(self, disk, path=disk_state_cache_dir):
        self.__max_retries  = 2
        self.__disk     = disk
        self.__cfg_path = '%s/disk_%s_%s' % (path,
            disk.get_serial().replace(' ', ''),
            disk.get_firmware())

        if not exists(path):
            mkdir(path)

        self.__failed_attempts = 0
        self.__read_state()


    ###########################################################################
    # internal
    # read the disks file (if it exists) and return the number of previous
    # attempts, if the file doesnt exist, or we find a malformed file,
    # assume we havent tried to update that disk before.
    #
    ###########################################################################
    def __read_state(self):
        output = '0'

        if exists(self.__cfg_path):
            try:
                fh = open (self.__cfg_path, "r")
                output = fh.read()
            finally:
                fh.close()

        try:
            result = int(output)
        except ValueError:
            # if the file has been corrupted, just assume we 
            # want to try to udpate.
            result = 0

        self.__failed_attempts = result

    ###########################################################################
    # External routines for determining the saved state
    # for a given disk and firmware combination
    #
    ###########################################################################
    def should_update(self):
        return self.__failed_attempts < self.__max_retries

    def get_max_retries(self):
        return self.__max_retries

    ###########################################################################
    # mark_success
    #
    # clear out any indication that this drive has previously failed a firmware 
    # update.
    #
    ###########################################################################
    def mark_success(self):
        if exists(self.__cfg_path):
            try:
                remove(self.__cfg_path)
            except Exception:
                # if we can't remove it, just deal with it.  The firware file name
                # will change, so it won't impact us the next time 
                # the script is run (it is a 1 file leak on the fs tho).
                pass

    ###########################################################################
    # mark_failed
    #
    # set an indication that the drive failed a firmware update.
    #
    ###########################################################################
    def mark_failed(self):
        self.__failed_attempts = self.__failed_attempts + 1
        try:
            fh = open (self.__cfg_path, "w")
            fh.write('%d' % self.__failed_attempts)
        finally:
            fh.close()
