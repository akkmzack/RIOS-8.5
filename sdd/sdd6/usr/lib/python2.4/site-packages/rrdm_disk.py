#!/usr/bin/env python

################################################################################
# Disk Related Structures
#
# Hard Disk
# Partition
# Partition Table
# DiskArray
#
################################################################################
from sys import exit, argv
from getopt import getopt, GetoptError
from os import remove, popen, stat, path, rename
from popen2 import Popen4
from time import sleep
from rrdm_util import *
from rrdm_super import RvbdSuperBlock
from rrdm_config import Partition, LogicalPartition

try:
    from Logging import *
except ImportError:
    pass

# Serial number used for spare disks created by OPs
spare_serial_num = '0000000000000'

#
# don't make init read the state unless you add the hw_ctl util to the 
# mfg tarball.
#
class DiskLED:
    def __init__(self, port):
	# XXX do a sanity check on port 
	self.port=port
	self.cmd_led_status = '/opt/hal/bin/hw_ctl.py -r hdd %s fault_led_on' % self.port
	self.cmd_led_on	    = '/opt/hal/bin/hw_ctl.py -w hdd %s fault_led_on' % self.port
	self.cmd_led_off    = '/opt/hal/bin/hw_ctl.py -w hdd %s fault_led_off' % self.port
	
    def get_led_state(self):
	
	rlog_debug ('Running %s' % self.cmd_led_status)
	try:
	    output = run_shell_cmd (self.cmd_led_status, True)
	    cmd_state = output.split('=')[1].strip()
	    if cmd_state == "True":
		state = "on"
	    else:
		state = "off"
	
	except (rrdm_error, IndexError):
	    state = 'unknown'

	return state

    def set_led_state(self, mode):
	if mode:
	    command = self.cmd_led_on
	else:
	    command = self.cmd_led_off
        try:
	    rlog_debug ('Running %s' % command)

            err = run_shell_cmd (command, False)
	    if err > 0:
		rlog_notice ('Failed to set LED state on drive %s' % self.port)
	    
        except (rrdm_error, IndexError):
	    rlog_notice ('Failed to set LED state on drive %s' % self.port)


################################################################################
# Hard Drive and Drive Array Structures 
################################################################################
class HardDisk:
    def __init__(self):
        self.type=''
        self.name=''
        self.portnum=''
        self.vendor=''
        self.bus_num=''
        self.size='0'
        self.cfg_size='0'
        self.status=''
        self.model='unknown'
        self.__media = 'unknown'
        # the partition table we expect is driven by the config.
        self.part_tbl=None
        self.__zone = None

        # the logical offset of a drive within its zone.
        self.__logical_port = -1

        # the logical offset the drive thinks it is within its zone
        # this info is read from the drive SB, -1 indicates the drive 
        self.__drive_logical_port = -1
    
        self.superblock=None
	self.disk_led=None
   
        # flag to indicate if the disk is managed by someone else (eg. writeimage.sh)
        self.__managed=False 

    # extended info filled in at request is the serial, model, fw, info
        self.serialnum=''
        self.firmware=''
        # branding info
        self.licensed=True

    def __str__(self):
        if self.__zone:
            zname = self.__zone.get_name()
        else:
            zname = 'unknown'

        result = ''
        result += 'disk%d:%d:%d:%s:%s:%s:%s:%s\n' % (self.portnum, 
                                             self.__logical_port, 
                                             self.__drive_logical_port,
                                             zname, self.model, 
                                             self.serialnum, self.firmware,
                                             self.status)
        return result

    def get_media(self):
        return self.__media

    def get_zone(self):
        return self.__zone

    ## has_volume_by_name
    # @param name Name of a volume/raid/ftraid array
    # Return True if a zone contains a given volume
    def has_volume_by_name(self, name):
        return self.__zone.has_volume_by_name(name)

    def get_portnum(self):
        return self.portnum

    def get_logical_port(self):
        return self.__logical_port

    def get_drive_logical_port(self):
        return self.__drive_logical_port
    
    def get_base_scsi_name(self):
        return hwtool_disk_map.find_devname_by_port(self.portnum)

    def get_scsi_state(self):
        return hwtool_disk_map.find_state_by_port(self.portnum)

    def get_devname(self):
        return 'disk%s' % self.portnum

    def get_drive_id(self):
        if self.serialnum == '':
            return 'unknown'
        else:
            return self.serialnum

    def get_license(self):
        return self.licensed

    def managed(self):
        return self.__managed

    ###########################################################################
    # Status Routines for Disks
    #
    # disk status is one of "online" "failed" "rebuilding" "missing" "degraded"
    #
    ###########################################################################
    def is_online(self):
        return self.status == 'online'
        
    def is_rebuilding(self):
        return self.status == 'rebuilding'

    def is_missing(self):
        return self.status == 'missing'
        
    def is_failed(self):                     
        return self.status == 'failed'       

    def is_invalid(self):
        return self.status == 'invalid'
                                             
    def degrade_drive(self):                 
        self.status = 'degraded'             
        
    def fail_drive(self):
        self.status = 'failed'

    def invalid_drive(self):
        self.status = 'invalid'
        
    def rebuild_drive(self):
        self.status = 'rebuilding'


    ###########################################################################
    #
    # A hard disks info is filled in via 2 phases when read from the system.
    # initially the physical information is read from the system and stored.
    # then this information is used to build up the raid information,
    # and finally, the status of the disk is determined by the state of the raids on 
    # the disk itself.
    # update status chooses the correct status for a disk based on the raid arrays that live
    # on the disk.
    #
    ###########################################################################
    def update_status_by_zone (self, raid_arrays, ftraid_arrays):
        # if the disk is not missing, we can look up its info in the raid arrays.
        #
        if (self.status == 'online'):
            for array in raid_arrays:
                drv_status = array.get_drive_raid_status(self)
                if drv_status != None:
                    if drv_status in [ 'failed', 'missing' ]:
                        self.degrade_drive()
                    elif drv_status == 'rebuilding':
                        self.rebuild_drive()

            for ftarr in ftraid_arrays:
                drv_status = ftarr.get_drive_status(self)
                if drv_status != None:
                    if drv_status != 'online':
                        self.degrade_drive()

    # This function reads information off the sysfs and other sources to
    # fill in disk related params.
    def fill_disk_params(self, port):
        found_bus = hwtool_disk_map.find_bus_by_port(port)
        if found_bus == None:
	    raise rrdm_error ('Unable to determine bus number for port [%s]' % port)

	licensed = hwtool_dlm.is_licensed('%s' % port)

	# disk params read from sysfs based on the bus.
	# if any of these fail, assume the disk has gone missing.
	#
	# XXX/munirb: Bug 38786
	# Dont set the status to failed as the disk may be missing
	# Check for that by doing an IO for vendor name which will
	# fail for missing drives
	self.type = get_scsi_sysfs_param(found_bus, 'vendor')
	self.bus_num = found_bus
	self.name = get_scsi_sysfs_param(found_bus, 'device_name')
	self.model = get_scsi_sysfs_param(found_bus, 'model')
	self.size = get_scsi_sysfs_param(found_bus, 'block/size')
	# XXX/munirb: Bug 38665
	# Set the status to online even though the disk is unbranded
	# If the disk is already being used, no point raising the RAID alarm
	# Hardware alarm will be triggered via self.licensed
	# Also clear all disk details as we want to give the impression
	# that it is a big thing to use that disk
	self.status="online"
        if self.model == "Virtual disk":
            self.serialnum  = ""
            self.firmware   = ""
            self.__media    = "disk"
        else:
            dinfo = disk_info_map.get_disk_info(self.get_devname())
            if dinfo != None and dinfo.have_valid_info():
                self.serialnum  = dinfo.get_serial()
                self.firmware   = dinfo.get_fw()
                self.__media    = dinfo.get_media()
            else:
                self.serialnum  = 'unknown'
                self.firmware   = 'unknown'
                self.__media    = 'unknown'
	    
	if licensed:
	    self.licensed=True 
	else:
	    self.licensed=False

    # Fill spare info from system and diskinfo
    def fill_system_spare_info(self, port):
        self.type='ATA'
        self.portnum = port
        try:
            self.fill_disk_params(self.portnum)

        except IOError:
            self.status="missing"
            self.licensed=False

    # the part tbl we expect is driven by the configuration
    # so it is set by its own API.
    def fill_from_system_info(self, port, zone, part_tbl, mfg_mode):
        self.type='ATA'
        self.__zone = zone
        
        self.part_tbl = part_tbl
        self.portnum = port

        try:
	    # Check if the disk is in a managed zone (for VSH) ?
	    dl = zone.get_layout()
	    if dl.managed_disk() == 1:
                rlog_debug ('Drive %d is externally managed' % self.portnum)
	        self.__managed = True 

        except rrdm_error:
	    print what
	    pass

        self.__logical_port = zone.physical_to_zone_logical(self.portnum)
        if self.__logical_port == None or self.__logical_port < 0:
            raise rrdm_error ('Invalid drive %d for zone %s' % (self.portnum, 
                              zone.get_name()))

        try:
            self.fill_disk_params(self.portnum)

        except IOError:
            self.status="missing"
            self.licensed=False

        if not self.is_missing() and \
            not self.__zone.is_media_valid(self.__media):
            self.invalid_drive()

	# initialize the LED 
	self.disk_led = DiskLED(port)	

        # if the drive is here & not managed, read the SB
        if not self.is_missing() and self.managed() == False:
            self.read_superblock()
            if mfg_mode == False and self.superblock == None:
                rlog_notice ('Drive %s does not have a valid superblock' % self.name)
                self.fail_drive()
            else:
                if SystemDiskStatus(self.portnum).is_failed():
                    self.fail_drive()

        if self.__zone and self.__zone.get_name() == 'fts':
            if self.superblock:
	        if self.superblock.get_serial() == spare_serial_num:
                    # Its a spare disk, keeping the debug statement if we add 
                    # anything in the future
                    rlog_debug ('Drive %s is a spare disk' % self.name)
		else:
		    if self.superblock.get_serial() != ApplianceInfo().get_serial() or \
		       self.__logical_port != self.superblock.get_raid_port():
			# out of position drive, this requires force add to 
			# get the system to use the disk
			self.invalid_drive()

    def is_valid_media(self):
        return self.__zone.is_media_valid(self.__media)

    def has_valid_superblock(self):
	return self.superblock != None

    def display_drive_info(self):
	print '\t----------------------------------------\t'
	print '\tPhysical Drive %s' % self.portnum 
	print '\t----------------------------------------\t'

	size_blocks	= int (self.size, 10) 
	size_gb		= size_blocks * 512 / (1024*1024*1024)
	print '\tStatus: %s\t\tType: %s' % (self.status, self.get_media())
	print '\tProduct: %s\t\tCapacity: %d GB' % (self.model, size_gb)
	print '\tSerial: %s\t\tFirmware: %s' % (self.serialnum, self.firmware)
	print '\tLicensed: %s' % self.get_license()
	print ''


    ###########################################################################
    # Disk LED Control Params
    #
    ###########################################################################
    def turn_on_led(self):
	self.disk_led.set_led_state (True)
	
    def turn_off_led(self):
	self.disk_led.set_led_state (False)

    def get_led_state(self):
	return self.disk_led.get_led_state()

    def read_superblock(self, wait_for_device = False):
        part = self.part_tbl.find_partition_by_name ('rvbd')
        if part != None and self.status != 'missing':
            rvbd_dev = '/dev/%sp%s' % (self.get_devname(), part.part_id)
            try:
                self.superblock = RvbdSuperBlock(rvbd_dev, wait_for_device)
                rlog_debug ('Read SB for %s [%d:r%d]' % (rvbd_dev,
                                                         self.superblock.get_port(),
                                                         self.superblock.get_raid_port()))
                self.__drive_logical_port = self.superblock.get_raid_port()
            except rrdm_error, error_msg:
                self.superblock = None

        else:
            rlog_notice ('unable to read rvbd SB partition for disk %s' % self.name)


    def printto(self, xml = False):
        if xml == True:
            print '<drive portnum=\"%d\" model=\"%s\" vendor=\"%s\" size=\"%d\" serial=\"%s\"/>' % (self.portnum, self.model, self.vendor, self.size, self.serialnum)
        else:
            print 'Port: ', self.portnum, 'Device:', self.name, 'Status:', self.status , 'Model:', self.model, 'Size:', self.size


    def get_status(self, xml = False):
        if xml == True:
            print '<drive portnum=\"%s\" status=\"%s\"/>' % (self.portnum, self.status)
        else:
            print self.portnum, ' ', self.status

    def get_detail_status(self, xml = False):
        if self.superblock == None:
            block_size='0'
        else:
            block_size=self.superblock.get_sb_kvp('erase_block_size')
            if block_size == None:
                block_size ='0'
        if xml == True:
            try:
                print '<drive portnum=\"%s\" logical_port=\"%s\" model=\"%s\" vendor=\"%s\" size=\"%s\" serial=\"%s\" firmware=\"%s\" zone=\"%s\" media=\"%s\" disk_mode=\"%s\" erase_block_size=\"%s\" status=\"%s\"/>' % (
                    self.portnum, self.__drive_logical_port, self.model, self.vendor, self.size, self.serialnum, self.firmware, self.__zone.get_name(), self.__media, str(self.__zone.get_disk_status_mode()), block_size, self.status)
            except:
	        pass
        else:
            print self.portnum, '\t', self.model, '\t', self.size, '\t', self.__zone.get_name(), '\t', self.status

    def get_disk_part_status(self):
        if self.superblock == None:
            block_size='0'
        else:
            block_size=self.superblock.get_sb_kvp('erase_block_size')
            if block_size == None:
                block_size ='0'

        result = '<drive '
        result += 'portnum=\"%s\" ' % self.portnum
        result += 'logical_port=\"%s\" ' % self.__drive_logical_port
        result += 'model=\"%s\" ' % self.model
        result += 'vendor=\"%s\" ' % self.vendor
        result += 'size=\"%s\" ' % self.size
        result += 'serial=\"%s\" ' % self.serialnum
        result += 'firmware=\"%s\" ' % self.firmware
        result += 'zone=\"%s\" ' % self.__zone.get_name()
        result += 'media=\"%s\" ' % self.__media
        result += 'disk_mode=\"%s\" ' % str(self.__zone.get_disk_status_mode())
        result += 'erase_block_size=\"%s\" ' % block_size
        result += 'status=\"%s\" ' % self.status
        result += '>\n'
        result += '<partition_table num=\"%d\" >\n' % self.part_tbl.get_num_partitions()
        for part in self.part_tbl.get_partition_list():
            result += '<part '
            result += 'name=\"%s\" ' % part.name
            result += 'num=\"%s\" ' % part.part_id
            result += 'size_mb=\"%s\" ' % part.size_mb
            result += '/>\n'
        result += '</partition_table>\n'
        
        result += '</drive>'
        return result

    def get_info_status (self):
        print '%d %s' % (self.portnum, self.bus_num)


    def update_rvbd_superblock(self, appliance_serial):
        # do a retry on the superblock.  In the case of manufacturing,
        # we don't have the partitions set up until after the system is 
        # populated.
        #
        if self.superblock == None and self.managed() == False:
            self.read_superblock(wait_for_device = True)

        if self.managed() == False:
            if self.superblock != None:
                self.superblock.update_superblock (appliance_serial, 
                                                   self.portnum, 
                                                   self.__logical_port)
            else:
                raise rrdm_error ('Unable to update superblock for device /dev/disk%s' % self.portnum)

    # CAREFUL .. this command will repartition your drive
    # create a temp file in /tmp and use that for the master partition record
    #
    def partition_drive(self, 
                        clear_labels = True,
                        dry = False):
        try:
            name="/tmp/part_temp"
            tfile = open(name, "w+b")
            part_str = self.part_tbl.gen_disk_geom()
            tfile.write(part_str)
            tfile.close()

            rlog_debug ("Partition Table :")
            rlog_debug (part_str)
            rlog_debug ("End Partition Table")
        except IOError:
            raise rrdm_error ('Unable to open temp partition table file')

	if self.name == '':
	    raise rrdm_error ('Disk %s is missing' % self.portnum)

        if not self.licensed:
            raise rrdm_error ('Disk is not Riverbed branded, not adding to array')

        cmd_line = 'sfdisk -q -uM /dev/%s 2>&1 < %s > /dev/null' % (self.name, name)
        if dry:
            print cmd_line
        else:
            err = run_shell_cmd(cmd_line)
            if err:
                raise rrdm_error ('Failed to partition device /dev/%s' % self.devname)

        # when manufacturing we want to clear labels, but on running systems we do not
        # the clear_labels flag is passed from rrdm_tool when we're either
        # manufacturing or changing profiles.
        if clear_labels:
            self.clear_labels()

    ############################################################################
    # clear_labels
    #
    # During manufacturing it is necessary to clear the labels on disks, because 
    # repartitioning isnt guaranteed to do that and if a disk being inserted
    # is from an old machine, we may inadvertently get a duplicate label
    # which can cause the system to not boot.
    #
    ############################################################################
    def clear_labels(self):
        e2_cmd  = '/sbin/e2label'
        for part in self.part_tbl.get_partition_list():
            dev = '/dev/%s' % part.get_devname()
            cmd = '%s %s \"\"' % (e2_cmd, dev)

            if not exists (dev):
                rlog_info ('device %s does not exist' % dev)
            else:
                try:
                    run_shell_cmd (cmd)
                except rrdm_error, what:
                    # right now just trying on each partition to ensure that
                    # if it had ext3 data on it and a label, then
                    # we should clear it.
                    pass


#################################################################################
# PartitionTable
#
# Holder for the layout of partitions on disks for a given model.
# 
# Normally driven by config by passing in a dictionary of the parameters
# read from the xml config.
#
#################################################################################
class PartitionTable:
    def __init__(self, zone_cfg):
        self.partitions = []

        part_list = zone_cfg.get_layout().get_part_list()
        for part in part_list:
            p = Partition()
            # don't tie the partition table to a HD. callers will need to check
            # when we create the HD, and assign it a ptable, we'll fill the backlinks.
            # we need the ptable to fill in the disk, but need to the disk to fill the 
            # ptable
            p.make_partition (part.get_part_id(), part.get_part_size(zone_cfg), 
                              part.get_ptype(), None, part.get_name())

            self.partitions.append(p)

    def __str__(self):
        result = ''
        for p in self.partitions:
            result += '%s/name=%s\n' % (p.part_id, p.name)
        return result


    ###########################################################################
    # assign_disk
    #
    # attach this partition table to a particular disk.
    #
    ###########################################################################
    def assign_disk(self, hd):
        for part in self.partitions:
            part.assign_hd (hd)

    def get_num_partitions(self):
        return len(self.partitions)

    def get_partition_list(self):
        return self.partitions

    def printto(self):
        for part in self.partitions:
            part.printto()

    def find_partition_by_id(self, id):
        for part in self.partitions:
            if (part.part_id == id):
                return part
        return None

    def find_partition_by_name(self, name):
        for part in self.partitions:
            if part.name == name:
                return part
        return None

    # generates output usable by sfdisk to partition a drive
    # default units: sectors
    #
    def gen_disk_geom(self):
        start_pos=1
        part_str= []
        first_part = True

        for part in self.partitions:
            # handle the logical partition case.
            if part.size == "":
                size = 0
            else:
                size = int (part.size, 10)

            #part_str.append('/dev/disk%sp%s : start=%d, size=%d, Id=%s' % (part.hd.portnum, part.part_id, start_pos, size, part.type))
            if (part.type != '0f'):
                if first_part:
                    part_str.append(',%d,%s,*' % (size, part.type))
                    first_part = False
                else:
                    part_str.append(',%d,%s,' % (size, part.type))
            else:
                part_str.append(',,%s,' % part.type)

        return ''.join (["%s\n" % (str) for str in part_str])

## Container class for physical information about all disks in the system
#
class DiskArray:
    def __init__(self):
        self.drive_list=[]
        self.__num_drives       = 0
        self.__expected_drives  = 0
        self.__disk_members     = []

    type='JBOD'
    name='physical drive array'
    drive_list=[]

    ## string representation of the array
    def __str__(self):
        result = ''
        result += 'Drives : %d\n' % self.__num_drives
        result += 'Expected Drives : %d\n' % self.__expected_drives
        for disk in self.drive_list:
            result += str(disk)

        return result

    ## using the appliance spec read disk info from the system
    # @param spec the spec class for this appliance
    # @param mfg_mode indicates whether to ignore SB errors
    #
    # read disk array info from system, we only need to know how many drives we should have
    # and what their partition tables should be.
    #
    # in mfg mode we'll ignore lack of SB errors
    #
    def fill_from_system_info(self, spec, mfg_mode=False):
        self.__expected_drives = spec.get_disk_count()
        self.__disk_members   = spec.get_disk_members()

        self.__num_drives = hwtool_disk_map.get_num_hard_disk()

        for dev in self.__disk_members:
            # XXX add checking here to make sure this is a valid number
            hd = HardDisk()

            zone_cfg = spec.get_disk_zone_spec(dev)

            if spec.uses_layouts():
                part_tbl = PartitionTable(zone_cfg)
                hd.fill_from_system_info(dev, zone_cfg, part_tbl, mfg_mode)
                part_tbl.assign_disk(hd)
                self.drive_list.append(hd)


    ####### Object Access Methods ##############################################

    ## Returns a disk array with all the drives specified by id in disk_list
    # @param disk_list a list of drive id's which we want a disk array made of
    #
    # disks in disk_list that are not in this disk array are ignored.
    #
    def get_disk_array_slice(self, disk_list):
        # given a list of disk id's create a disk_array with only those disks 
        # populated.
        slice = DiskArray()
        for disk_id in disk_list:
            hd = self.find_drive_by_id(disk_id)

            if hd != None:
                slice.drive_list.append(hd)
            else:
                rlog_warning ('requested disk %d does not exist in disk_array' % disk_id)

        slice.__expected_drives = len(disk_list)
        slice.__num_drives      = len(slice.drive_list)

        return slice

    def get_expected_drives(self):
        return self.__expected_drives

    def get_num_drives(self):
        return self.__num_drives

    def get_drive_list(self):
        return self.drive_list

    ## update the member drive status based on the state of the arrays that live on the drives.
    # @param array list used to use when determining the disk status
    #
    # Disk status is by default online, then its state is updated based on what the state
    # of raid arrays is that live on that drive.
    #
    def update_status_by_zone(self, raid_arrays, ftraid_arrays):
        for hd in self.drive_list:
            hd.update_status_by_zone(raid_arrays, ftraid_arrays)

    def printto(self):
        for drive in self.drive_list:
            drive.printto()

    ##
    # be careful using this, a drive array may have different partition
    # tables on each drive.
    def find_drive_by_partition_name(self, name):
        found_drive = None
        for drive in self.drive_list:
            found_drive = drive.part_tbl.find_partition_by_name(name)
            if (found_drive != None):
                return found_drive

        return found_drive

    def find_drive_by_id(self, id):
        for drive in self.drive_list:
            if (drive.portnum == id):
                return drive
        return None

    def get_status(self, xml = False):
        for hd in self.drive_list:
            hd.get_status()

    def get_info_status(self):
        for hd in self.drive_list:
            hd.get_info_status()

    def get_detail_status(self, xml = False):
        if xml == True:
            print '<drive-array num_drives=\"%s\">' % self.__expected_drives
        else:
            print 'Num Drives : %s' % self.__expected_drives

        for hd in self.drive_list:
                hd.get_detail_status(xml)

        if xml == True:
            print '</drive-array>'

    def get_detail_part_status(self):
            print '<drive-array num_drives=\"%s\">' % self.__expected_drives
            for hd in self.drive_list:
                print hd.get_disk_part_status()
            print '</drive-array>'
        

