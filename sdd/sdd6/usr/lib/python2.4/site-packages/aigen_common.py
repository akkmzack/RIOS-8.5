#!/usr/bin/python

import getopt
from os.path import exists
from sys import exit, argv
from os import system, popen, remove, rmdir, mkdir, makedirs, WEXITSTATUS
from popen2 import Popen3
from time import sleep

############ CONSTANTS ############
PASSWD_FILE = '/var/etc/opt/tms/output/bootloader.passwd'


## print_log
# Print the log message to system logs
# @level -> "warn"|"info"|"notice"|"err"
# @message -> message to print to the logs
#
def print_log(level, message):
    system("/usr/bin/logger -p user.%s -t aigen %s" % (level, message))


## execute_hwtool_query
# @param -> the query argument to hwtool
#
# Depending on whether the machine is in manufacturing state or
# running RiOS, this function chooses the file paths for hwtool.py
# and config.xml
# It executes the hwtool query and returns the result in string format
#
def execute_hwtool_query(param):
    hwtool_path='/opt/hal/bin/hwtool.py'
    hwtool_mfg_path='/sbin/hwtool.py'
    config_path='/opt/tms/lib/hwtool/config/config.xml'
    config_mfg_path='/etc/config.xml'

    if not param or param == '':
        print_log("warn", "hwtool command missing the query parameter")
        return ''

    hwtool = None
    config = None

    # make sure we support both mfg mode hwtool and 
    # image mode hwtool paths.
    if exists(hwtool_path):
        hwtool=hwtool_path
    elif exists(hwtool_mfg_path):
        hwtool=hwtool_mfg_path

    if exists(config_path):
        config=config_path
    elif exists(config_mfg_path):
        config=config_mfg_path

    try:
        output = popen('%s -c %s -q %s' % (hwtool, config, param)).readline().strip()
    except Exception:
        print_log("warn", "hwtool returned error, output = [%s]" % output)
        output = ''

    return output


## check_password
# Check to see if the user has set a BIOS password
# if so, we need to set the global variable with the password
def check_password():
    password = ''
    if exists(PASSWD_FILE):
        try:
            password = popen('cat %s' % PASSWD_FILE).readline().strip()
        except Exception:
            print_log("warn", "Cannot read BIOS password file, output = [%s]" % password)
            password = ''
            pass

    return password


## get_prod_from_ver_string
# @ver -> version string
# Given the version string (from build_version.sh)
# find out what the product is
# return the product description
#
def get_prod_from_ver_string(ver):
    st = ver[4:7]
    if st == "sh ":
        return 'Steelhead'
    if st == "ex ":
        return 'SteelheadEX'
    elif st == 'cmc':
        return 'Central Management Console'
    elif st == 'ib ':
        return 'Interceptor'
    elif st == 'gw ':
        return 'Steelhead Mobile Controller'
    elif st == 'fg ':
        return 'Atlas Storage Appliance'
    elif st == 'bgl':
        return 'Beagle'
    elif st == 'dd ':
        return 'Atlas Data Appliance'
    elif st == 'eva':
        return 'Virtual Edge EVA'
    elif st == 'dva':
        return 'Virtual Edge DVA'
    elif st == 'cb ':
        return 'Whitewater'
    elif st == 'fwk':
        return 'Framework Development'
    else:
        return 'Error'


## supports_flash
# @param -> filename
# Checks the build file to see if the BUILD_FLASH_SUPPORT flag is set
# return True if supported else False
#
def supports_flash(filename):
    try:
        file = open(filename, 'r')
    except IOError:
        print "Could not open: %s" % filename
        return False

    flash = False
    while True:
        line = file.readline()[:-1]
        if line == 'BUILD_FLASH_SUPPORT="1"':
            flash = True
            break
        if line == "":
            break
    file.close()
    return flash


## vstring_to_arch
# @param -> version string line from the build file
# Returns the build arch type i386 or x86_64
#
def vstring_to_arch(ver_string):
    ret = ''
    try:
       ret = ver_string.split(" ")[5]
    except IndexError:
       print_log('warn', 'Unable to get arch')
       ret = ''

    return ret


## vstring_to_title
# @param -> version string line from the build file
# @param -> restore, if this title is for a restore partition
#           on a xx20 rev B box
# Returns the title string for the grub entry
#
def vstring_to_title(ver_string, restore = False):
    if ver_string == 'unknown version' or \
       ver_string == '':
        return ''

    arr = ver_string.split(" ")

    prod = get_prod_from_ver_string(ver_string)

    try:
        vers = arr[1]
    except IndexError:
        print_log('warn', 'Unable to get version')
        vers = ''

    arch = vstring_to_arch(ver_string)

    if arch == 'i386':
        bits = '32bit'
    elif arch == 'x86_64':
        bits = '64bit'

    pretty = 'Riverbed %s Software v. %s (%s)' % (prod, vers, bits)

    title = "title "
    if restore == True:
        title += "Restore: "
    title += pretty + '\n'

    return title


## get_ver_string
# @param -> build_version.sh file path
# @param -> if box in manufacturing or upgrade
# returns the version string of the current partition
#
def get_ver_string(filename, manufacturing):
    try:
        file = open(filename, 'r')
    except IOError:
        return 'unknown version'

    ver_string = 'unknown version'
    supports_cr = False
    # I really hate these checks
    supports_5050L = False
    supports_1050U = False
    supports_V150M = False
    supports_sv_on_var = False
    try:
        lines = file.readlines()
        file.close()
    except IOError:
        system("/usr/bin/logger -p user.warn -t aigen Could not read the build file")
        pass
    for line in lines:
        if line[:19] == "BUILD_PROD_VERSION=":
            ver_string = line[20:-1]
        if line[:20] == "BUILD_1050U_SUPPORT=":
            supports_1050U = True
        if line[:24] == "BUILD_1050RAIDUP_SUPPORT":
            supports_cr = True
        if line[:20] == "BUILD_5050L_SUPPORT=":
            supports_5050L = True
        if line[:20] == "BUILD_V150M_SUPPORT=":
            supports_V150M = True
        if line[:29] == "BUILD_8150_SV_ON_VAR_SUPPORT=":
            supports_sv_on_var = True

    if not supports_cr or not supports_5050L or not supports_sv_on_var or not supports_1050U or not supports_V150M:
        if not manufacturing:
            from appliance_util import get_appliance_model
            spec = get_appliance_model()
            if not supports_cr:
                if spec in ["1050_LR", "1050_MR", "1050_HR"]:
                    raise Exception("Unsafe boot target, aborting.")
            if not supports_1050U:
                if spec in ["1050U"]:
                    raise Exception("Unsafe boot target, aborting.")
            if not supports_5050L:
                if spec in ["5050L"]:
                    raise Exception("Unsafe boot target, aborting.")
            if not supports_V150M:
                if spec in ["V150M"]:
                    raise Exception("Unsafe boot target, aborting.")
            if not supports_sv_on_var:
                if spec in ["8150"]:
                    raise Exception("Cannot boot into partition due to secure vault incompatibility, aborting.")

    #need better checking for empty ver string
    return ver_string

