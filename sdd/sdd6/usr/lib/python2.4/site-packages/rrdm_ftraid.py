#!/usr/bin/env python

from sys import exit, argv
from re import compile as recompile
from os import remove, popen, stat, path, rename, listdir, mkdir
from os.path import exists, isdir
from popen2 import Popen4
from time import sleep
from rrdm_util import rrdm_error,HwtoolDriveList,run_shell_cmd,get_scsi_sysfs_param,get_sysfs_param, rlog_debug
from rrdm_util import *
from rrdm_disk import Partition
from rrdm_sysconfig import SystemConfig

try:
    from Logging import *
except ImportError:
    pass

## FtDiskPartitionStatus
# A fault tolerant disk partition (used for segstore in FTS mode)
# The status for a fts partition is maintained in a file on /config/disk
# since we don't have an API to query status of the drive from sport
# if the file exists, then the disk is failed/missing, and if it does not
# exist, then the drive is ok to be added to sport
class FtDiskPartitionStatus:
    # Status strings for the partition
    ftpart_status_online = 'online'
    ftpart_status_failed = 'failed'
    ftpart_status_missing = 'missing'

    ## Init Method
    # @param hd HardDisk object this partition resides on
    # @param part FtDiskPartition object associated with this status
    def __init__(self, 
                 hd, 
                 part):
        self.__hd   = hd
        self.__part = part
        self.__status = self.ftpart_status_missing
        
        self.__devname = part.dev_name
        
        # Location of the status file
        self.__cfg_status_dir  = '/config/disk'
        self.__cfg_status_name = '%s/disk%sp%s_failed' % ( \
                                  self.__cfg_status_dir, 
                                  hd.portnum, 
                                  part.part_id)

        self.__update_status()

    ## String method
    def __str__(self):
        result = ''
        result += 'name=%s\n' % self.__devname
        result += 'status=%s\n' % self.__status
        result += 'stat_file=%s\n' % self.__cfg_status_name
        return result
    
    ## __update_status
    # Wrapper for determining status of the partition
    def __update_status(self):
        if self.__hd.is_missing():
            self.__status = self.ftpart_status_missing
        else:
            if exists(self.__cfg_status_name):
                self.__status = self.ftpart_status_failed
            else:
                self.__status = self.ftpart_status_online

    ## fail
    # Touch the config file to indicate this partition is failed
    def fail(self):

        if not isdir(self.__cfg_status_dir):
            try:
                mkdir(self.__cfg_status_dir)
            except OSError:
                raise rrdm_error('Unable to create disk state directory %s' % \
                                 self.__cfg_status_dir)

        try:
            open(self.__cfg_status_name, "w").close()
        except IOError:
            raise rrdm_error ('Unable to create disk state file: %s' % \
                              self.__cfg_status_name)

    ## add
    # Remove the config file to indicate that this partition is now ok
    def add(self):
        if exists(self.__cfg_status_name):
            remove(self.__cfg_status_name)

    ## get_status
    # Return the partition status
    def get_status(self):
        return self.__status

## FtDiskPartition
# Class describing a partition belonging to a fault-tolerant segstore array
# 
class FtDiskPartition(Partition):
    ## Init Method
    # @param part_id partition num associated with this partition
    # @param hd HardDisk object on which this partition resides
    # @param lport Logical port of this device within the FtRaid (i.e 
    #              if the ftraid starts on disk 2, disk 2 has a lport of 0)
    def __init__(self, 
                 part_id,
                 hd,
                 lport):
        Partition.__init__(self)
        self.make_partition(part_id, '0', 'fts', hd)

        self.__ftraid_array     = None
        self.__logical_port     = lport
        self.__hd               = hd
        self.serialnum          = hd.serialnum
        self.__ftdrive_status   = FtDiskPartitionStatus(hd, self)

    ## String Method
    def __str__(self):
        result = ''
        result += '%s/status=%s\n' % ( \
                    self.__logical_port,
                    self.get_state())
        result += '%s/phys_port=%s\n' % (self.__logical_port,
                                         self.__hd.portnum)
        return result

    ## get_logical_port
    # Return the logical port of this partition within the FtRaidArray
    def get_logical_port(self):
        return self.__logical_port

    ## get_state
    # return the status associated with this partition
    def get_state(self):
        return self.__ftdrive_status.get_status()

    ## get_status
    # Return the logical port/status of this partition
    def get_status(self, xml = False):
        if xml:
            print '<ftraid-drive port=%s status=%s/>' % (self.__logical_port,
                                                         self.get_state())
        else:
            print '%s %s' % (self.__logical_port, self.get_state())

    ## is_on_hd
    # @param phys_port string id for the physical port of the disk
    # Returns True if the partition resides on the given drive
    def is_on_hd(self, phys_port):
        if self.__hd.portnum == phys_port:
            return True
        else:
            return False

    ## get_drive_num
    # Returns the physical disk number this FtDiskPartition resides on
    def get_drive_num(self):
        return self.__hd.portnum

    ## is_on_logical_port
    # @param logical_port string id for the logical port within the array
    # Returns True if the partition resides on the given logical port of the 
    # array
    def is_on_logical_port(self, logical_port):
        if self.__logical_port == logical_port:
            return True
        else:
            return False

    ## fail
    # Force the partition status to failed
    def fail(self):
        self.__ftdrive_status.fail()

    ## add
    # Force the partition status to online
    def add(self):
        self.__ftdrive_status.add()


## FtRaidArray
# An FtRaidArray is just a fancy term for a riverbed designed striping
# mechanism that plays well with sports data usage and data reliability
# This class maintains a list of partitions that are members of the array
# as well as maintaining status on the array/devices
class FtRaidArray:
    # Init Method
    # @param device_list DeviceList object this array resides on
    # @param name Name of the array
    # @param size_mb  Size of each disk in MB
    def __init__(self,
                 device_list,
                 name):
        self.__part_list = []
        self.__device_list  = device_list
        self.__name         = name
        self.__ftpart_array = []

        self.__num_drives   = self.__device_list.get_expected_drives()

        expected_part_size = 0
        for device in self.__device_list.get_devices():
            if expected_part_size == 0:
                expected_part_size = device.size_mb

            if expected_part_size != device.size_mb:
                # all ftraid device elements should be the same size
                raise AssertionError('Invalid FtRaidArray, device elements' \
                                     ' have different configured sizes' \
                                     ' expected:%d devsize:%d' % \
                                     (expected_part_size,
                                      device.size_mb))
            ftpart = FtDiskPartition(part_id = device.part_id,
                                     hd = device.hd,
                                     lport = device.hd.get_logical_port())
            self.__ftpart_array.append(ftpart)

        self.__per_disk_size = expected_part_size

    ## String Method
    def __str__(self):
        result = ''
        result += '/ftraid/%s/num_disks=%d\n' % (self.__name, self.__num_drives)
        for ftpart in self.__ftpart_array:
            for line in str(ftpart).split('\n'):
                if line != '':
                    result += '/ftraid/%s/%s\n' % (self.__name, line)
        return result
        
    ## is_disk_in_array
    # @param drive_num drive number of a system disk
    # Returns True if the system drive_num is part of this array
    def is_disk_in_array(self, drive_num):
        return self.__device_list.is_disk_in_devlist(drive_num)

    ## get_name
    # Returns the name of the array
    def get_name(self):
        return self.__name

    ## get_status
    # prints the status of the array (used for rrdm_tool.py -s queries)
    def get_status(self, xml=False):
	if xml:
            print '<ftraid-array name=\"%s\" status=\"%s\"/>' % \
                  (self.get_name(), self.get_state())
        else:
            print '%s %s' % (self.get_name(), self.get_state())

    def get_detail_status(self, xml=False):
        if xml:
            print '<ftraid-array name=\"%s\" status=\"%s\">' % \
                  (self.get_name(), self.get_state())
            for ftpart in self.__ftpart_array:
                print '<ftraid-drive port=\"%s\" drive=\"%s\" part=\"%s\" status=\"%s\"/>' % \
			(ftpart.get_logical_port(), 
			 ftpart.get_drive_num(),
			 ftpart.part_id,
                         ftpart.get_state())
            print '</ftraid-array>'
	else:
            for ftpart in self.__ftpart_array:
                print '%s %s' % (ftpart.get_logical_port(), 
                                 ftpart.get_state())

    ## find_dev_by_physical_port
    # @param phys_port system drive number
    # Returns a FtDiskPartition associated with a given physical port, or None
    # if the requested port is not part of the array
    def find_dev_by_physical_port(self, phys_port):
        for ftpart in self.__ftpart_array:
            if ftpart.is_on_hd(phys_port):
                return ftpart

        return None

    ## find_dev_by_hd
    # @param hd HardDisk object
    # Returns a FtDiskPartition associated with a given HardDisk object, or None
    # if the requested port is not part of the array
    def find_dev_by_hd(self, hd):
        return self.find_dev_by_physical_port(hd.portnum)

    ## find_dev_by_logical_port
    # @param log_port Logical port number of the array
    # Returns the FtDiskPartition object associated with a given logical
    # drive in the array, or None, if the logical drive does not exist
    def find_dev_by_logical_port(self, log_port):
        for ftpart in self.__ftpart_array:
            if ftpart.is_on_logical_port(log_port):
                return ftpart
        return None

    ## get_state
    # returns the state of an ftraid array.  The states can either be
    # online (all disks health), or degraded if one or more disks are missing
    # / failed.
    def get_state(self):
        for ftpart in self.__ftpart_array:
            if ftpart.get_state() != FtDiskPartitionStatus.ftpart_status_online:
                return 'degraded'

        return 'online'
       

    ## get_drive_status
    # @param hd HardDisk object
    # Return the status of the FtDiskPartition on a given system disk
    # or None, if the device is not part of the FtRaidArray
    def get_drive_status(self, hd):
        dev = self.find_dev_by_hd(hd)
        if dev != None:
            return dev.get_state()
        else:
            return None

    ## get_cfg_size
    # Return the configuration driven size of the volume
    # For example, if we are supposed to have 10 disks at 100G each,
    # this will say 1000000M. (units are in MB). This is purely driven
    # by the config file, and as such, if drives are missing, will not change.
    def get_cfg_size(self):
        return self.__per_disk_size * self.__num_drives
        
