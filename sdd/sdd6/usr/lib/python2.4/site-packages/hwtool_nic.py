#!/usr/bin/python

from os import listdir
from os.path import isfile
from re import compile as recompile
from re import sub
from sys import exit
from hwtool_util import *
from hwconfig import Pci_link
from VmxUtils import *

BOB_VMX = "/tmp/BOB.vmx"
VMX_CLIENT = "/sbin/vmx_client"

##############################################################
# NIC, container class for NIC information in the system
##############################################################

class NIC:
    """NIC part information 
    """

    def __init__(self, mobo):
        self.mobo = mobo


    def _walk(self, root_dir, pref = ''):
        dir = listdir(root_dir)
        ret = []
        for f in dir:
            if f[:5] == '0000:':
                sd = self._walk(root_dir + f + '/', pref + f + '/')
                if len(sd) > 0:
                    for i in sd:
                        ret.append(i)
                else:
                    ret.append(pref + f)
        return ret


    def _read_strip(self, path):
        fd = open(path)
        ret = fd.readline().strip()
        fd.close()
        return ret


    def _read_id(self, path):
        return self._read_strip(path)[2:]


    def _gen_pci_tup(self, root_dir, path):
        subvend = self._read_id(root_dir + path + '/subsystem_vendor')
        subid = self._read_id(root_dir + path + '/subsystem_device')
        mem = self._read_id(root_dir + path + '/resource')
        if subvend == '0000':
            return ''

        mem = mem.split(' ')[0]

        dirs = path.split('/')
        busid = dirs[len(dirs)-1][5:]
        busid_match = ''

        for d in dirs:
            busid_match += d[8:] + ':'
        busid_match = busid_match[:-1]

        return (subvend, subid, busid_match, busid, mem)


    def get_card_from_link(self, nics, cards, link):
        for n in nics:
            for k in n.name_keys:
                if k == link.pci_subid:
                    return n

        for c in cards:
            for ks in c.name_keys:
                nm = ks.split()
                if len(nm) >= 2:
                    k = nm[0]
                    l = nm[1]
                else:
                    k = nm[0]
                    l = None
            if k == link.pci_subid or l == link.pci_subid:
                return c


        return None


    def _get_nic_card_from_link(self, nics, link):
        for n in nics:
            for k in n.name_keys:
                if k == link.pci_subid:
                    return n


    def get_links_from_pattern(self, pat, links):
        pattern = recompile('^'+pat.upper())

        ret = []
        for l in links:
            if pattern.search(l.tnv_string.upper()):
                ret.append(l)

        return ret


    def _get_nic_brand_str(self, interface, offset):
        output = ethtool(arg = '-e %s offset %s length 0x14' % (interface, offset))
        #Parse output, I dont like this at all
        secret = ''
        for n in range(2, 4):
            line = output[n]
            line = line.split('\t')
            line = line[2].replace(' ', '')
            secret += line

        return secret[0:40]

    @staticmethod
    def valid_brand_string(bstr):
        if compareSecretStr(bstr):
            print "true"
        else:
            print "false"

    def _print_rename_pairs(self, card, links, map, 
                            slot, out_file, gateway_naming = False, 
                            quiet_print=False):

        brand_support = self.mobo.branding
        # This flag is used to indicate unbranded hardware found in system
        unbranded_found = False
        ln = len(links)
        if not hasattr(card, 'ordering'):
            return
        if ln % 2 != 0:
            return

        iter = range(ln)
        orders = card.ordering.split(':')
        for ord in orders:
            if ord == "descending":
                iter.reverse()
            elif ord == "ascending":
                pass
            else:
                lst = ord.split(',')
                if ln != len(lst):
                    continue
                ct = 0
                for idx in lst:
                    ct += 1
                    if ct > ln:
                        break
                    iter[ct-1] = int(idx)

        if gateway_naming:
            prefix = 'eth'
        else:
            if card.if_naming != 'hp':
                prefix = 'lan'
            else:
                prefix = 'eth'

        if card.if_naming == 'hp':
            nic = 1
        else:
            nic = 0
        for i in iter:
            for a in map:
                if links[i].memory_base == a[2]:
                    if gateway_naming:
                        pnic = nic
                    else:
                        pnic = nic/2

                    if card.if_naming == 'hp':
                        interface = "%s%d" % (prefix, nic)
                    else:
                        interface = "%s%d_%d" % (prefix,slot,pnic)
                    if "true" == brand_support:
                        # Skip check for onboard NIC's
                        if 'Integrated' != card.part_num:
                            if '' != card.ethtool_offset:
                                if not compareSecretStr(self._get_nic_brand_str(a[0], card.ethtool_offset)):
                                    unbranded_found = True
                                    # Remove interface from mapping so that its not printed
                                    map.remove(a)
                                    continue

                    if not quiet_print:
                        print >>out_file, "%s" % (interface), a[1]
                    if not card.if_naming == 'hp':
                        if prefix == 'lan':
                            prefix = 'wan'
                        elif prefix == 'wan':
                            prefix = 'lan'
            nic += 1

        return unbranded_found

    def get_bob_nic_info(self, nics, slot, query):
        try:
            device_info = vmwarerpctool('\'info-get guestinfo.slotcard\' 2>/dev/null')[0]
            slot_no     = vmwarerpctool('\'info-get guestinfo.slot\' 2>/dev/null')[0]
        except HwtoolError:
            # This means there is no passthru slot
            # no need to do any further processing
            return 

        card = self.get_card_from_device_and_vendor(nics, device_info)
        if slot == slot_no:
            if query == 'if_util':
                print "%s" % (card.utility)
            elif query == 'if_type':
                print "%s" % (card.wdt_type)
            elif query == 'if_part_num':
                print "%s" % (card.part_num)
            elif query == 'if_block':
                print "%s" % (card.block)
            else:
                print "Unknown query"
        else:
            # No card in this slot so return
            return



    def get_nic_info(self, nics, slot, query):
        links = self.make_pci_links()

        ct = 0
        for (n, s) in self.mobo.slot_patterns:
            try:
                l = self.get_links_from_pattern(s, links)
                if l != []:
                    card = self._get_nic_card_from_link(nics, l[0])
                    if slot == n:
                        if query == 'if_util':
                            print "%s" % (card.utility)
                        elif query == 'if_type':
                            print "%s" % (card.wdt_type)
                        elif query == 'if_part_num':
                            print "%s" % (card.part_num)
                        elif query == 'if_block':
                            print "%s" % (card.block)
                        else:
                            print "Unknown query"
            except AttributeError:
                continue
            ct += 1


    def get_bob_card_list(self, nics, cards):
	# First figure out if this is bluedell or redfin 1U or redfin 2 U
	# and then assign range_max as 1, 3 and 5 respectively
	part_num = self.mobo.part_num
	type = self.mobo.type
	if part_num == '425-00135-01':
            range_max = 1;
	elif part_num == '425-00205-01':
	    if type  == '1U_LSI':
	        range_max = 3;
  	    elif type == '2U_LSI':
	        range_max = 5;
  	    elif type == '2U25_LSI':
	        range_max = 5;
	    else:
		print "Error: Redfin MOBO not recognized"
	else:
	    print "Error: MOBO not recognized"
	    return	
	
	try:
            device_info = vmwarerpctool('\'info-get guestinfo.slotcard\' 2>/dev/null')[0]
            slot_no     = vmwarerpctool('\'info-get guestinfo.slot\' 2>/dev/null')[0]
        except HwtoolError:
            # This means there is no passthru slot
            # no need to do any further processing
            return

	card = self.get_card_from_device_and_vendor(nics, device_info)
	if card == None:
            part_num = "Unknown"
	else:
            part_num = card.part_num

	for i in range(0,range_max):
	    if i == int(slot_no):
		print "%s %s" % (i, part_num)
            else:
		print "%s missing" % i	


    def get_card_list(self, nics, cards):
        links = self.make_pci_links()

        for (n, s) in self.mobo.slot_patterns:
            l = self.get_links_from_pattern(s, links)
            if l != []:
                card = self.get_card_from_link(nics, cards, l[0])
                if card == None:
                    part_num = "Unknown"
                else:
                    part_num = card.part_num

                print "%s %s" % (n, part_num)
            else:
                print "%s missing" % n


    def has_card(self, nics, cards, arg):
        """Given arg (a regex) return True if the card is in any slot in
        the system, or False otherwise
        """
        creg = recompile(arg)
        has_card = False

        links = self.make_pci_links()

        for (n, s) in self.mobo.slot_patterns:
            l = self.get_links_from_pattern(s, links)
            if l != []:
                card = self.get_card_from_link(nics, cards, l[0])
                if card == None:
                    part_num = "Unknown"
                else:
                    part_num = card.part_num

                if creg.match(part_num):
                    has_card = True
                    break

        return has_card


    def get_nic_card(self, nics, cards):
        links = self.make_pci_links()

        ct = 0
        for (n, s) in self.mobo.slot_patterns:
            try:
                l = self.get_links_from_pattern(s, links)
                if l != []:
                    card = self.get_card_from_link(nics, cards, l[0])
                    print "%s, %s, %s, %s, %s" % (n,
                                               card.utility,
                                               card.block,
                                               card.part_num,
                                               card.wdt_type)
            except AttributeError:
                continue
            ct += 1


    def make_pci_links(self):
        links = []

        device_root = '/sys/devices/'
        prelinks = []
        bases = []
        trees = {}

        for dir in listdir (device_root):
            if dir[:8] == 'pci0000:':
                bases.append(dir)

        for base in bases:
            trees[base] = self._walk(device_root+base+'/')
            trees[base].reverse() #get the tree in the order we're expecting.

        for base in bases:
            ct = 0
            for pl in trees[base]:
                pl = base + '/' + pl
                trees[base][ct] = pl
                ct += 1
            prelinks.extend(trees[base])
        base_len = len(bases)

        for node in prelinks:
            fail = self._gen_pci_tup(device_root, node)
            if fail == '':
                continue
            (vend, id, match, str, mem) = fail
            link = Pci_link()
            link.pci_subid = vend+':'+id
            if base_len == 2:
                link.tnv_string = match
            else:
                link.tnv_string = match[3:]
            link.memory_base = mem
            links.append(link)

        return links


    ## get_card_from_device_and_vendor
    #
    # @nics list of all the NIC we know about
    # @param subdevice ID, subvendor ID of the passthru device
    #
    # pass in the device ID and the vendor ID string and get the card information
    # note that the card has to be a NIC card or else skip it
    def get_card_from_device_and_vendor(self, nics, nicid):
        for n in nics:
            for k in n.name_keys:
                if nicid == k:
                    return n


    ## _print_bob_passthru_pairs
    #
    # @param card that we need to name the interfaces for
    # @param pairs interface information for each NIC that is unnamed
    # @param slot number where the card is inserted
    # @param out_file where the mactab output is redirected
    #
    # This will give the interfaces names for mactab if they are unnamed
    def _print_bob_passthru_pairs(self, card, pairs, slot, out_file):
        brand_support = self.mobo.branding
        # This flag is used to indicate unbranded hardware found in system
        unbranded_found = False
        iter = pairs.keys()
        ln = len(iter)
        if not hasattr(card, 'ordering'):
            return
        if ln % 2 != 0:
            return

        iter.sort()
        if card.guest_order != None and card.guest_order != '':
            ord = card.guest_order
        else:
            ord = card.ordering

        if ord == "descending":
            iter.reverse()
        elif ord == "ascending":
            pass

        prefix = 'lan'
        nic = 0
        for i in iter:
            nicinfo = pairs[i]
            pnic = nic/2

            interface = "%s%s_%d" % (prefix, slot, pnic)
            if "true" == brand_support:
                if '' != card.ethtool_offset:
                    if not compareSecretStr(self._get_nic_brand_str(nicinfo[0], card.ethtool_offset)):
                        unbranded_found = True
                        continue

            print >>out_file, "%s" % (interface), nicinfo[1]
            if prefix == 'lan':
                prefix = 'wan'
            elif prefix == 'wan':
                prefix = 'lan'
            nic += 1

        return unbranded_found


    ## get_bob_mactab
    #
    # @param list of all the NIC cards we know about
    # @param filename where the MAC output needs to be printed
    #
    # Get the interface to MAC mapping for all BOB boxes
    # This will read the VMX file from the host and parse it
    # based on the MAC's in the VMX file apply the name
    #
    def get_bob_mactab(self, nics, out_path):
        out_file = None
        if out_path != '':
            out_file = open(out_path, 'w')
        # This is the first attempt to get the mactab, read the 
        # VMX file
        if not isfile(BOB_VMX):
            try:
                vmx_client()
            except HwtoolError:
                print "Could not get the VMX file in the guest"
                exit(1)

        # These are the ifaces that are already named via VMX file
        # For passthru NIC naming, we need to skip all the named NIC's
        named_ifaces = {}

        pvf = ParseVMXFile(BOB_VMX);
        pnics = pvf.get_nic()
        p_nic_keys = pnics.keys()
        for p in p_nic_keys:
            if pnics[p].name() != "":
                # These are RSP NICS, to get the name of the interface
                # get the FilterParam value
                print >>out_file, pnics[p].param0().replace('"', ''), pnics[p].generatedAddress().replace('"', '').upper()
                named_ifaces[pnics[p].generatedAddress().replace('"', '').upper()] = 1
            else:
                # These are the NON RSP NICS
                # For primary, aux, hpn, get rid of the 'vm' suffix
                ifacename = pnics[p].networkName().replace('"', '')
                if ifacename == 'primaryvm' or ifacename == 'auxvm':
                    ifacename = re.sub(recompile('vm$'), "", ifacename)
                    print >>out_file, ifacename, pnics[p].address().replace('"', '').upper()
                    named_ifaces[pnics[p].address().replace('"', '').upper()] = 1
                elif ifacename == 'hpnvm':
                    ifacename = re.sub(recompile('vm$'), "", ifacename)
                    print >>out_file, ifacename, pnics[p].generatedAddress().replace('"', '').upper()
                    named_ifaces[pnics[p].generatedAddress().replace('"', '').upper()] = 1
                else:
                    print >>out_file, ifacename, pnics[p].generatedAddress().replace('"', '').upper()
                    named_ifaces[pnics[p].generatedAddress().replace('"', '').upper()] = 1

        try:
            device_info = vmwarerpctool('\'info-get guestinfo.slotcard\' 2>/dev/null')[0]
            slot_no     = vmwarerpctool('\'info-get guestinfo.slot\' 2>/dev/null')[0]
        except HwtoolError:
            # This means there is no passthru slot
            # no need to do any further processing
            return 

        # This dict will be used if the pairs aren't named as yet
        # We will need more information to do the naming
        pairs = {}

        # This list will be used if the ifaces are already named
        # If will use the name and MAC and just display the interface
        named_pairs = []

        ifaces = recompile("^eth[\d]+|^[l|w]an\d_\d")

        # This flag indicates that the passthru NIC is not named
        # and we need to rename the pairs
        passthru_is_unnamed = False
        dir_list = listdir('/sys/class/net/')
        dir_list.sort()
        for nicname in dir_list:
            if ifaces.search(nicname):
               mac = self._read_strip("/sys/class/net/" + nicname + "/address").upper()
               bar0 = self._read_id("/sys/class/net/" + nicname +
                              "/device/resource").split(' ')[0]
               device = self._read_strip("/sys/class/net/" + nicname + "/device/device")
               vendor = self._read_strip("/sys/class/net/" + nicname + "/device/vendor")

               if not named_ifaces.has_key(mac):
                   if nicname[0:3] == 'eth':
                       pairs[int(nicname[3:])] = [ nicname, mac, bar0, device, vendor ]
                       passthru_is_unnamed = True
                   else:
                       named_pairs.append([nicname, mac])

        passthru_nic = self.get_card_from_device_and_vendor(nics, device_info)
        if passthru_is_unnamed:
            self._print_bob_passthru_pairs(passthru_nic, pairs, slot_no, out_file)
        else:
            # XXX/munirb: Do not change the order of allowed_ifaces
            # it is used to control the output
            # lan/wan interfaces need to be added as well, from XanY_0 .. XanY_2
            # (for 6 port copper if ever used)
            
            allowed_ifaces = [ z + 'an' + str(x)+ '_' + str(y) for z in ['l', 'w'] for x in range(6) for y in range(3) ]
            for ifname in allowed_ifaces:
                for nic in named_pairs:
                    if ifname == nic[0]:
                        print >>out_file, nic[0], nic[1]


    def get_address_map(self, nics, cards, gateway_naming = False, return_map = False, get_branding = False):
        ifc = ifconfig(arg = "-a")

        # This flag is to check if the prihw interface is present or not
        # For non SH and IB appliances the prihw interface won't be present 
        # if the flag is not set, no need to rename primary for sysfs nodes
        # XXX/munirb: Bug 68779
        has_prihw = True
        if not exists('/sys/class/net/prihw'):
            has_prihw = False

        nic_brand_state = True
        pairs = []

        link = recompile("Link") 
        if gateway_naming:
            ifaces = recompile("primary|aux|eth[\d]+|[l|w]an\d_\d")
        else:
            ifaces = recompile("prihw|primary|aux|eth[\d]+|[l|w]an\d_\d")

        for l in ifc:
            if link.search(l, 1):
                if ifaces.search(l):
                    nm = l.split()[0]
                    virt_name = nm
                    # In canary we have a primary interface and a prihw interface
                    # both share the same MAC, primary is a virtual interface
                    # while prihw is the real interface
                    # The easiest fix is to replace the 'primary' with 'prihw' to 
                    # get all the sysfs information, but for printing purpose
                    # use 'primary'. This is a bit different to samoa, the address_map
                    # query will print primary instead of prihw, but since no one
                    # uses that query, we should not have any issues.
                    if virt_name == 'primary' and has_prihw:
                        virt_name = 'prihw'
                    elif virt_name == 'prihw':
                        # Skip this interface as we don't
                        # want to duplicate entries
                        continue
                    mac = self._read_strip("/sys/class/net/" + virt_name + "/address").upper();
                    bar0 = self._read_id("/sys/class/net/" + virt_name +
                                   "/device/resource").split(' ')[0];

                    pairs.append( [ nm, mac, bar0 ] )

        pci_links = self.make_pci_links()
        ob_links = self.get_links_from_pattern(self.mobo.onboard_pattern, pci_links)

        ifaces = {}
        iface_arr = []
        for iface in pairs:
            ifaces[iface[0]] = 1

        for (n, s) in self.mobo.slot_patterns:
            l = self.get_links_from_pattern(s, pci_links)

            if l != []:
                card = self.get_card_from_link(nics, cards, l[0])
                if self._print_rename_pairs(card, l, pairs, int(n), None, gateway_naming, True):
                    nic_brand_state = False

        #need to sort pairs into the correct order
        if return_map:
            return [pairs, nic_brand_state]
        else:
            # XXX/munirb: Do not change the order of allowed_ifaces
            # it is used to control the output

            # interface name can be eth0 .. eth39 max at mfg prompt
            allowed_ifaces = [ 'eth' + str(x) for x in range(40) ]
            # Append primary, aux and prihw
            allowed_ifaces.extend(['primary', 'aux', 'prihw'])
            # lan/wan interfaces need to be added as well, from XanY_0 .. XanY_2
            # (for 6 port copper if ever used)
            allowed_ifaces.extend([ z + 'an' + str(x)+ '_' + str(y) for z in ['l', 'w'] for x in range(6) for y in range(3) ])
            # For corsica which names interfaces ethX_Y
            allowed_ifaces.extend([ 'eth' + str(x)+ '_' + str(y) for x in range(6) for y in range(6) ])
            for name in allowed_ifaces:
                for pair in pairs:
                    if pair[0] == name:
                        if get_branding:
                            if ifaces.has_key(name):
                                iface_arr.append([name, 'Licensed'])
                                # Remove this iterface from the original map
                                # Remaining interfaces are unbranded
                                del ifaces[name]
                        else:
                            print "%s %s" % (pair[2], pair[0])

        if get_branding:
            for name in ifaces.keys():
                iface_arr.append([name, 'Unlicensed'])
            return iface_arr


    def get_mactab(self, nics, cards, out_path, gateway_naming):
        out_file = None
        if out_path != '':
            out_file = open(out_path, 'w')

        pci_links = self.make_pci_links()
        # XXX:munir: Dump this to debug the PCI bus patterns. Easiest way
        # I found to figure interface patterns
        #for p in pci_links:
        #    p.printo()

        ob_links = self.get_links_from_pattern(self.mobo.onboard_pattern, pci_links)
        if len(ob_links) == 0:
            ifc = ifconfig(arg = "-a")
            link = recompile("Link")
            for l in ifc:
                lk = link.search(l, 1)
                if lk:
                    parts = l.split()
                    if len(parts) > 4:
                        print >>out_file, 'primary', parts[4]
            return

        if self.mobo.num_ifs == 2:
            if self.mobo.primary_first:
                primary = ob_links[0]
                aux = ob_links[1]
            else:
                primary = ob_links[1]
                aux = ob_links[0]

            dev_map_list = [{'device':primary, 'name':'primary'},
                            {'device':aux, 'name':'aux'}]
        
        else:
            # we only have primary no aux
            primary = ob_links[0]
            dev_map_list = [{'device':primary, 'name':'primary'}]

        (map, nic_brand_state) = self.get_address_map(nics, cards, gateway_naming, return_map = True, get_branding = False)

        for a in map:
            for nic in dev_map_list:
                if nic['device'].memory_base == a[2]:
                    print >>out_file, nic['name'], a[1]

        if self.mobo.part_num == "VM":
            self.get_mactab_vm_slots(nics, cards, pci_links, map, out_file, gateway_naming)
            return

        for (n, s) in self.mobo.slot_patterns:
            l = self.get_links_from_pattern(s, pci_links)
            if l != []:
                card = self.get_card_from_link(nics, cards, l[0])

                self._print_rename_pairs(card, l, map, int(n), out_file, gateway_naming, False)

    def get_mactab_vm_slots(self, nics, cards, pci_links, map, out_file, gateway_naming):
        # made separate for vm's due to bug#102052
        # ESXi, afaik, doesn't guarantee that guest network
        # adaptors will land on the same pci slot after any changes to
        # the network adaptors.  For VSH bypass, where a card is added
        # either for bypass management, and afterwards, more pairs
        # of cards may be added for upgrades, we have to be careful
        # about handling an odd number of cards.

        # map is a list of (ifname, mac address, memory base) tuples
        # get_address_map builds this by scanning all the nics
        # EXCEPT any that doesnt match an expected name (primary,aux,eth, etc.)
        # so if there's a pci link whose memory_base can't be found
        # in map, it means that get_address_map excluded that interface.
        # vsh_silicom_bypass_init.py renames the bypass management
        # interface to 'bpvm0', so it shouldn't be in here.
        relevant_mem_bases = set([ a[2] for a in map ])

        stash_link = None
        stash_slot = None
        for (slot, s) in self.mobo.slot_patterns:
            # filter out bpvm0 or other ifaces not in map
            links = [ l for l in self.get_links_from_pattern(s, pci_links)
                        if l.memory_base in relevant_mem_bases ]
            if stash_link:
                # We had a lone link from last time; try
                # to use that and its slot number this time.
                # We keep the slot number so that someone
                # that adds/removes a vsh bypass bpvm interface
                # shouldn't notice any changes in which interfaces
                # belong to their inpaths
                links.insert(0, stash_link)
                slot = stash_slot
                stash_link = None
                stash_slot = None
            if len(links) % 2 == 1:
                # our peer in this slot was excluded by the 
                # relevant_mem_base check.  To keep the expected
                # slot numbers the same, stash the slot along
                # with the link.
                stash_link = links[-1]
                stash_slot = slot
                links = links[:-1]
            if not links:
                continue

            card = self.get_card_from_link(nics, cards, links[0])

            self._print_rename_pairs(card, links, map, int(slot), out_file, gateway_naming, False)

