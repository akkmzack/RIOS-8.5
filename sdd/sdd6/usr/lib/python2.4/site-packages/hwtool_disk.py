#!/usr/bin/python
from os import listdir
from os.path import exists
from hwtool_util import *
from re import compile as recompile
import glob

##############################################################
# Disk, container class for Disk information in the system
##############################################################
class Disk:
    def __init__(self, bus):
        self.__vendor = get_sysfs_param('/sys/bus/scsi/devices/%s/vendor' % bus)
        self.__model = get_sysfs_param('/sys/bus/scsi/devices/%s/model' % bus)
        self.__devname = get_sysfs_param('/sys/bus/scsi/devices/%s/device_name' % bus)
        self.__state = get_sysfs_param('/sys/bus/scsi/devices/%s/state' % bus)
        self.__bus = bus

        # Do not fill in this by default cause it is a ioctl call 
        # and we dont want to do that every few seconds
        self.__serial = ''
        self.__fw = ''
        
    def get_diskinfo(self):
        """This call will fill out the disk serial number and firmware version
        this is an ioctl call so please use sparingly
        """
        (self.__serial, self.__fw) = get_disk_info('/dev/%s' % self.devname)[0].split(' ')

    def printo(self):
        """Pretty printing for all the disk information
        """
        print "Device Name: %s, Bus: %s, Serial: %s, FW version: %s, Vendor: %s, Model: %s, State: %s" % (self.__devname
            , self.__bus, self.__serial, self.__fw, self.__vendor, self.__model, self.__state)


##############################################################
# Disks, container class for all the Disks in the system
##############################################################
class Disks:
    def __init__(self, mobo):
        self.__size = []
        self.__branded = []
        self.__sysmobo = mobo
        self.__disk_list = {}
        self.__map = ''
        self.__unlicensed = ''
        self.__quantity = ''

        ## Sturgeon Disk Map Info
        #
        # The procfs phys_drive_info has 2 bytes of output the first is the 
        # expander port, and the second is the target offset within that 
        # expander
        #
        # on sturgeon units, the first expander 
        # shows up on port 0, the second on port 4.
        # the drive offsets are linear with each expander having 8 drives.
        #
        self.sturgeon_disk_map = { 
                                  0x0000:0,
                                  0x0001:1,
                                  0x0002:2,
                                  0x0003:3,
                                  0x0004:4,
                                  0x0005:5,
                                  0x0006:6,
                                  0x0007:7,
                                  0x0400:8,
                                  0x0401:9,
                                  0x0402:10,
                                  0x0403:11,
                                  0x0404:12,
                                  0x0405:13,
                                  0x0406:14,
                                  0x0407:15
                                 }
        self.dell_disk_map = {
                                  0x0006:0,
                                  0x0004:1,
                                  0x0002:2,
                                  0x0007:3,
                                  0x0005:4,
                                  0x0003:5,
                                 }

        # RF 1U LSI
        self.rf_1u_lsi_disk_map = {
                                  0x0000:0,
                                  0x0001:1,
                                  0x0002:2,
                                  0x0003:3 
                                 }

        self.rf_2u_lsi_disk_map = {
                                  0x0000:0,
                                  0x0003:1,
                                  0x0006:2,
                                  0x0009:3,
                                  0x0001:4,
                                  0x0004:5,
                                  0x0007:6,
                                  0x000a:7, 
                                  0x0002:8,
                                  0x0005:9,
                                  0x0008:10,
                                  0x000b:11
                                 }

        self.rf_25u_lsi_disk_map = {
                                  0x0004:0,
                                  0x0005:1,
                                  0x0006:2,
                                  0x0007:3,
                                  0x0008:4,
                                  0x0009:5,
                                  0x000a:6,
                                  0x000b:7, 
                                  0x000c:8,
                                  0x000d:9,
                                  0x000e:10,
                                  0x000f:11,
                                  0x001a:12,
                                  0x001b:13,
                                  0x0012:14,
                                  0x0013:15,
                                  0x0014:16,
                                  0x0018:17,
                                  0x0017:18,
                                  0x0016:19,
                                  0x0015:20,
                                  0x0019:21,
                                  0x0010:22,
                                  0x0011:23
                                 }

        ## Gar Disk Map Info
        #
        # The procfs phys_drive_info has 2 bytes of output the first is the 
        # expander port, and the second is the target offset within that 
        # expander
        #
        #
        # On Gar units, the disk mapping to between expander and port is more 
        # complicated, and we tabled it, since its confusing. Refer to the
        # Gar backplane spec for more info 
        #
        self.gar_disk_map = {
                  0x0003:0,
                  0x000f:1,
                  0x040d:2,
                  0x040c:3,
                  0x040a:4,

                  0x0005:5,
                  0x0000:6,
                  0x040e:7,
                  0x040b:8,
                  0x0408:9,

                  0x0006:10,
                  0x0001:11,
                  0x040f:12,
                  0x0409:13,
                  0x0406:14,

                  0x0008:15,
                  0x0002:16,
                  0x000e:17,
                  0x0407:18,
                  0x0403:19,

                  0x0009:20,
                  0x0004:21,
                  0x000d:22,
                  0x0405:23,
                  0x0402:24,

                  0x000a:25,
                  0x0007:26,
                  0x000c:27,
                  0x0404:28,
                  0x0401:29,

                  0x000b:30,
                  0x0400:31
               }


    def get_map(self):
        """Return the disk map string
        """
        if not self._get_disk_map():
            rlog_warning('Could not get the disk mapping')
            self.__map = ''
        return self.__map.rstrip()

    def get_size(self):
        """Return the size of all the disks in the system
        we dont care if the disks are branded here
        """
        if not self.get_disk():
            rlog_warning('Could not get the disk size information')
            self.__size = []

        return self.__size

    def get_unlicensed(self):
        """Return "true" if there are unbranded disks in the system else "false"
        """
	# If it is a BOB but branding is checked by esxi, ignore branding 
        if 'true' == self.__sysmobo.isbob and 'host' == self.__sysmobo.disk_brand_checker:
            return "false"

        if "true" == self.__sysmobo.branding:
            if not self.get_disk():
                rlog_warning('Could not get the disk size information, don\'t know if there are unbranded disks')
                return "false"

            if len(self.__size) != len(self.__branded):
                return "true"

        return "false"

    def get_quantity(self):
        """Return the number of branded disks in the system
        """
        if not self.get_disk():
            rlog_warning('Could not get the disk quantity information')
            self.__size = []

        return len(self.__size)

    def get_branded(self):
        """Return all the branded disks in the system
        """
        if not self.get_disk():
            rlog_warning('Could not get the branded disk information')
            self.__branded = []

        return self.__branded

    def translate_scsi_state(self, state):
        """We want to turn the scsi state into a binary state
        which indicates whether we can talk to the drive or not.
        we only want to talk to the drive when it is in the
        running state
        """
        if state == "running":
            return 'online'
        else:
            return 'offline'

    def get_scsi_dev_info(self, path):
        """Returns a tuple of scsi device name and state based on the path
        to its sysfs.

        the state is the raw scsi state, so it will need to be translated
        prior to use given the above translate_scsi_state() call, if you
        want to know whether the device can be talked to or not.

        An exception is raised if the sysfs file does not exist, or another IO
        error, which can be interpreted as a drive is missing by the caller
        if so desired.
        """
        dev_name  = get_sysfs_param ('%s/device/device_name' % path)
        dev_num = get_sysfs_param ('%s/device/block/dev' % path)

        bkdevs = glob.glob('/sys/block/*/shadow/backing_device')
        if bkdevs != []:
            for bkd in bkdevs:
                if get_sysfs_param(bkd) == dev_num:
                    dev_name=bkd.split('/')[3]
                    break

        dev_state = get_sysfs_param ('%s/device/state' % path)

        return (dev_name, dev_state)


    def _get_license_info(self, dname, brand_support):
	# If it is a BOB but branding is checked by esxi, ignore branding 
	if 'true' == self.__sysmobo.isbob and 'host' == self.__sysmobo.disk_brand_checker:
	    return "Licensed"

        if dname[:4] == 'disk' and brand_support == "true":
            dbrand = get_disk_branding("/dev/%s" % dname)
            if dbrand == -1:
                return "Error"
            if not compareSecretStr(dbrand):
                return "Unlicensed"
    
        return "Licensed"


    def get_disk_license(self):
        brand_support = self.__sysmobo.branding
        if not self._get_disk_map():
            rlog_warning('Could not get the disk mapping')
            self.__map = ''

        str = ''
        try:
            for disk in self.__map.rstrip().split('\n'):
                diskinfo = disk.split(' ')
                dname = diskinfo[1]
                state = diskinfo[3]
                # only talk to disks that hwtool reports as online (scsi state).
                # this disk may still be degraded in a raid, but the disk_map query
                # tells us whether we should talk to the disk or not.
                #
                if 'online' == state:
                    str += dname + ' ' + self._get_license_info(dname, brand_support) + '\n'
        except IndexError:
            # Old models where nothing is returned for disk=map
            pass

        return str


    def _do_scan_scsi_mpt(self, root_dir, pattern, bus_type):
        """Return a map of all the scsi drives in the system
        """
        mpt_scsi_regex = recompile(pattern)
        scsi_dev_dir_list = listdir (root_dir)
        found_drive_count = 0

        mpt_scsi_list = {}

        for scsi_dir in scsi_dev_dir_list:
            if mpt_scsi_regex.match (scsi_dir):
                try:
                    phys_drive_info = get_sysfs_param ("%s%s/device/phys_drive_info" % (root_dir, scsi_dir))
                except Exception:
                    rlog_debug('%s%s/device/phys_drive_num went missing, don\'t insert it into the list' % (root_dir, scsi_dir))
                    continue

                try:
                    pdi_int = int(phys_drive_info)
                except ValueError:
                    continue

                if bus_type == 'scsi-mpt':
                    disk_map = self.sturgeon_disk_map
                elif bus_type == 'scsi-mpt-2':
                    disk_map = self.gar_disk_map
                elif bus_type == 'scsi-dell':
                    disk_map = self.dell_disk_map
                elif bus_type == 'scsi-rf-1u-lsi':
                    disk_map = self.rf_1u_lsi_disk_map
                elif bus_type == 'scsi-rf-2u-lsi':
                    disk_map = self.rf_2u_lsi_disk_map
                elif bus_type == 'scsi-rf-25u-lsi':
                    disk_map = self.rf_25u_lsi_disk_map
                else:
                    raise HwtoolError('Invalid bus type for scsi-mpt system [%s]' % bus_type)

                if disk_map.has_key(pdi_int):
                    phys_drive_num = disk_map[pdi_int]
                else:
                    continue

                mpt_scsi_list[phys_drive_num] = scsi_dir

        return mpt_scsi_list


    def _get_disk_map(self):
        """Get the disk OS to bus mapping
        # disk maps are generated in 2 different ways for the new hw,
        # Barramundi's use direct scsi host bus patterns, on sturgeon,
        # the MPT driver assigns bus numbers in order of drive insertion,
        # so we need to use the phys_drive_num in the scsi device sysfs dir.
        #
        # also simplify the config when we have an explicit port number field
        """
        self.__map      = ''
        brand_support = self.__sysmobo.branding
        status        = ''

        disk_root = '/sys/class/scsi_device/'
        for (n, slot, bus, prefix, start_offset) in self.__sysmobo.disk_patterns:

            if bus == "scsi-mpt" or bus == "scsi-mpt-2" or bus == "scsi-dell" or \
                bus == "scsi-rf-1u-lsi" or bus == "scsi-rf-2u-lsi" or bus == "scsi-rf-25u-lsi":
                # the number for scsi-mpt entries indicates the total number of drives.
                #
                mptpd_to_scsi_map = self._do_scan_scsi_mpt(disk_root, slot, bus)

                for disk_ix in range (int(n, 10)):
                    dev_name  = 'missing'
                    dev_state = 'missing'
    
                    if mptpd_to_scsi_map.has_key (disk_ix):
                        scsi_bus = mptpd_to_scsi_map[disk_ix]
                        try:
                            (dev_name, dev_scsi_state) = self.get_scsi_dev_info ('%s%s' % (disk_root, scsi_bus))
                            dev_state = self.translate_scsi_state (dev_scsi_state)

                        except Exception:
                            pass
                    else:
                        scsi_bus = 'unknown'

                    dname = "%s%d" % (prefix, disk_ix + start_offset)

                    # use the device name prefix in the config file.
                    # e.g. disk0, the naming script elsewhere optionally attaches the
                    # p<partition num>
                    #
                    self.__map += (scsi_bus + " " + dname + " " + dev_name + " " + dev_state + "\n")
                    if dname[0:4] == 'disk' and dev_name != 'missing':
                        disk_obj = Disk(scsi_bus)   
                        self.__disk_list[dev_name] = disk_obj
                    
            elif bus == "scsi":
                dev_name  = 'missing'
                dev_state = 'missing'

                # scan the scsi devices using the pattern specified in the cfg.
                #
                if exists (disk_root):
                    scsi_dev_list = listdir (disk_root)
                    scsi_regex    = recompile(slot)

                    matches = filter (lambda dir: scsi_regex.match(dir), scsi_dev_list)
                    if matches != []:
                        slot = matches[0]

                        # today we use the first match, there can be only one match
                        # for regex's in scsi bus config entries.
                        #
                        try:
                            (dev_name, dev_scsi_state) = self.get_scsi_dev_info ('%s%s' % (disk_root, slot))
                            dev_state = self.translate_scsi_state (dev_scsi_state)
                        except Exception:
                            # we default to missing above.
                            pass

                # set the prefix
                dname = prefix + n

                self.__map += (slot + " " + dname + " " + dev_name + " " + dev_state + "\n")
                if dname[0:4] == 'disk' and dev_name != 'missing':
                    disk_obj = Disk(slot)   
                    self.__disk_list[dev_name] = disk_obj
            else:
                continue

        return True


    def get_disk(self):
        """Get the hard disk information
        """

        #get the size of each disk, rounded to the nearest GB.
        self.__size = []
        self.__branded = []

        if not self._get_disk_map():
            rlog_warning('Cannot get disk mapping')
            return False

        for e in self.__map.strip().split('\n'):
            try:
                parts = e.split(' ')
                if parts[1][0:5] == 'flash':
                    # skipping flash
                    continue
		if parts[2] == 'missing':
		    # skipping missing disks
		    continue
		size = get_sysfs_param('/sys/block/%s/size' % parts[2])
		size = int(size)/2
                size = int(int(size) * 1.024 / 1e6) # convert into GB

                if "true" == self.__sysmobo.branding:
                    dbrand = get_disk_branding('/dev/%s' % parts[1])
                    if dbrand == -1:
                        # This is a failed drive assume the disk size is zero and move on
                        self.__branded.append([parts[1], 0])
                        self.__size.append([parts[1], 0])
                        continue

                    if compareSecretStr(dbrand):
                        self.__branded.append([parts[1], size])
                        self.__size.append([parts[1], size])

                    else:
                        self.__size.append([parts[1], size])
                else:
                    self.__branded.append([parts[1], size])
                    self.__size.append([parts[1], size])

            except IndexError:
                # Nothing we can do as yet, would be great to log this
                pass
            except HwtoolError:
                pass
            except AttributeError:
                pass

        return True
