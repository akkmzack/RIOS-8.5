#!/usr/bin/python
from os.path import exists
import re

#################################################################
# This file holds the classes for the VMX Ethernet and Passthru
# config objects. 
# NOTE: It is needed both in the mgmtd repo as well as 
# the esxiplatform repo.
#################################################################

## check_if_passthrough_elements_are_equal
#
# @param pasthru_1, first instance of PassthroughSettings
# @param pasthru_2, second instance of PassthroughSettings
#
# Function that checks if two passthrough elements are the same
# Return True if elements are equal else False 
def check_if_passthrough_elements_are_equal(pasthru_1, passthru_2):
    if pasthru_1.present() != passthru_2.present():
        return False

    if pasthru_1.deviceId() != passthru_2.deviceId():
        return False

    if pasthru_1.vendorId() != passthru_2.vendorId():
        return False

    if pasthru_1.systemId() != passthru_2.systemId():
        return False

    if pasthru_1.id() != passthru_2.id():
        return False

    return True


## check_if_nic_elements_are_equal
#
# @param nic_1, first instance of NicSettings
# @param nic_2, second instance of NicSettings
#
# Function that checks if two nic elements are the same
# Return True if elements are equal else False 
def check_if_nic_elements_are_equal(nic_1, nic_2):
    if nic_1.present() != nic_2.present():
        return False

    if nic_1.virtualDev() != nic_2.virtualDev():
        return False

    if nic_1.networkName() != nic_2.networkName():
        return False

    if nic_1.addressType() != nic_2.addressType():
        return False

    if nic_1.address() != nic_2.address():
        return False

    if nic_1.checkMACAddress() != nic_2.checkMACAddress():
        return False

    if nic_1.name() != nic_2.name():
        return False

    if nic_1.onFailure() != nic_2.onFailure():
        return False

    if nic_1.param0() != nic_2.param0():
        return False

    return True


## PassthroughSettings
# class containing all the passthrough interfaces settings in the VMX file
# We care about the following settings only.
# pciPassthruX.present
# pciPassthruX.deviceId
# pciPassthruX.vendorId
# pciPassthruX.systemId
# pciPassthruX.id
class PassthroughSettings:
    ## Init Method
    #
    def __init__(self):
        # __present
        # indicate if the interface is present
        self.__present = ''

        # __deviceId
        # device ID of the passthrough device
        self.__deviceId = ''

        # __vendorId
        # vendor ID of the passthrough device
        self.__vendorId = ''

        # __systemId
        # system ID of the passthrough device
        self.__systemId = ''

        # __id
        # ID of the passthrough device
        self.__id = ''

    def __str__(self):
        str = "Present = %s\n" % self.present()
        str += "Device ID  = %s\n" % self.deviceId()
        str += "Vendor ID = %s\n" % self.vendorId()
        str += "System ID = %s\n" % self.systemId()
        str += "ID = %s\n" % self.id()

        return str

    ##############################################################
    # ACCESSORS
    ##############################################################
    def present(self, value = None):
        if value:
            self.__present = value
        return self.__present

    def deviceId(self, value = None):
        if value:
            self.__deviceId = value
        return self.__deviceId

    def vendorId(self, value = None):
        if value:
            self.__vendorId = value
        return self.__vendorId

    def systemId(self, value = None):
        if value:
            self.__systemId = value
        return self.__systemId

    def id(self, value = None):
        if value:
            self.__id = value
        return self.__id


## NicSettings
# class containing all the Ethernet interface settings in the VMX file
# We care about the following settings only.
# ethernetX.present
# ethernetX.virtualDev
# ethernetX.networkName
# ethernetX.addressType
# ethernetX.address
# ethernetX.checkMACAddress
# ethernetX.filter0.name
# ethernetX.filter0.onFailure
# ethernetX.filter0.param0
class NicSettings:
    ## Init Method
    #
    def __init__(self):
        # __present
        # indicate if the interface is present
        self.__present = ''

        # __virtualDev
        # driver used
        self.__virtualDev = ''

        # __networkName
        # for non RSP interfaces, it indicates the name of the interface
        # for RSP interfaces its the RSP vSwitch name
        self.__networkName = ''

        # __addressType
        # generally set to generated
        self.__addressType = ''

        # MAC address of the interface if the addressType is static
        self.__address = ''

        # Set to False for primary and aux interfaces
        self.__checkMACAddress = ''

        ###########################################################
        # All settings starting with filter* are for RSP interfaces
        ###########################################################
        # __filterName
        # name of the dvfilter module
        self.__filterName = ''

        # __filterFailure
        # generally set to failClosed
        self.__filterFailure = ''

        # __filterParam
        # For RSP interfaces, this is the name of the interface
        self.__filterParam = ''

        # __generatedAddress
        # For the guest interfaces the MAC will be generated, this 
        # value will be needed to identify interfaces
        self.__generatedAddress = ''

    def __str__(self):
        str = "Present = %s\n" % self.present()
        str += "VirtualDev = %s\n" % self.virtualDev()
        str += "NetName = %s\n" % self.networkName()
        str += "AddType = %s\n" % self.addressType()
        str += "Address = %s\n" % self.address()
        str += "checkMACAddress = %s\n" % self.checkMACAddress()
        if self.name():
            # Will be set only for RSP interfaces
            str += "FilterName = %s\n" % self.name()
            str += "OnFailure = %s\n" % self.onFailure()
            str += "FilterParam = %s\n" % self.param0()
        str += "generatedAddress = %s\n" % self.generatedAddress()

        return str

    ##############################################################
    # ACCESSORS
    ##############################################################
    def present(self, value = None):
        if value:
            self.__present = value
        return self.__present

    def virtualDev(self, value = None):
        if value:
            self.__virtualDev = value
        return self.__virtualDev

    def networkName(self, value = None):
        if value:
            self.__networkName = value
        return self.__networkName

    def addressType(self, value = None):
        if value:
            self.__addressType = value
        return self.__addressType

    def checkMACAddress(self, value = None):
        if value:
            self.__checkMACAddress = value
        return self.__checkMACAddress

    def address(self, value = None):
        if value:
            self.__address = value
        return self.__address

    def name(self, value = None):
        if value:
            self.__filterName = value
        return self.__filterName

    def onFailure(self, value = None):
        if value:
            self.__filterFailure = value
        return self.__filterFailure

    def param0(self, value = None):
        if value:
            self.__filterParam = value
        return self.__filterParam

    def generatedAddress(self, value = None):
        if value:
            self.__generatedAddress = value
        return self.__generatedAddress


## ParseVMXFile
# class that will do the VMX parsing and build a list of 
# Ethernet and Disk settings
class ParseVMXFile:
    ## Init Method
    # @param VMX file name to parse
    #
    # parses the VMX file and builds lists for interfaces and disks
    #
    def __init__(self, vmx):
        ## __vmx
        # vmx file to parse
        if not exists(vmx):
            raise AssertionError('VMX file does not exist')
        self.__vmx = vmx

        ## __nics
        # dictionary of all the nic cards in the system
        self.__nics = {}

        ## __passthroughs
        # dictionary of all the passthrough devices
        self.__passthru = {}

        ## __disks
        # dictionary of all the disks in the system
        self.__disks = {}

        ## __nic_keys
        # The EthernetX.keys we care about
        self.__nic_keys = {
                     'present':1,
                     'virtualDev':1,
                     'networkName':1,
                     'addressType':1,
                     'address':1,
                     'checkMACAddress':1,
                     'filter0.name':1,
                     'filter0.onFailure':1,
                     'filter0.param0':1,
                     'generatedAddress':1,
                    }

        ## __passthru_keys
        # The passthruX.keys we care about
        self.__passthru_keys = {
                     'present':1,
                     'deviceId':1,
                     'vendorId':1,
                     'systemId':1,
                     'id':1,
                    }

        # parse the VMX file
        self.__parse_file()


    ## __parse_file
    # 
    # parses the VMX file and fills up the NIC and disk information
    def __parse_file(self):
        try:
            file = open(self.__vmx, "r")
            lines = file.readlines()
            file.close()
        except IOError:
            raise AssertionError('Cannot read VMX file')

        nic_dict = {}
        passthru_dict = {}
        for line in lines:
            try:
                (key, value) = line.strip().split('=')
            except ValueError:
                # Don't care about non key value pair entries
                continue

            if key.startswith('ethernet'):
                sub_key = key.split('.')[0]
                nic_index = int(sub_key.replace('ethernet', '').strip())
                sub_value = key.replace('ethernet%s.' % nic_index, '').strip()

                # Get only the information that helps us rebuild the interfaces
                # if something went wrong
                if self.__nic_keys.has_key(sub_value):
                    if nic_dict.has_key(nic_index):
                        nic_dict[nic_index][sub_value] = value.strip()
                    else:
                        dict = {}
                        dict[sub_value] = value.strip()
                        nic_dict[nic_index] = dict

            if key.startswith('pciPassthru'):
                sub_key = key.split('.')[0]
                passthru_index = int(sub_key.replace('pciPassthru', '').strip())
                sub_value = key.replace('pciPassthru%s.' % passthru_index, '').strip()

                # Get only the information that helps us rebuild the interfaces
                # if something went wrong
                if self.__passthru_keys.has_key(sub_value):
                    if passthru_dict.has_key(passthru_index):
                        passthru_dict[passthru_index][sub_value] = value.strip()
                    else:
                        dict = {}
                        dict[sub_value] = value.strip()
                        passthru_dict[passthru_index] = dict


        for index in nic_dict.keys():
            ns = NicSettings()
            for key in nic_dict[index]:
                funct_name = re.sub("\w+\.", "", key)
                getattr(ns, funct_name)(nic_dict[index][key])

            self.__nics[index] = ns

        for index in passthru_dict.keys():
            pt = PassthroughSettings()
            for key in passthru_dict[index]:
                funct_name = re.sub("\w+\.", "", key)
                getattr(pt, funct_name)(passthru_dict[index][key])

            self.__passthru[index] = pt


    # get_passthru
    #
    # Get the passthru dictionary
    def get_passthru(self):
        return self.__passthru

    # get_nic
    #
    # Get the nic dictionary
    def get_nic(self):
        return self.__nics

