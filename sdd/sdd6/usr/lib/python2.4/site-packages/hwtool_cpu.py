#!/usr/bin/python

from hwtool_util import cat, smbiosDump
from re import compile as recompile
from hwtool_util import rlog_debug, rlog_warning

##############################################################
# CPU, container class for CPU core information in the system
##############################################################
class CPU:
    """CPU part information like coreid, vendor, speed, etc
    """
    def __init__(self, pid=0, sp=0, ven='', mod='', cac='', cid=0):
        self.__pid = pid
        self.__speed = sp
        self.__vendor = ven
        self.__model = mod
        self.__cache = cac
        self.__coreid = cid

    def get_speed(self):
        """Return the speed of the CPU
        """
        return self.__speed

    def get_vendor(self):
        """Return the CPU vendor name
        """
        return self.__vendor

    def printo(self):
        """Pretty printing for all the CPU information
        """
        print "Processor Id: %s, Vendor: %s, Speed: %s, Core Id: %s, Cache: %s, Model: %s" % (self.__pid
            , self.__vendor, self.__speed, self.__coreid, self.__cache, self.__model)


###################################################################
# Cores, container class for all the cores in the system
###################################################################
class Cores:
    def __init__(self, type):
        self.__cores = []
        # Type can be "ESXi" or "RiOS"
        self.__type = type
        if self.__type == 'RiOS':
            self.__get_cores_information()
        elif self.__type == 'ESXi':
            self.__get_esxi_cores_information()
        else:
            rlog_warning('Unknown platform type for CPU information')
            exit(1)

    def get_quantity(self):
        """Return the number of CPU cores in the system
        """
        if len(self.__cores) > 0:
            return len(self.__cores)
        else:
            if self.__type == 'RiOS':
                self.__get_cores_information()
            elif self.__type == 'ESXi':
                self.__get_esxi_cores_information()
            return len(self.__cores)

    def get_speed(self):
        """Return the speed value from the first core in the system
           its going to be the same for all cores
        """
        if len(self.__cores) > 0:
            return self.__cores[0].get_speed()
        else:
            if self.__type == 'RiOS':
                self.__get_cores_information()
            elif self.__type == 'ESXi':
                self.__get_esxi_cores_information()
            return self.__cores[0].get_speed()

    def get_vendor(self):
        """Return the vendor value from the first core in the system
           its going to be the same for all cores
        """
        if len(self.__cores) > 0:
            return self.__cores[0].get_vendor()
        else:
            if self.__type == 'RiOS':
                self.__get_cores_information()
            elif self.__type == 'ESXi':
                self.__get_esxi_cores_information()
            return self.__cores[0].get_vendor()

    def get_cores_list(self):
        """Return the list of cores
        """
        if len(self.__cores) < 1:
            if self.__type == 'RiOS':
                self.__get_cores_information()
            elif self.__type == 'ESXi':
                self.__get_esxi_cores_information()
            
        return self.__cores

    def __get_esxi_cores_information(self):
        """Use the output of smbiosDump as ESXi does not support /proc/cpuinfo
        """
        dmi = smbiosDump()
        # cache and model will always remain empty for ESXi
        # coreid will be an incremental counter
        (pid, speed, vendor, model, cache, coreid) = (0, 0, '', '', '', 0)
        processor_pat = recompile("^\s*Processor Info:")
        manu_pat = recompile("^Manufacturer:")
        speed_pat = recompile("^Max. Speed:")
        core_pat = recompile("^Core Count:")
        cache_pat = recompile("^Cache Info:")
        pid_pat = recompile("^Socket:")

        core = 0 # Number of cores per CPU
        in_processor = False
        for line in dmi:
            # Get rid of all start and end white spaces
            line = line.strip()
            if in_processor:
                if pid_pat.match(line):
                    pid = line[7:]
                    if pid: 
                        try:
                            pid = int(pid.strip().replace('"', '').replace('CPU', ''))
                        except ValueError:
                            rlog_warning("Cannot get the processor ID for the CPU")
                            return False
                if manu_pat.match(line):
                    vendor = line[13:]
                    if vendor:
                        vendor = vendor.strip().replace('"', '')
                elif speed_pat.match(line):
                    speed = line[11:]
                    if speed:
                        try:
                            speed = int(speed.strip().replace('MHz', ''))
                        except ValueError:
                            rlog_warning("Cannot get the Speed info for the CPU")
                            return False
                elif core_pat.match(line):
                    core = line[11:]
                    if core:
                        try:
                            core = int(core.strip().replace('#', ''))
                        except ValueError:
                            rlog_warning("Cannot get the number of cores for the CPU")
                            return False

            elif processor_pat.match(line):
                in_processor = True
            if in_processor and cache_pat.match(line):
                # Done with the processor section, time to create the core objects
                in_processor = False
                for i in range(core):
                    coreid += 1
                    cpu = CPU(pid, speed, vendor, model, cache, coreid)
                    self.__cores.append(cpu)

                (pid, speed, vendor, model, cache) = (0, 0, '', '', '')

        return True
            

    def __get_cores_information(self):
        """Use the output of /proc/cpuinfo to figure out CPU information
        """
        (pid, speed, vendor, model, cache, coreid) = (0, 0, '', '', '', -1)
        cpuinfo = cat("/proc/cpuinfo")
        for i in range(0, len(cpuinfo)):
            line = cpuinfo[i]
            if line[:9] == 'processor':
                # The output starts with 'processor' so nothing to add there
                # if speed value has changed 
                # and a processor line is encountered, 
                # it means we have parsed the first core
                # DO NOT USE COREID VALUE AS ITS NOT DISPLAYED ON ESXI GUESTS
                if speed > 0:
                    cpu = CPU(pid, speed, vendor, model, cache, coreid)
                    self.__cores.append(cpu)
                    (pid, speed, vendor, model, cache, coreid) = (0, 0, '', '', '', -1)
                (key, value) = line.split(': ')
                pid = int(value.strip())
            elif line[:7] == 'cpu MHz':
                try:
                    (key, value) = line.split(': ')
                    speed = int(float(value.strip()))
                except ValueError:
                    speed = 0
                    rlog_warning("Cannot get the CPU speed")
            elif line[:9] == 'vendor_id':
                (key, value) = line.split(': ')
                vendor = value.strip()
            elif line[:10] == 'cache size':
                (key, value) = line.split(': ')
                cache = value.strip()
            elif line[:7] == 'core id':
                (key, value) = line.split(': ')
                coreid = int(value.strip())
            elif line[:10] == 'model name':
                (key, value) = line.split(': ')
                model = value.strip()

        # Add the last core to the list
        cpu = CPU(pid, speed, vendor, model, cache, coreid)
        self.__cores.append(cpu)
        return True


