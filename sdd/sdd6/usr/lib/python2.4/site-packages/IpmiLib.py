#!/usr/bin/env python
from os import popen
from time import sleep
from os.path import exists
from os import remove

# Different Exceptions that might be generated from our utilities.
#
class HalError(Exception):
    pass

class IpmiError(Exception):
    pass

class GeneralError(Exception):
    pass


###############################################################################
# ipmi_modules_list
# 
# list of modules to load using modprobe, that are needed for IPMI
# image flashing support
#
# This list is ordered, msghandler should come before modules that depend on it
# When unloading, we need to be able to unload all the modules in reverse
# 
# you may want to sleep a second after loading the modules to give the module
# a sec to complete initializing
#
###############################################################################
ipmi_modules_list=[ "ipmi_msghandler", "ipmi_si", "ipmi_devintf" ]
ipmi_devintf = '/dev/ipmi0'

def get_devmajor_by_module(module):
    pdev_path = '/proc/devices'

    if not exists(pdev_path):
        return None

    try:
        fh = open(pdev_path, 'r')
        output = fh.read().strip()
        fh.close()
    except IOError:
        return None

    for line in output.split('\n'):
        newline = line.strip()
        parts = newline.split(' ')
        if len(parts) != 2:
            continue

        if parts[1] == module:
            return parts[0]

    return None

def load_ipmi_modules():
    global ipmi_modules_list
    cmd = "/sbin/modprobe"

    for module in ipmi_modules_list:
        call    = popen ('%s %s 2>&1' % (cmd, module) )
        output  = call.read().strip()
        rcode = call.close()

        if rcode != None:
            raise GeneralError('Unable to load IPMI module %s, with error [%s]' % 
                               (module, output))

    ipmi_dev_major = get_devmajor_by_module('ipmidev')
    if ipmi_dev_major == None:
        raise GeneralError('Unable to determine IPMI dev major number')

    if exists(ipmi_devintf):
        remove(ipmi_devintf)

    call    = popen ('/bin/mknod %s c %s 0 2>&1' % (ipmi_devintf, ipmi_dev_major) )
    output  = call.read().strip()
    rcode = call.close()

    # as this is called shortly after loading the modules,
    # we have a small race where the device may appear after we do the existance
    # check on /dev/ipmi0 but before we call mknod.
    # make sure that if the mknod fails, the device didnt just appear.
    if rcode != None and not exists(ipmi_devintf):
        raise GeneralError('Unable to create /dev/ipmi0 device')

def unload_ipmi_modules(force = False):
    global ipmi_modules_list
    cmd     = "/sbin/rmmod"
    status  = 'ok'

    unload_mod_list = ipmi_modules_list[:]
    
    # in place reversal of the list
    unload_mod_list.reverse()
    # unload the modules in the reverse order
    #
    for module in unload_mod_list:
        call    = popen ('%s %s 2>&1' % (cmd, module) )
        output  = call.read().strip()
        rcode = call.close()

        # a force unload means that we'll not fail out on error conditions
        # so we can continue to try to unload the rest of the modules
        #
        if rcode != None:
            if  not force:
                raise GeneralError('Unable to unload IPMI module %s, with error [%s]' %
                                (module, output))
            else:
                print 'Failed to unload IPMI module %s [%s]' % (module,
                    output)
                        
                # for unloading if we're in force mode, we'll return
                # an indication to ther that something bad happened.
                status = 'failed'

    # if the ipmi devintf node exists and we unloaded the driver,
    # make sure we remove the dev node as ipmi uses dynamic device
    # device major nums and this may point to a diff driver.
    if exists(ipmi_devintf):
        remove(ipmi_devintf)

    return status


###############################################################################
# is_ipmi_supported
#
#
###############################################################################
def is_ipmi_supported():
    hwtool_path = '/opt/hal/bin/hwtool.py'
    if not exists(hwtool_path):
        raise GeneralError('Unable to find hwtool at %s' % hwtool_path)
    else:
        call    = popen ('%s -q %s' % (hwtool_path, 'ipmi'))
        output  = call.read().strip()
        rcode = call.close()

        if rcode != None or output == '':
            # no response or error.
            # log error
            raise GeneralError('Failed to determine IPMI support from hwtool')
        elif output == 'True':
            return True
        else:
            return False

            

###############################################################################
# compare_ipmi_versions
#
# Compare version v2 against v1 and return
# a string indicating the result of the comparison
#
# If the major version (motherboard identified)
# doesnt match, they are incompatible.
#
###############################################################################
def compare_ipmi_versions(v1, v2):
    (v1_maj, v1_min) = v1
    (v2_maj, v2_min) = v2

    if v2_maj != v1_maj:
        return 'incompatible'
    elif v2_min > v1_min:
        return 'newer'
    elif v2_min == v1_min:
        return 'same'
    else:
        return 'older'

###############################################################################
# class IpmiFile
#
# Takes a file name like S6631r08.bin or S6673r08.sdr and extracts
# the major minor versions from it, as well as the file type.
#
###############################################################################
class IpmiFile:
    def __init__(self, file):
        self.__fpath = file
        if file != '':
            file_parts  = file.split("/") 
            fp_len      = len (file_parts)
            self.__fname = file_parts[fp_len - 1]

        self.__maj_version  = -1
        self.__min_version  = -1
        self.parse_file_name()

    ###########################################################################
    # External interfaces
    # 
    ###########################################################################
    def is_sdr_file(self):
        return self.__file_type == 'ipmi_sdr'
        
    def is_fw_file(self):
        return self.__file_type == 'ipmi_fw'

    def get_maj_version(self):
        return self.__maj_version

    def get_min_version(self):
        return self.__min_version

    ###########################################################################
    # get_version
    # 
    # returns the major minor version as a tuple
    ###########################################################################
    def get_version (self):
        return (self.__maj_version, self.__min_version)

    ###########################################################################
    # parse_file_name
    #
    # IPMI files should have the names : 
    # S6631rXY.sdr or S6631rXY.bin
    # 
    # do the real work of 
    # 
    ###########################################################################
    def parse_file_name(self):
        parts = self.__fname.split('.')
        if len (parts) != 2:
            raise HalError ("Invalid IPMI file name specified")

        if parts[1] == 'bin':
            self.__file_type = 'ipmi_fw'
        elif parts[1] == 'sdr':
            self.__file_type = 'ipmi_sdr'
        else:
            raise GeneralError ("Unknown IPMI File Format")

        # split S6631rXY into parts allowing either R or r as a
        # separator
        #
        ipmi_info_parts = parts[0].split('r')
        if (len(ipmi_info_parts) == 1):
            ipmi_info_parts = parts[0].split('R')

        if len (ipmi_info_parts) != 2:
            raise GeneralError ("Invalid IPMI file name specified %s", self.__fname)
        
        try:
            self.__maj_version = int(ipmi_info_parts[0][1:5])
            self.__min_version = int(ipmi_info_parts[1][0:2])
        except IndexError:
            raise GeneralError("Invalid IPMI file name specified %s" % self.__fname)
            
###############################################################################
# IpmiSystem
#
# Class wrapper for IPMI FW and SDR version information as read
# from the system via the HAL get_ipmi_ver interface.
#
#
###############################################################################
class IpmiSystem:
    def __init__(self):
        self.__ipmi_version_str     = 'ipmi_ver' 
        self.__ipmi_fw_maj_ver_str  = 'ipmi_fw_maj_rev' 
        self.__ipmi_fw_min_ver_str  = 'ipmi_fw_min_rev' 
        self.__ipmi_sdr_maj_ver_str = 'ipmi_sdr_maj_ver'
        self.__ipmi_sdr_min_ver_str = 'ipmi_sdr_min_ver'
        
        # lazy update flag.  when data is requested, we'll 
        # call the hal and grab it if we havent already.
        self.__is_populated = False 
        self.__ipmi_dict   = {}

    ###########################################################################
    # fill_from_system_info
    #
    # call the HAL and fill in the dictionary with the key/values returned.
    # special handling is done on the fw version to translate it from 0.X to 
    # X since version 30 of the firmware is called 0.30 by the fw.
    #
    ###########################################################################
    def fill_from_system_info(self):
        hal_path = '/opt/hal/bin/hal'

        call    = popen ('%s %s' % (hal_path, 'get_ipmi_ver'))
        output  = call.read()
        rcode = call.close()

        if rcode == None and output != None and output != '':
            kvp_list    = map (lambda line: line.split('='), output.split('\n'))
            for kvp in kvp_list:
                try:
                    self.__ipmi_dict[kvp[0]] = kvp[1]
                except IndexError:
                    # skip a malformed entry
                    pass
        else:
            raise HalError

        try:
            self.__translate_fw_version()
        except KeyError:
            raise GeneralError('Unable to translate IPMI fw version %s' %
                               self.__ipmi_dict[self.__ipmi_fw_min_ver_str])
            
        self.__is_populated = True

    def __translate_fw_version(self):
        # mitac for some reason has decided to call the firmware revision 0.30 in the 
        # fw file, but version 30 in everything else.    
        # we'll convert it to a standard value here, we leave a leading 0 if there is
        # one, it will be stripped when it is converted to an int.
        # but if we ever get to a revision 1.03 , such as this will still work.
        #
        self.__ipmi_dict[self.__ipmi_fw_min_ver_str] = \
                self.__ipmi_dict[self.__ipmi_fw_min_ver_str].replace('.','')

    ###########################################################################
    # External Access Routines
    ###########################################################################
    def get_ipmi_version(self):
        if not self.__is_populated:
            self.fill_from_system_info()
        
        return self.__ipmi_dict[self.__ipmi_version_str]

    def get_ipmi_fw_version(self):
        if not self.__is_populated:
            self.fill_from_system_info()

        try:
            major = int(self.__ipmi_dict[self.__ipmi_fw_maj_ver_str])
            minor = int(self.__ipmi_dict[self.__ipmi_fw_min_ver_str])

            return (major, minor)
        except ValueError:
            # one of these is malformed.  we'll update the firmware to a known good
            # version
            return (0, 0)

    def get_ipmi_sdr_version(self):
        if not self.__is_populated:
            self.fill_from_system_info()

        try:
            major = int(self.__ipmi_dict[self.__ipmi_sdr_maj_ver_str])
            minor = int(self.__ipmi_dict[self.__ipmi_sdr_min_ver_str])
            return (major, minor)
        except ValueError:
            return (0, 0)

    ###########################################################################
    # display
    # 
    # debug routine for dumping the IPMI and SDR version info.
    #
    ###########################################################################
    def display(self):
        if not self.__is_populated:
            self.fill_from_system_info()

        print '%s:%s:%s:%s:%s' % (self.get_ipmi_version(), 
                               self.get_ipmi_fw_version()[0],
                               self.get_ipmi_fw_version()[1],
                               self.get_ipmi_sdr_version()[0],
                               self.get_ipmi_sdr_version()[1])


    ###########################################################################
    # upgrade_sdr_file
    #
    #
    ###########################################################################
    def upgrade_sdr_file(self, fname):
        tool = '/sbin/uh8l --open --sdr'
        cmdline = '%s %s' % (tool, fname)
    
        if not exists (fname):
            raise GeneralError('SDR file %s does not exist' % fname)

        ifile = IpmiFile(fname)
        if not ifile.is_sdr_file():
            raise IpmiError ('Invalid SDR file %s, skipping update' % fname)

        pf = popen (cmdline)
        output = pf.read()
        rcode = pf.close()
    
        if rcode != None:
            # error..
            raise IpmiError ('Unable to update SDR file %s' % fname)

    ###########################################################################
    # upgrade_fw_file
    #
    #
    ###########################################################################
    def upgrade_fw_file(self, fname):
        tool = '/sbin/uh8l --open -u'
        cmdline = '%s %s' % (tool, fname)

        if not exists (fname):
            raise GeneralError('FW file %s does not exist' % fname)

        ifile = IpmiFile(fname)
        if not ifile.is_fw_file():
            raise IpmiError ('Invalid FW file %s, skipping update' % fname)

        pf = popen (cmdline)
        output = pf.read()
        rcode = pf.close()

        if rcode != None:
            # error..
            raise IpmiError ('Unable to update FW file %s' % fname)
