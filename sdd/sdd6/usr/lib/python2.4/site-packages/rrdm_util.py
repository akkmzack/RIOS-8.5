#!/usr/bin/env python
#
# Copyright (C) 2008 Riverbed Technology, Inc.
# All rights reserved world wide.
#
from popen2 import Popen4
from os import stat, popen
from os.path import exists, isfile
from rrdm_logging import *
import appliance_util
import errno

try:
    from Logging import *
    from Logging import log
except ImportError:
    pass

verbose = False
log_syslog = False

hwtool_py	=   "/opt/hal/bin/hwtool.py"
mfg_hwtool_py	=   "/sbin/hwtool.py"

###############################################################################
# Logging Utilities
# 
# Abstraction allows the classes to work in manufacturing mode, with -v option
# and at runtime, using syslog
#
# Calling application must call log_init()
#
###############################################################################
def enable_syslog():
    global log_syslog
    log_syslog = True

def rlog_notice (msg):
    global log_syslog, verbose
    if log_syslog:
	notice(msg)
    if verbose:
	print msg

def rlog_info (msg):
    global log_syslog, verbose
    if log_syslog:
        info(msg)
    if verbose:
        print msg

def rlog_warning (msg):
    global log_syslog, verbose
    if log_syslog:
	warn(msg)
    if verbose:
	print msg

def rlog_debug (msg):
    global log_syslog, verbose
    # debug messaging can be a bit much, so only output
    # debug msgs if we are verbose as well
    if log_syslog and verbose:
	debug(msg)
    if verbose:
	print msg
	

# Exception class
#
class rrdm_error(Exception):
    pass

def set_mfdb_val(mdcfg,
                 mddbreq_path = '/opt/tms/bin/mddbreq',
                 mfdb_path    = '/config/mfg/mfdb'):
    if not exists (mddbreq_path):
        raise OSError(errno.ENOENT, '%s not found' % mddbreq_path)
    if not exists(mfdb_path):
        raise OSError(errno.ENOENT, '%s not found' % mfdb_path)
    
    rlog_debug('Setting mfdb value %s:%s:%s' % (mdcfg.get_node(),
                                                mdcfg.get_type(),
                                                mdcfg.get_value()))
    value = mdcfg.get_value()
    if value == '':
        value = '\"\"'

    pf = popen('%s %s set modify - %s %s %s' % (mddbreq_path,
                                                mfdb_path,
                                                mdcfg.get_node(),
                                                mdcfg.get_type(),
                                                value))
    rcode = pf.close()

    if rcode != None:
        raise rrdm_error('Unable to update mfdb node %s val:%s' % \
                         (mdcfg.get_node(), mdcfg.get_value()))

def get_mfdb_val(node,
                 mddbreq_path = '/opt/tms/bin/mddbreq',
                 mfdb_path    = '/config/mfg/mfdb'):
    if not exists (mddbreq_path):
        raise OSError(errno.ENOENT, '%s not found' % mddbreq_path)
    if not exists(mfdb_path):
        raise OSError(errno.ENOENT, '%s not found' % mfdb_path)

    pf = popen('%s -v %s query get - %s' % (mddbreq_path,
                                            mfdb_path,
                                            node))
    result = pf.read().strip()
    rcode = pf.close()

    if rcode != None:
        raise rrdm_error('Unable to read mfdb node %s' % node)
    else:
        return result

# Should be an appliance util call?
def get_storage_profile():
    mddbreq_path = '/opt/tms/bin/mddbreq'
    if not exists (mddbreq_path):
        # we can't get the model.
        return None

    if not exists('/config/mfg/mfdb'):
        return None

    # grab the model from hald_model
    pf = popen ('%s -v /config/mfg/mfdb query get - /rbt/mfd/resman/profile' % \
                mddbreq_path)
    profile_line  = pf.read().strip()
    rcode = pf.close()

    try:
        profile = profile_line.strip()
    except IndexError:
        # if we can't find the model, we'll return None and expect the caller
        # to handle this case
        return None
    if profile == '':
        return None

    return profile
 
def set_storage_profile(profile,
                        mfdb_path='/config/mfg/mfdb'): 
    mddbreq_path = '/opt/tms/bin/mddbreq'
    if not exists (mddbreq_path) or not exists(mfdb_path):
        # we can't get the model.
        return None

    # grab the model from hald_model
    pf = popen ('%s %s set modify - /rbt/mfd/resman/profile string %s' % \
                (mddbreq_path, mfdb_path, profile))
    rcode = pf.close()

    if rcode != None:
        return False
    else:
        return True

    

def get_model():
    model = appliance_util.get_appliance_model()
    if model == None:
        raise rrdm_error ("Unexpected error fetching system model")
    else:
        return model

    

def display_debug(bool):
    global verbose
    verbose = bool   

###############################################################################
# Mgmt and Model Support Interfaces
###############################################################################

# get_raid_type 
# Figure out whether this model supports hardware or software raid
def get_raid_type(model):
    if (model in [ "3030", "2050" ]):
	return 'software'
    elif (model in ["3000","3010","3020","3510","3520","5000",
                     "5010","5520" ,"6020","6120","9200"]):
	    return 'hardware'
    else:
	return 'none'

##############################################################################
# Sysfs Support
##############################################################################

# get_scsi_sysfs_param
#
# Find the value of a specific scsi sysfs entry based on its ID and 
# sysfs name
#
def get_scsi_sysfs_param(bus, name):
    device_str='/sys/bus/scsi/devices/%s/%s' % (bus, name)
    return get_sysfs_param(device_str)

def get_blockdev_param(blockdev, 
                       param_name):
    # 2 cases:
    # blockdev is "sda" then we use a /sys/block/sda/<name> path
    # if blockdev is "sda7" then we use /sys/block/sda7/<name>

    device_str = '/sys/block/%s/%s' % (blockdev, param_name)
    # see if we're case 1
    if exists(device_str):
        return get_sysfs_param(device_str)
    else:
        # see if we're case 2
        bdevname = blockdev.rstrip('0123456789')
        device_str = '/sys/block/%s/%s/%s' % (bdevname,
                                              blockdev,
                                              param_name)
        return get_sysfs_param(device_str)

def get_blockdev_size_mb(blockdev,
                         param_name):
    try:
        value = int(get_blockdev_param(blockdev, param_name))
    except ValueError:
        return -1

    # block device values are in sectors, so convert to MB
    # * 512 / 1024 / 1024
    return (value / 2048)

    


def set_sysfs_param(name, value):
    if not exists (name):
	return True

    outfile = open (name, "w")
    try:
        outfile.write(value)
    except:
        outfile.close()
	return False

    outfile.close()

    return True
        

def get_sysfs_param(name):
    infile = open (name, "r")
    try:
        text = infile.read()
    finally:
        infile.close()

    text = text.rstrip()
    return text

def find_mdadm():
    mdadm_mfg_path='/mfg/mdadm'
    mdadm_img_path='/sbin/mdadm'
    
    if exists(mdadm_img_path):
	return mdadm_img_path
    elif exists (mdadm_mfg_path):
	return mdadm_mfg_path
    else:
	raise rrdm_error ('Unable to find mdadm')


# run_shell_cmd
#
# Run any shell command and get its return code.
#
def run_shell_cmd(cmd, output = False):
    if cmd != '':
        shell = Popen4(cmd)
        ret = shell.wait()
        if ret:
            raise rrdm_error('failed to exec : %s' % cmd)
        else:
            if output:
                return shell.fromchild.read()[:-1]
            else:
                return ret

# grab the basic device and raid info from a raid device
#
# FIXME: replace with RaidSuper(device)
#
def read_brief_md_sb(dev_name):
    mdadm = find_mdadm()
    cmdline = '%s --examine -b %s' % (mdadm, dev_name)

    output = run_shell_cmd (cmdline, True)
    if output == '':
        raise rrdm_error ('failed to read raid superblock for device [%s]' % dev_name)
    
    # make sure this is all one line.
    return output

# grab the full SB contents from the drive
# this will return 1 for a non SB or corrupted SB drive
#
# FIXME: replace with RaidSuper(device)
#
def read_md_sb(dev_name):
    mdadm = find_mdadm()
    cmdline = '%s --examine %s' % (mdadm, dev_name)
    output = run_shell_cmd (cmdline, True)
    if output == '':
        raise rrdm_error ('failed to read raid superblock for device [%s]' % dev_name)
    
    return output

# given brief MD superblock output grab the raid uid string
#
# FIXME: this can be replaced with RaidSuper(device).uuid()
#
def get_uid_from_brief_sb(output):
    kvp_list = output.replace('\n', '').split(' ')
    for kvp_line in kvp_list:
        kvp = kvp_line.split('=')
        if kvp[0] == 'UUID':
            return '%s' % kvp[1]

    return 'unknown'
    
# given brief MD superblock output grab the raid device number
#
# FIXME:replace with RaidSuper(device).lookup_disk('this').raid_device()
#
def get_rdev_from_brief_sb(output):
    kvp_list = output.split(' ')
    for kvp_line in kvp_list:
	kvp = kvp_line.split('=')
	if kvp[0] == 'device':
	    return int (kvp[1], 10)

    return 'unknown'

################################################################################
# Raid Superblock Disk
# 
# Info in one of the raid superblock disk fields
#
################################################################################
class RaidSuperDisk:
    def __init__(self, line):
	ln = line.split()
	self.__ident = ln[0]
	self.__number = int(ln[1])
	self.__major = int(ln[2])
	self.__minor = int(ln[3])
	self.__raid_device = int(ln[4])
	self.__state = ' '.join(ln[5:])

    def ident(self):
	return self.__ident

    def number(self):
	return self.__number

    def major(self):
	return self.__major

    def minor(self):
	return self.__minor

    def raid_device(self):
	return self.__raid_device

    def state(self):
	return self.__state

################################################################################
# Raid Superblock
# 
# Info from the raid superblock, retreived using mdadm --examine bdev
#
################################################################################
class RaidSuper:
    def __init__(self, device):
	self.__device = device
	self.__output = None
	self.__fields = None
	self.__disks = None
	self.__events = None

    def __get_output(self):
	if self.__output != None:
	    return self.__output
	try:
	    self.__output = run_shell_cmd('mdadm --examine %s' % self.__device,
					  True)
	except rrdm_error:
	    self.__output = ''
	
	return self.__output

    def __get_fields(self):
	if self.__fields != None:
	    return self.__fields

	self.__fields = {}
	for ln in self.__get_output().splitlines()[1:]:
	    sln = ln.split(' : ', 1)
	    if len(sln) != 2:
		if ln.strip() != '':
		    break
		else:
		    continue

	    self.__fields[sln[0].strip()] = sln[1].strip()

	return self.__fields

    def __lookup_field(self, key):
	fields = self.__get_fields()
	if fields.has_key(key):
	    return fields[key]
	else:
	    return ''

    def magic(self):
	return self.__lookup_field('Magic')

    def version(self):
	return self.__lookup_field('Version')

    def uuid(self):
	return self.__lookup_field('UUID')

    def creation_time(self):
	return self.__lookup_field('Creation Time')

    def raid_level(self):
	return self.__lookup_field('Raid Level')

    #
    # events are special, as we need them as a number
    #
    def events(self):
	if self.__events != None:
		return self.__events

	es = self.__lookup_field('Events').split('.')
	if len(es) != 2:
		return long(0)
	self.__events = (long(es[0]) << 32) + long(es[1])
	return self.__events;

    def checksum(self):
	return self.__lookup_field('Checksum')

    #
    # et al...  add the rest when we need them?
    #

    #
    # create disks if necessary
    #
    def disks(self):
	if self.__disks != None:
	    return self.__disks

	dlns = False
	dlist = []
	for ln in self.__get_output().splitlines()[1:]:
	    if ln.strip() == '':
		continue

	    if dlns:
		dlist.append(RaidSuperDisk(ln))
	    else:
		lns = ln.split()
	    	dlns = len(lns) == 5 and lns[0] == "Number"

	self.__disks = dlist
	return self.__disks

    #
    # lookup a disk by it's ident field (first field in mdadm --examine)
    #
    def lookup_disk(self, key):
	for disk in self.disks():
		if disk.ident() == key:
			return disk
	return None

def stop_md_array(dev_name):
    cmdline = '/sbin/mdadm --stop %s' % dev_name
    run_shell_cmd (cmdline)

def convert_md_status_to_rrdm(status):
    if status == "in_sync":
	return "online"
    elif status == "spare":
	return "rebuilding"
    elif status == "faulty":
        return "failed"
    else:
	return "error"

###############################################################################
# get_hwtool_path
#
# Determine the appropriate hwtool path for the current system 
# environment.  In mfg, hwtool lives in /sbin and in normal mode
# it lives in /opt/hal/bin
#
###############################################################################
def get_hwtool_path():
    config_path	    =	"/opt/tms/lib/hwtool/config/config.xml"
    mfg_config_path =	"/etc/config.xml"

    if exists(config_path):
        cfg_path = config_path
    elif exists (mfg_config_path):
        cfg_path = mfg_config_path
    else:
        print 'Unable to find hwtool configuration file.'
        return (None, None)

    if exists (hwtool_py):
        hwpath  = hwtool_py
    elif exists (mfg_hwtool_py):
        hwpath  = mfg_hwtool_py
    else:
        print 'Unable to find hwtool script'
        return (None, None)

    return (hwpath, cfg_path)


###############################################################################
# get_hwtool_motherboard
#
# Find the system motherboard string for this appliance.
#
###############################################################################
def get_hwtool_motherboard():
    (hwpath, cfgpath) = get_hwtool_path()
    
    if hwpath == None or cfgpath == None:
        return ''

    cmd = '%s -c %s -q motherboard' % (hwpath, cfgpath)
    try:
        mobo = run_shell_cmd (cmd, True)
    except rrdm_error, what:
        return ''

    return mobo.strip()
    
###############################################################################
# get_hwtool_phy_motherboard
#
# Find the physical motherboard string for this appliance. (ONLY VALID FOR BOB)
#
###############################################################################
def get_hwtool_phy_motherboard(): 
    (hwpath, cfgpath) = get_hwtool_path()

    if hwpath == None or cfgpath == None:
        return ''

    cmd = '%s -c %s -q physical-mobo' % (hwpath, cfgpath)
    try:
        mobo = run_shell_cmd (cmd, True)
    except rrdm_error, what: 
        return ''

    return mobo.strip()


def get_disk_list():
    (hwpath, cfgpath) = get_hwtool_path()

    if hwpath == None or cfgpath == None:
        return ''

    cmd = '%s -c %s -q disk=size' % (hwpath, cfgpath)
    try:
        sizes = run_shell_cmd (cmd, True).strip().split('\n')
    except rrdm_error, what:
        return ''

    size_dict = {}
    for elem in sizes:
        try:
            (devname, size) = elem.split(' ')
            size_dict[devname] = size
        except ValueError:
            # Malformed output, keep going
            pass

    return size_dict


class HwtoolDriveList:
    drive_list = None

    def __init__(self):
	if self.drive_list == None:
	    self.drive_list = self.__fill_from_hwtool()

    def rescan(self):
        self.drive_list = self.__fill_from_hwtool()

    def find_bus_by_port(self, port):
        found_bus = None

        for drive in self.drive_list:
            name="disk%s" % port
            try:
                if drive[1] == name:
                    found_bus = drive[0]
                    break
            except IndexError:
                continue

	return found_bus

    def find_devname_by_port (self, port):
	for drive in self.drive_list:
	    name='disk%s' % port
            try:
                if drive[1] == name:
		    if drive[2] != 'missing':
			return drive[2]
                    break
            except IndexError:
                continue

	return None

    def find_state_by_port (self, port):
        for drive in self.drive_list:
            name='disk%s' % port
            try:
                if drive[1] == name:
                    return drive[3]
            except IndexError:
                continue

        return None

    def get_num_hard_disk(self):
	list = self.get_drive_list()
	if list != None:
	    return len(list)
	else:
	    return 0

    ##
    #
    def get_drive_list(self):
        return self.drive_list
	   
    #
    # use hwtool.py to obtain a list of physical drives and 
    # their associated scsi bus number
    #
    def __fill_from_hwtool(self):

	list = []
	cfg_path    =   ''
	hwpath	    =   ''

	try:
            (hwpath, cfg_path) = get_hwtool_path()
            if hwpath == None or cfg_path == None:
                return None

	    cmdline='%s -c %s -q disk=map |grep disk' % (hwpath, cfg_path)
	    drive_list = run_shell_cmd (cmdline, True)
	except rrdm_error, what :
	    # return none and let the caller report an error.
	    return None

	dev_lines = drive_list.split('\n')

	for line in dev_lines:
	    port_bus = line.split(' ')
	    try:
		if port_bus != '':
		    bus = port_bus[0]
		    port = port_bus[1]

		    if port[:4] != 'disk':
			# skip non disk entries.
			continue

		    dev = port_bus[2]
		    state = port_bus[3]

		    list.append((bus, port, dev, state))
	    
	    except IndexError:
		# skip malformed entries
		continue

	return list

def devpath_to_devname(dev_path):
    if dev_path == '':
        return ''
    elif dev_path[0:5] == '/dev/':
        return dev_path[5:]
    elif dev_path[0] == '/':
        return dev_path[1:]
    else:
        return dev_path
        

## DiskInfo object
# holds the specific metadata describing a particular disk.
class DiskInfo:
    ## initializer
    # @param devpath either a device /dev/diskX or diskX
    # @hwtool_state if we know the disks state from hwtool it can be passed in
    #
    def __init__(self, devpath='', hwtool_state=None): 
        self.__devpath = devpath

        self.__serial   = ''
        self.__fw       = ''
        self.__media    = ''

        ## Physical state variables for a disk
        # States can be 
        # ok : all is good
        # failed : IO error talking to the drive, or hwtool tells us its offline
        # missing : disk is missing
        self.__state_ok         = 'ok'
        self.__state_failed     = 'failed'
        self.__state_missing    = 'missing'
        self.__state_unknown    = 'unknown'
        self.__dm               = DiskMedia()

        if hwtool_state == None:
            self.__set_state(self.__state_unknown)
        else:
            if hwtool_state == 'online':
                self.__set_state(self.__state_ok)
            elif hwtool_state == 'offline':
                self.__set_state(self.__state_failed)
            elif hwtool_state == 'missing':
                self.__set_state(self.__state_missing) 

    ## Textual representation of the disk object
    def __str__(self):
        return '%s : %s : %s : %s : %s\n' % (self.__devpath, 
                self.__serial, self.__fw, self.__media, self.__state)

    ## Internal utility to update the state
    def __set_state(self, state):
        self.__state = state

    ####### External Interfaces ###############################################

    ## Populate the DiskInfo object from a line of diskinfo outut
    # @param diskinfo_line single row of diskinfo output
    #
    # In failure cases, diskinfo might tell us the disk is failed or missing
    # in such cases, it passes the serial/fw strings as ERROR or MISSING
    #
    def fill_from_diskinfo(self, diskinfo_line):
        parts = diskinfo_line.strip().split(' ')
        if len(parts) >= 4:
            self.__devpath = parts[0]

            self.__serial   = parts[1]
            self.__fw       = parts[2]
            # we'll standardize on lower case
            self.__media    = parts[3].lower()
        
            lserial = self.__serial.lower()

            if lserial == 'error': 
                self.__set_state(self.__state_failed)
            elif lserial == 'missing':
                self.__set_state(self.__state_missing)
            else:
                self.__set_state(self.__state_ok)
        else:
            # skip the invalid entry
            pass

    def get_devpath(self):
        return self.__devpath

    def have_valid_info(self):
        return self.__state == self.__state_ok

    def get_media(self):
        return self.__media

    def is_ssd(self):
        return self.__media == DiskMedia.media_type_ssd

    def is_disk(self):
        return self.__media == DiskMedia.media_type_disk

    def get_serial(self):
        return self.__serial

    def get_fw(self):
        return self.__fw

## HwtoolDiskLicenseMap
# maintains a dictionary mapping drive port numbers to whether or not the 
# disk is licensed.
# 
# raises an rrdm_error if hwtool can't be found, or hwtool fails
class HwtoolDiskLicenseMap:
    def __init__(self, fill = False):
        self.__licensed_map = None

        if fill == True:
            self.__fill_from_hwtool()

    ## Return the string representation of the license disk map
    def __str__(self):
        result = ''
        if self.__licensed_map != None:
            for entry in self.__licensed_map.keys():
                result += '%s : %s \n' % (entry, str(self.__licensed_map[entry]))

        return result
    
    ## read the disk licensing information using hwtool
    def __fill_from_hwtool(self):
        (hwpath, cfg_path) = get_hwtool_path()
        if hwpath == None or cfg_path == None:
            raise rrdm_error ('Unable to find hwtool')
    
        cmdline='%s -c %s -q disk-license |grep disk' % (hwpath, cfg_path)
        licensed_drive = run_shell_cmd (cmdline, True)

        for line in licensed_drive.strip().split('\n'):
            if line != '':
                parts = line.split(' ')
                if len(parts) >= 2:
                    disk_port = parts[0][4:]
                    licensed = (parts[1].lower() == 'licensed')

                    if self.__licensed_map == None:
                        self.__licensed_map = {}
                    self.__licensed_map[disk_port] = licensed
    
    ####### External Interfaces ##############################################

    ## Repopulate the license map from hardware
    def rescan(self):
        self.__fill_from_hwtool()

    # Return True if the disk is licensed False otherwise
    # @param port string disk port number (i.e. '1', '2')
    def is_licensed(self, port):
        if self.__licensed_map == None:
            self.__fill_from_hwtool()

        if self.__licensed_map.has_key(port):
            return self.__licensed_map[port]
        else:
            return False
        

## DiskInfoClass
# wraps disk attributes such as the serial number, firmware revision, media
# type, etc.
#
# Currently this is only using the output of diskinfo, but we'll migrate
# the rest of the sysfs disk params
#
class DiskInfoMap:
    def __init__(self, disk_map=None):
        self.__mfg_disk_image = '/mfg/diskinfo'
        self.__image_disk_image = '/opt/tms/bin/diskinfo'
        if exists(self.__image_disk_image): 
            self.__disk_info_path = self.__image_disk_image
        else:
            self.__disk_info_path = self.__mfg_disk_image

        self.__disk_list = None
        self.__hwtool_disk_map = disk_map

        if disk_map != None:
            self.__populate_from_disk_map(disk_map)

    ## Textual representation of the DiskInfoMap
    def __str__(self):
        result = ''
        result += 'DiskInfoMap [%d]\n' % len(self.__disk_list)
        for entry in self.__disk_list.values():
            result += str(entry)

        return result

    ## Given the disk information in the disk_map, read in the 
    # additional disk fields using diskinfo
    # @param disk_map HwtoolDiskMap structure
    #
    def __populate_from_disk_map(self, disk_map):
        dev_list = ''
        self.__disk_list = {}

        self.__hwtool_disk_map = disk_map
        for entry in disk_map.get_drive_list():
            dev     = entry[1]
            dev_path = '/dev/%s' % dev
            state = entry[3]

            if state == 'online':
                dev_list = '%s %s' % (dev_list, dev_path)
            else:
                dinfo = DiskInfo(dev_path, state)
                self.__disk_list[dev] = dinfo

        cmd_line = '%s %s' % (self.__disk_info_path, dev_list)
        output = run_shell_cmd (cmd_line, True)
        for line in output.strip().split("\n"):
            parts = line.split(' ')
            if parts == '':
                continue

            dinfo = DiskInfo()
            dinfo.fill_from_diskinfo(line)
            self.__disk_list[devpath_to_devname(dinfo.get_devpath())] = dinfo

    ####### External Interfaces ###############################################

    ## Returns a DiskInfo object given the indicated device
    # @param dev_str device name or disk name (/dev/disk0, or disk0)
    #
    def get_disk_info(self, dev_str):
        if self.__disk_list == None:
            self.__populate_from_disk_map(hwtool_disk_map)

        dev_name = devpath_to_devname(dev_str)
        if self.__disk_list.has_key(dev_name):
            return self.__disk_list[dev_name]
        else:
            return None

    ## Repopulate the disk information from the current appliance state.
    def rescan(self):
        hwtool_disk_map.rescan()
        self.__populate_from_disk_map(hwtool_disk_map)

class DiskMedia:
    media_type_ssd  = 'ssd'
    media_type_disk = 'disk'
    supported_media_types = [ media_type_ssd, media_type_disk ]

    def is_valid_media_type(self, media):
        return media in self.supported_media_types

    def is_ssd(self, media):
        return media == DiskMedia.media_type_ssd

    def is_disk(self, media):
        return media == DiskMedia.media_type_disk


## Wrapper around how disk status is determined for appliance disks
# the two modes of operation today are:
# mgmt : for non-raided units, status is determined by presence in the system
#        for raided units, status is determined by disk presence, then 
#           additionally the state of any raid arrays that live on that disk.
# fts  : For FTS disk we don't have any raid arrays, but we want
#        to enforce the rule that disks need to be in the proper position
#        for us to add them to the segstore.
#
class DiskStatusMode:
    # local variables describing the available states.
    mode_type_fts           = 'fts'
    mode_type_mgmt_legacy   = 'mgmt'
    mode_type_seg_vsh       = 'vsh'
    
    mode_type_invalid       = 'invalid'
    
    supported_modes  = [ mode_type_fts, mode_type_mgmt_legacy, mode_type_seg_vsh ]

    def __init__(self, mode_str):
        mode = mode_str.lower()
        if mode in self.supported_modes:
            self.__mode = mode
        else:   
            self.__mode = self.mode_type_invalid

    def __str__(self):
        return self.__mode
    
    ####### External Interfaces ###############################################
    def is_fts_mode(self):
        return self.__mode == self.mode_type_fts
        
    def is_mgmt_mode(self):
        return self.__mode == self.mode_type_mgmt

    def is_valid(self):
        return self.__mode in self.supported_modes

## SystemDiskStatus information for a disk
# When we fail a disk, we set state on the filesystem to indicate that the drive 
# slot has failed. This class wraps that state so applications should know
# whether or not to use a drive in a particular slot.
#
# This is used mainly for FTS disks where the disks do not maintain a notion
# of their health (the segstore knows that info)
#
class SystemDiskStatus:
    def __init__(self, portnum):
        self.__dconfig_path = '/config/disk'
        self.__portnum = portnum
        self.__dfile = '%s/disk%d_failed' % (self.__dconfig_path, self.__portnum)

    def is_failed(self):
        return exists(self.__dfile)

    def is_online(self):
        return not exists(self.__dfile)

## ApplianceInfo class wrapping the serial number of the appliance
# For the serial number it uses a class local variable, so only
# the first time it is instantiated will the serial be filled in
# The serial number is considered to be a static appliance
# value (as opposed to the model, which can change due to flexl).
#
class ApplianceInfo:
    appliance_serial = None
    def __init__(self):
        if not ApplianceInfo.appliance_serial:
            ApplianceInfo.appliance_serial = self.__get_serial()

    ## Internal routine to fetch the serial number from the system
    # which works in both mfg mode and running mode.
    #
    def __get_serial(self):
        mddbreq_path = '/opt/tms/bin/mddbreq'
        mfg_serial_path = '/mfg/serial_num'

        if exists(mfg_serial_path):
            try:
                fh = open(mfg_serial_path, 'r')
                serial = fh.read().strip()
            finally:
                fh.close()
        else:
            if not exists (mddbreq_path):
                # we can't get the model.
                return None

            # grab the model from hald_model
            cmd = '%s -v /config/mfg/mfdb query get - /rbt/mfd/serialnum' % \
                   mddbreq_path

            pf = popen (cmd)
            serial  = pf.read().strip()
            rcode = pf.close()

            if rcode:
                return None

        return serial

    ## Fetch the serial number, on success return the value,
    # or none if we can't for some reason determine the serial
    def get_serial(self):
        if not ApplianceInfo.appliance_serial:
            ApplianceInfo.appliance_serial = self.__get_serial()

        return ApplianceInfo.appliance_serial

## Class to wrap the state of the system disk LED's
# Does lazy loading, only when you request data.  Will not fetch
# data multiple times without allocating a new class instance. 
#
class DiskLEDMap:
    hw_ctl_py           = '/opt/hal/bin/hw_ctl.py'
    hw_ctl_led_cmd      = '%s -Rr hdd fault_led_on' % hw_ctl_py

    def __init__(self):
        self.__disk_led_state_map  = None

    ## Return a string representation of the DiskLEDMap or nothing
    # if we are unable to get disk led status
    def __str__(self):
        result = ''

        if not self.__disk_led_state_map:
            self.__populate_from_system_info()

        if not self.__disk_led_state_map:
            return result

        for key in self.__disk_led_state_map.keys():
            result += '%s:%s\n' % (key, self.__disk_led_state_map[key])

        return result

    ## Fill in the class variables with the data using the batched hw_ctl.py 
    # command
    #
    def __populate_from_system_info(self):
        if not exists(self.hw_ctl_py):
            # we won't update the map
            self.disk_led_state_map = None
            return

        output = run_shell_cmd(self.hw_ctl_led_cmd, True)
        if not output or output.strip() == '':
            # invalid output, clear the cache
            self.__disk_led_state_map = None
            return

        self.__disk_led_state_map = {}

        lines = output.split('\n')
        for line in lines:
            parts = line.split('=')
            if len(parts) != 2:
                # malformed entry skip updating the map
                continue

            led_state   = parts[1].strip().lower()
            try:
                disk_num    = int(parts[0].split('(hdd)')[0])
            except ValueError:
                continue

            if led_state == 'true':
                state = True
            elif led_state == 'false':
                state = False
            else:
                # invalid entry, skip updating the map
                break

            self.__disk_led_state_map[disk_num] = state

    ## Return a boolean (or None if no state is found) indicating disk led state
    # @param port integer port number
    def led_is_on(self, port):
        if not self.__disk_led_state_map:
            self.__populate_from_system_info()

        if not self.__disk_led_state_map:
            return None
        else:
            if self.__disk_led_state_map.has_key(port):
                return self.__disk_led_state_map[port]
            else:
                return None

hwtool_disk_map = HwtoolDriveList()
hwtool_dlm      = HwtoolDiskLicenseMap()

# the disk info map will be populated the first time someone asks it for information
disk_info_map = DiskInfoMap()

## Class to wrap model specific SSD meta information such as
# erase block size (bytes)
# write_lifetime (GB)
#
class SSDDiskWearInfo:
    def __init__(self, eb_size, write_lifetime):
        self.__eb_size = eb_size
        self.__write_lifetime = write_lifetime

    def get_erase_block_size(self):
        return self.__eb_size

    def get_max_write_lifetime(self):
        return self.__write_lifetime

# Each drive model we support gets an erase block entry.
# erase_block_size is given in bytes
# max_write_lifetime is given in GB
#
# We typically fetch the model from sysfs, and sysfs truncates the
# model to 16 characters, therefore, the key index is based on the truncated
# value.
model_to_ssdinfo_map = { "ATP Industrial S":SSDDiskWearInfo(524288,15360),
			 "INTEL SSDSA2MH16":SSDDiskWearInfo(524288,15360),
			 "SAMSUNG MMDOE56G":SSDDiskWearInfo(524288,15360),
			 "INTEL SSDSA2CW08":SSDDiskWearInfo(524288,640000),
			 "INTEL SSDSA2M160":SSDDiskWearInfo(524288,640000),
			 "INTEL SSDSA2CW16":SSDDiskWearInfo(524288,640000),
			 "INTEL SSDSA2CW30":SSDDiskWearInfo(524288,640000)
		       }
